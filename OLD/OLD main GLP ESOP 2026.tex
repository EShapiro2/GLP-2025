\documentclass[runningheads,thm-restate]{llncs}

% Essential packages for LNCS
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{xspace}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{xcolor}
\usepackage{enumitem}

% Algorithm packages
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

% Your specific packages
\usepackage{multirow}
\usepackage{mathtools}
\usepackage{relsize}
\usepackage{bm}
\usepackage{verbatimbox}
\usepackage{wrapfig}
\usepackage{thmtools}

% Your custom formatting commands
\newcommand{\mypara}[1]{\smallskip\noindent\textbf{#1.}}
\newcommand{\temph}[1]{\textbf{#1}}  % or use \emph{#1}
\newcommand{\remove}[1]{}
\newcommand{\udi}[1]{\textcolor{blue}{[Udi says: #1]}}
\newcommand{\claude}[1]{\textcolor{red}{[Claude: #1]}}

% Your abbreviation commands
\newcommand{\glp}{\textsc{GLP}\xspace}
\newcommand{\lp}{logic programs\xspace}
\newcommand{\cp}{Concurrent Prolog\xspace}
\newcommand{\scl}{\textsc{scl}\xspace}
\newcommand{\gsn}{\textsc{gsn}\xspace}

% Your math commands
\newcommand{\calV}{\mathcal{V}}
\newcommand{\calG}{\mathcal{G}}
\newcommand{\calT}{\mathcal{T}}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calR}{\mathbb{R}}
\newcommand{\calN}{\mathbb{N}}
\newcommand{\calA}{\mathcal{A}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\calS}{\mathcal{S}}
\newcommand{\calL}{\mathcal{L}}
\newcommand{\calP}{\mathcal{P}}
\newcommand{\calM}{\mathcal{M}}
\newcommand{\calE}{\mathcal{E}}
\newcommand{\calB}{\mathcal{B}}
\newcommand{\calC}{\mathcal{C}}
\newcommand{\calX}{\mathcal{X}}
\newcommand{\calD}{\mathcal{D}}

% Roman numeral abbreviations
\newcommand{\ia}{\textit{i}}
\newcommand{\ib}{\textit{ii}}
\newcommand{\ic}{\textit{iii}}
\newcommand{\id}{\textit{iv}}
\newcommand{\iie}{\textit{v}}
\newcommand{\iif}{\textit{vi}}
\newcommand{\iiv}{\textit{iv}}
\newcommand{\iv}{\textit{v}}

% Program counter for examples
\newcounter{pc}
\newcommand\spc{\addtocounter{pc}{1}\thepc}
\newcommand{\Program}[1]{\medskip\noindent\textbf{Program \spc: #1}\vspace{-5pt}}

% Define Program environment with automatic verbatim and small
\newenvironment{programcode}
{\begin{small}\begin{verbatim}}
{\end{verbatim}\end{small}}

% Redefine Program command to use the new environment
%\renewcommand{\Program}[1]{%
%  \medskip\noindent\textbf{Program \spc: #1}\vspace{-5pt}%
%  \begin{programcode}%
%}
%\newcommand{\endProgram}{\end{programcode}}






% Set list spacing

\setlist{nosep, leftmargin=*}
\setlist{itemsep=1pt, topsep=3pt, leftmargin=*}

\newtheorem{observation}{Observation}

\raggedbottom  % Prevents vertical justification

% Bibliography style
\bibliographystyle{plain}  % Use plain since you don't have splncs04.bst

\begin{document}

\title{\smaller Grassroots Logic Programs:
A Secure, Multiagent, Concurrent, Logic Programming Language}

\author{Anonymous}
\authorrunning{Anonymous}
\institute{Anonymous}

%\author{Ehud Shapiro}

%\authorrunning{E. Shapiro}

%\institute{Weizmann Institute of Science, Rehovot, Israel\\ London School of Economics and Political Science, UK\\
%\email{ehud.shapiro@weizmann.ac.il}}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Grassroots platforms are distributed applications run by\linebreak cryptographically-identified people on their networrked personal devices, where multiple disjoint platform instances emerge independently and coalesce when they interoperate. Their foundation is the grassroots social graph, upon which grassroots social networks, grassroots cryptocurrencies, and grassroots democratic federations can be built. In the social graph, nodes represent people, edges—authenticated friendships, and connected components arise spontaneously and interconnect through befriending.  

Grassroots platforms have yet to be implemented, the key challenge being faulty and malicious participants:  without secure programming support, correct participants cannot reliably identify each other, establish secure communication, or verify each other's code integrity.  A programming language providing such support, combined with useful abstractions for grassroots platforms, may offer the most effective path to realizing them.  This is especially true with AI-supported programming, as a higher level of abstraction would facilitate more effective programmer-AI communication.

We present Grassroots Logic Programs (GLP), a secure, multiagent, concurrent, logic programming language for implementing grassroots platforms. GLP extends logic programs with paired reader/writer variables (akin to futures and promises), providing secure communication channels between authenticated friends. Language-level attestations enable participants to verify each other's identity and code integrity.

We present GLP in five steps, 
starting from the abstract computational model of logic programs and ending in `implementation-ready', secure, multiagent, transition system specification of GLP, injecting illustrative programming examples along the way: (\ia) Use transition systems to define the operational semantics of standard logic programs (LP)  (\ib) Extend LP to concurrent GLP with communication and synchronization, and prove safety properties, including that GLP computations are deductions (\ic) Employ multiagent transition systems to define multiagent concurrent GLP and prove the resulting language to be grassroots (\iiv) Augment communication with encryption, signatures and attestations, resulting in secure, multiagent, concurrent GLP, prove its security properties and that GLP streams enjoy the security of blockchains and interlaced streams—of blocklaces. (\iv) Replace nondeterministic goal reduction with goal deterministic scheduling, suspension and activation, and replace `magical' push-based writer-to-reader communication with shared-variable tables that support pull-based routing that withstands dynamic variable migration.

We present a GLP grassroots social graph protocol that establishes authenticated peer-to-peer connections through cold calls and friend introductions, and upon this foundation present a secure grassroots social network platform supporting direct messaging, content distribution with cryptographic provenance, and group communication via interlaced streams for causal consistency without consensus.
\end{abstract}


\section{Introduction}

Grassroots platforms~\cite{shapiro2023grassrootsBA} are distributed applications in which multiple disjoint platform instances emerge independently and coalesce when they interoperate. They are run by people on their personal devices, who are identified cryptographically~\cite{rivest1978method}, communicate only with authenticated friends, and can participate in multiple instances of different grassroots platforms simultaneously. The grassroots social graph~\cite{shapiro2023gsn} is both a platform in its own right and the foundational infrastructure layer for all other grassroots platforms. In it, nodes represent people, edges—authenticated friendships, and connected components arise spontaneously and interconnect through befriending. Communication in grassroots platforms, except for befriending across disconnected components, occurs only along graph edges, signed and encrypted to ensure authenticity and privacy. Upon this foundation, grassroots social networks~\cite{shapiro2023gsn}, grassroots cryptocurrencies~\cite{shapiro2024gc}, and grassroots democratic federations~\cite{shapiro2025GF} are built.

A key challenge in implementing grassroots platforms is overcoming faulty and malicious participants~\cite{lamport1982byzantine}. Without secure language support, correct participants cannot reliably identify each other, establish secure communication channels, or verify each other's code integrity~\cite{sabt2015trusted,costan2016intel}. 
While grassroots platforms have been formally specified and their properties mathematically proven~\cite{shapiro2023grassrootsBA,shapiro2023gsn,shapiro2024gc,shapiro2025GF,shapiro2025atomic}, they are so far theoretical constructions without an actual implementation. The specifications define what these platforms should achieve—sovereignty, privacy, grassroots emergence—but not how to program them. No existing programming language provides the necessary combination of distributed execution, cryptographic security, and formal guarantees required to realize these specifications. Grassroots Logic Programs aim to close the gap between the mathematical specifications and an actual implementation.

Our goal here is to design a high-level, secure, multi-agent, concurrent programming language suitable for the implementation of grassroots platforms. To do so, the language should address:
\begin{enumerate}
\item Mutual authentication~\cite{boyd2003protocols} enabling people to identify each other and verify each other's code identity and integrity
\item Grassroots social graph formation through both cold calls (for bootstrap and connecting disconnected components) and friend-mediated introductions
\item Secure communication among friends
\item Multiagent formal semantics~\cite{shapiro2021multiagent} with well-defined safety and liveness properties~\cite{alpern1985defining}
\end{enumerate}

We present Grassroots Logic Programs (GLP), a secure, multiagent, concurrent, logic programming language designed for implementing grassroots platforms. 
GLP extends logic programs~\cite{lloyd1987foundations,sterling1994art} with paired reader/writer variables (akin to futures and promises~\cite{dauth2019futures,azadbakht2020formal}), each establishing a secure communication channel between authenticated friends, with these shared logic variables enabling all subsequent secure communication. Such bidirectional channels serve as edges in the social graph. The single-reader/single-writer (SRSW) invariant enables signed and encrypted communication via these variables, preventing malicious participants from intercepting or forging messages, and as we prove, enables GLP streams to achieve blockchain security properties~\cite{nakamoto2008peer}.

Through attestation transactions~\cite{shapiro2025atomic} at the language level, participants verify each other's identity and each other's code integrity when befriending. These mechanisms enable both cold calls (for bootstrap and connecting disconnected components) and friend-mediated introductions (the preferred trust propagation method).

We present Grassroots Logic Programs and prove their properties in four steps, injecting illustrative programming examples along the way: 
\begin{enumerate}
\item \textbf{Logic Programs:} Define a transition system-based operational semantics for standard logic programs (LP)~\cite{lloyd1987foundations,sterling1994art}, in which the configuration (state) is a resolvent and the transition is goal/clause reduction. 

\item \textbf{Concurrent GLP:} Extend LP with reader/writer pairs, which must satisfy the Single-Reader/Single-Writer (SRSW) requirement; extend unification to suspend upon an attempt to bind a reader, extend configurations to include pending assignments to readers, extend transitions to include the application of an assignment from a writer to its paired reader, and thus provide interleaving-based asynchronous operational semantics for concurrent GLP. Prove safety properties~\cite{alpern1985defining}, including that GLP computations are deductions~\cite{kowalski1974predicate,lloyd1987foundations}. 

\item \textbf{Multiagent, Concurrent GLP:} Employ multiagent transition systems~\cite{shapiro2021multiagent} with atomic transactions~\cite{shapiro2025atomic} to define the operational semantics of multiagent concurrent GLP, in which a set of identified agents reduce the resolvent cooperatively. Reduction is a unary transaction, cross-agent communication is a binary transaction among the sender and recipient, and the network provides for agents to bootstrap shared logic variables. Prove multiagent GLP is grassroots~\cite{shapiro2023grassrootsBA}. 

\item \textbf{Secure, Multiagent, Concurrent GLP:} Augment agents with self-chosen keypairs and augment cross-agent assignments with encryption, signatures and attestations, resulting in secure, multiagent, concurrent GLP. Prove its security properties required for distributed systems~\cite{coulouris2011distributed} and that GLP streams enjoy the security properties of blockchains~\cite{nakamoto2008peer}.
\end{enumerate}


The remainder of this paper is organized as follows. Section~\ref{section:multiagent-glp} extends the semantics of logic programs to the standard (single-agent) interleaving operational semantics of GLP.  Section~\ref{section:GLP-multiagent} extends it further to a multi-agent operational semantics via atomic transactions, in which the goal reduction performed by an agent also affects the state of agents with readers for which the writers are instantiated by the reduction.
Section~\ref{section:safety-fairness-liveness} establishes safety, fairness, and liveness properties. 
%
Section~\ref{section:glp-security} proves GLP's security properties and that GLP streams achieve blockchain security. Section~\ref{section:logical-and-grassroots} proves that GLP computations are deductions and that GLP is grassroots. Section~\ref{section:programming-examples} presents basic GLP programming techniques. Section~\ref{section:social-graph} implements the social graph protocol. Section~\ref{section:social-networking} demonstrates social networking applications. Section~\ref{section:related-work} reviews related work, and Section~\ref{section:conclusions} concludes.


\section{Logic Programs}\label{section:lp}

We introduce the notion of transition systems and use them to recall standard Logic Programs (LP): syntax, the notion of most-general unifier (mgu), operational semantics via nondeterministic goal/clause reduction, and a proof that LP computations are deductions. The construction of Grassroots Logic Programs will proceed by extending Logic Programs, and of and Multiagent Grassroots Logic Programs by first extending transition systems to multiagent transition systems, and then using them to extend Grassroots Logic Programs to Multiagent Grassroots Logic Programs.

\subsection{Transition Systems}

Here we introduce transition systems, which provide the formal framework for defining the operational semantics of both Logic Programs and Grassroots Logic Programs.
We use $\subset$ to denote the strict subset relation and $\subseteq$ when equality is also possible, and $a\ne b \in S$ as a shorthand for $a\ne b\wedge q\in S \wedge b\in S$.

\begin{definition}[Transition System]\label{definition:ts}
A \temph{transition system} is a tuple $TS = (C, c0, T)$ where:
\begin{itemize}
    \item $C$ is a set of \temph{configurations}
    \item $c0 \in C$ is the \temph{initial configuration}
    \item $T \subseteq C \times C$ is a \temph{transition relation}. A transition $(c,c') \in T$ is also written as $c \rightarrow c' \in T$.
\end{itemize}
A transition $c \rightarrow c' \in T$ is \temph{enabled} from configuration $c$. A configuration $c$ is \temph{terminal} if no transitions are enabled from $c$. A \temph{computation} is a (finite or infinite) sequence of configurations where for each two consecutive configurations $(c,c')$ in the sequence, $c \rightarrow c' \in T$. A \temph{run} is a computation starting from $c0$, which is \temph{complete} if it is infinite or ends in a terminal configuration.
\end{definition}
Definition~\ref{definition:ts} uses `configuration' rather than the more standard `state'  to avoid confusion with the `local state' of agents in a multiagent transition system, Definition~\ref{definition:mts}.

%Safety properties for transition systems are typically proved by induction on computation length, establishing that invariants hold in every reachable state. Liveness properties require reasoning about infinite computations, often using fairness assumptions to ensure that enabled transitions eventually occur.

\subsection{Logic Programs Syntax}

The syntax of Logic Programs follows the standard in logic programming and Prolog, and is formally defined
in Appendix~\ref{appendix:lp}.
We recall the quintessential logic program for list concatenation as an example:
\begin{example}[Append]
\begin{verbatim}
append([X|Xs], Ys, [X|Zs]) :- append(Xs, Ys, Zs).
append([], Ys, Ys).
\end{verbatim}
Logically, a logic program clause $A$\verb|:-| $B$ is a universally-quantified implication in which $B$ implies $A$, and a program is a conjunction of its clauses.
By convention, we use plural variable names like \verb|Xs| to denote lists of elements, where the \verb|s| suffix suggests plurality. 
%The first clause states that appending an empty list to any list \verb|Ys| yields \verb|Ys|. The second clause states that appending a list with head \verb|X| and tail \verb|Xs| to \verb|Ys| yields a list with the same head \verb|X| and tail \verb|Zs|, if \verb|Zs| is the result of appending \verb|Xs| to \verb|Ys|.
\end{example}


\subsection{Logic Programs Operational Semantics}



\begin{definition}[Substitution, Instance, Unifier, Most-General Unifier]\label{definition:substitution}
A \temph{substitution} $\sigma$ is an idempotent function $\sigma: V \xrightarrow{} \calT$, namely a mapping from variables to terms applied to a fixed point. By convention, $\sigma(x)=x\sigma$.
\begin{itemize}
    \item Given a substitution $\sigma$, $V_\sigma := \{ X \in V ~|~ X\sigma \ne X\}$.
    \item Given a term $T \in \calT$ and a substitution $\sigma$, then $T\sigma$ is term obtained from $T$ by replacing every variable $X \in T$ by the term $X\sigma$.
    \item The partial order on terms $\preceq \subset \calT \times \calT$ is defined by $T \preceq T'$, or $T'$ is an \temph{instance} of $T$, if there is a substitution $\sigma$ for which $T\sigma = T'$, and 
    $T \simeq T'$ if $T \preceq T'$ and $T' \preceq T$.
    If $T \ne T\sigma$ we say that $\sigma$ \temph{instantiates} $T$. 
   
    \item For substitutions $\sigma$ and $\sigma'$, $\sigma \preceq \sigma'$ if for every $T \in \calT$, $T\sigma \preceq T\sigma'$, and $\sigma \simeq \sigma'$ if for every $T \in \calT$, $T\sigma \simeq T\sigma'$.
    
    \item A substitution $\sigma$ is \temph{as general as} substitution $\sigma'$ if $V_\sigma \subseteq V_{\sigma'}$ and $\sigma \preceq \sigma'$.
    \item A substitution $\sigma$ is a \temph{unifier} of two terms $T, T' \in \calT$ if $T\sigma = T'\sigma$; it is a \temph{most-general unifier (mgu)} of $T, T'$ if in addition it is as general as any other unifier of $T$ and $T'$.
\end{itemize}
\end{definition}

Namely, a most general unifier is frugal both in its domain (not instantiating variables unnecessarily) and in its range (not instantiating variables more than necessary).

\begin{remark}[Substitution as Assignment Set]
We equivalently view a substitution $\sigma$ as a set of assignments $\{X_1:=T_1, \ldots, X_n:=T_n\}$ where $X_i\sigma = T_i$. Thus the singleton substitution mapping $X$ to $T$ is $\{X:=T\}$, its application $T\sigma$ may be written $T\{X:=T\}$, the empty substitution is $\emptyset$, and compatible substitution composition corresponds to set union.
\end{remark}


\begin{definition}[Renaming, Rename apart]\label{definition:renaming}
A \temph{renaming} is a substitution $\sigma: V \mapsto V$ that maps variables to variables.
A renaming $\sigma$ renames $T'$ \temph{apart from} $T$ if $T$ and $T'\sigma$ have no variable in common.
\end{definition}
We assume a deterministic renaming-apart function, so that the result of renaming $T'$ apart from $T$ is well defined.
Next we define the operational semantics of Logic Programs via a transition system.
 
\begin{definition}[LP Goal/Clause Reduction]\label{definition:logic-goal-clause-reduction}
Given LP goal $A$ and clause $C$,  with $H \verb|:-| B$ being the result of renaming $C$ apart from $A$, the \temph{LP reduction} of $A$ with $C$ \temph{succeeds with result} $(B,\sigma)$ if $A$ and $H$ have an mgu $\sigma$,  else \temph{fails}.
\end{definition}


\begin{definition}[Logic Programs Transition System]\label{definition:lp-ts}
A transition system $LP = (C,c0, T)$ is a \temph{Logic Programs transition system} for a logic program $M$ and initial goal $G_0 \in \mathcal{G}(M)$ if 
$C=\mathcal{G}(M)$, $s0=G_0$, and $T$
is the set of all transitions $G \rightarrow G' \in \mathcal{G}(M)^2$ such that for some atom $A \in G$ and clause $C \in M$  the LP reduction of $A$ with $C$ succeeds with result $(B,\sigma)$, and $G' = (G \setminus \{A\} \cup B)\sigma$.
\end{definition}
We write $G \xrightarrow{\sigma} G'$ when we want to make the substitution of a reduction explicit.
As a tribute to resolution theorem proving~\cite{robinson1965machine}—the intellectual ancestor of logic programming—a configuration of $LP$ is also referred to as a \emph{resolvent}.
%
Note that $LP$ is nondeterministic in its choices of both $A\in G$ (called \emph{and-nondeterminism}) and  $C\in M$ (called \emph{or-nondeterminism}).  Thus, as an abstract model of computation, Logic Programs  are  closely-related to \emph{Alternating Turing Machines}, a generalization of Nondeterministic Turing Machines~\cite{shapiro1984alternation}.

\begin{definition}[Proper Run and Outcome]\label{definition:proper-run}
A run $\rho: G_0 \xrightarrow{\sigma_1} G_1 \xrightarrow{\sigma_2} \cdots \xrightarrow{\sigma_n} G_n$ of $LP$ is \temph{proper} if for any $1\le i<  n$,  a variable that occurs in  $G_{i+1}$ but not in  $G_i$ also does not occur in any $G_j$, $j<i$.   If proper, the \temph{outcome} of $\rho$ is $(G_0 \verb|:-| G_n)\sigma$ where $\sigma = \sigma_1 \circ \sigma_2 \circ \cdots \circ \sigma_n$.
\end{definition}
While we use LP transition systems to define the operational semantics of Logic Programs, it so happens that the set of all outcomes of all proper runs of a logic program constitutes its fully-abstract compositional semantics~\cite{gaifman1989fully}.
Next we prove the key safety property of LP:

\begin{restatable}[LP Computation is Deduction]{proposition}{LPComputationisDeduction}\label{proposition:LP-computation-deduction}
The outcome\linebreak $(G_0$ :- $G_n)\sigma$ 
of a proper run $\rho: G_0 \xrightarrow{\sigma_1} G_1 \xrightarrow{\sigma_2} \cdots \xrightarrow{\sigma_n} G_n$ of $LP$  is a logical consequence of $M$, where $\sigma = \sigma_1 \circ \sigma_2 \circ \cdots \circ \sigma_n$.
\end{restatable}

\section{Grassroots Logic Programs}\label{section:glp}

We present Grassroots Logic Programs (GLP) as an extension of Logic Programs: The syntax is extended with reader variables $X?$, where $X$ and $X?$ form a reader/writer pair, and the Single-Reader/Single-Writer (SRSW) restriction on clauses.  For example, here is the quintessential concurrent logic program for merging two streams (incrementally constructed, potentially unbounded lists), written in GLP.  Its first two arguments are the input streams to be merged, and the third is the merged output stream:

\Program{GLP Fair Stream Merger}\label{program:merge}
\begin{small}
\begin{verbatim}
merge([X|Xs],Ys,[X?|Zs?]) :- merge(Ys?,Xs?,Zs). % output from first stream
merge(Xs,[Y|Ys],[Y?|Zs?]) :- merge(Xs?,Ys?,Zs). % output from second stream
merge([],[],[]).                                % terminate on empty streams
\end{verbatim}
\end{small}
Note that in each clause, every reader or writer occurs at most once.

The operational semantics of GLP extends that of LP as follows:
\begin{enumerate}
\item \textbf{Synchronisation}: Unification may only instantiate writers, so in addition to succeed/fail, unification may suspend when it requires instantiating readers.
\item \textbf{Communication}: When a unifying writer substitution binds a writer $X$ to a term $T$, the message  $X? := T$ encoding its reader counterpart substitution is created and added to the configuration. Its application happens asynchronously, realizing a message $T$ from the single occurrence of $X$ to the single occurrence of $X?$. 
\item \textbf{Deterministic clause selection}: The first applicable clause is chosen (not nondeterministically as in LP). This implies the fairness of \verb|merge| presented above:  As long as the two input streams are available the output dovetails the two inputs, due to the switch of the order of arguments in the recursive call of the first clause; if only one is available, its elements are copied to the output; and if both unavailable the goal suspends.
\end{enumerate}

\subsection{GLP Syntax}

\mypara{Reader/Writer pairs}
GLP extends Logic Programs with paired reader/writer variables, where a \emph{writer} $X$ is a single-assignment variable (promise) and its \emph{paired reader $X?$} provides read-only access to the (future) value of $X$. We denote by $V$ the set of all writers, $V?$ the set of all readers and, $\mathcal{V} = V \cup V?$ the set of all variables, where for each writer $X \in V$ there exists a paired reader $X? \in V?$.  
We view $?$ as an identity suffix operator on non-writers, namely  $(X?)?=X?$ for $X?\in V?$ and $T?=T$ for $T\notin \calV$. 
We use $\calA_?$ and $\calG_?$ to denote the set of all atoms and goals, respectively, over $\calV$ (i.e., goals that may contain both readers and writers), and for a GLP program $M$,  $\calA_?(M)$  and $\calG_?(M)$ to denote the subsets of  $\calA_?$ and $\calG_?$, respectively,  restricted to the vocabulary of $M$.

\mypara{Single-Reader/Single Writer (SRSW)} The critical innovation in GLP is the \emph{single-reader/single-writer requirement}:
That any reader and any writer may occur at most once in any state of a computation.  It is realized by two complementary concepts:
\begin{enumerate}
    \item \emph{SRSW syntactic restriction on clauses}: In each clause each variable (reader or writer) occurs at most once
    \item \emph{SRSW invariant}: If a resolvent satisfies the SRSW requirement, then applying to it a goal/clause reduction with a clause that satisfies the SRSW syntactic restriction produces  a resolvent that also satisfies the SRSW requirement.
\end{enumerate}
This SRSW syntactic restriction excludes programs like the equality definition $X=X$ which has two occurrences of the writer $X$. At the same time it
eliminates the need for distributed atomic unification~\cite{kleinman1990distributed}—replacing it with efficient point-to-point communication of a single assignment from the single occurrence of a writer to the single occurrence of its paired reader.

\subsection{GLP Operational semantics}


\begin{definition}[Writer and Reader Substitution, Reader Counterpart, Suspension Set, Writer MGU]\label{definition:glp-unification}

A substitution $\sigma$ is a \temph{writer substitution} if  $\sigma$: 
\begin{enumerate}
    \item only binds writers: $V_\sigma \subset V$
    \item does not bind writers to writers: if $X\ne X\sigma$ then $X\sigma\notin V$
    \item does not form cycles through readers:  $X?$ does not occur in $X\sigma$ for any $X \in V_\sigma$
\end{enumerate}
A substitution $\sigma$ is a \temph{reader substitution} if $V_\sigma \subset V?$.
If $\sigma$ is a writer substitution then its \temph{reader counterpart} is the reader substitution  $\sigma?$  defined by $X?\sigma? = X\sigma$ for every $X\in V_\sigma$.
%
The \temph{suspension set} of a (regular) substitution $\sigma$ is $W_\sigma:= \{X?\in V? : X?\sigma \notin \calV\}$.

The \temph{writer unification} of two terms:
\begin{enumerate}
    \item \temph{succeeds with $\sigma$} if they have a writer mgu $\sigma$.
    \item else \temph{suspends on $W_\sigma$} if they have a (regular) mgu $\sigma$
    \item else \temph{fails}
\end{enumerate}
\end{definition}
\begin{remark}
If a writer mgu exists it is unique, rather than unique up to renaming,  since it does not include writer-to-writer bindings.
If writer-to-writer bindings were allowed then, by the single-writer restriction, the binding would leave their two paired readers \emph{abandoned}, namely without a writer that can provide them with a value.   
The occurs check condition for the reader counterpart ensures that no writer is bound to a term containing its paired reader, preventing the formation of circular terms, as proven in Proposition~\ref{proposition:acyclicity}.

  %The empty/identity substitution is both a writer and a reader substitution, and is the only one such.
\end{remark}


Renaming  (Definition~\ref{definition:renaming}) is extended to respect variable pairing:
\begin{definition}[GLP Renaming]\label{definition:glp-renaming}
 Two GLP terms $T, T'$ have a variable in common if for some writer $X$, either $X$ or $X?$ occur in $T$ and either $X$ or $X?$ occur in $T'$. A \temph{GLP renaming} is a renaming substitution $\sigma: \mathcal{V} \mapsto \mathcal{V}$ such that for each $X\in V$: $X\sigma \in V$ and $X?\sigma = (X\sigma)?$.
\end{definition}



\begin{definition}[GLP Goal/Clause Reduction]\label{definition:glp-goal-clause-reduction}
 Given GLP goal $A$ and clause $C$,  with $H \verb|:-| B$ being the result of renaming $C$ apart from $A$,
 the \temph{GLP reduction} of $A$ with $C$ \temph{succeeds with result} $(B,\sigma)$ if $A$ and $H$ have writer mgu $\sigma$; \temph{suspends} if $A$ has a reader-instance $A'$ for which the GLP reduction of $A'$ with $C$ succeeds; else \temph{fails}.
\end{definition}

The GLP transition system extends Definition~\ref{definition:lp-ts}:
\begin{definition}[GLP Transition System]\label{definition:glp-ts}
Given a GLP program $M$, an \temph{asynchronous resolvent} over $M$ is a pair $(G,\sigma)$ where $G\in \calG_?(M)$ and $\sigma$ is a reader substitution. 
%
A transition system $GLP = (\calC,c0,\calT)$ is a \temph{GLP transition system} over $M$ and initial goal $G_0 \in \mathcal{G}_?(M)$ satisfying SRSW if:
\begin{enumerate}
    \item $\calC$ is the set of all asynchronous resolvents over $M$
    \item $c0= (G_0,\emptyset)$
    \item $\calT$ is the set of all transitions $(G,\sigma)\rightarrow (G',\sigma')$ satisfying:
    \begin{enumerate}
        \item \textbf{Reduce:} there exists an atom $A \in G$ such that $C \in M$ is the first clause for which the GLP reduction of $A$ with $C$ succeeds with result $(B,\hat\sigma)$, and $G' = (G \setminus \{A\} \cup B)\hat\sigma$ and $\sigma' = \sigma \circ \hat\sigma?$
        \item \textbf{Communicate:} $\hat\sigma = \{X?:=T\} \in \sigma$, $G'= G\hat\sigma$, and $\sigma' = \sigma \setminus \hat\sigma$
\end{enumerate}
\end{enumerate}
\end{definition}
The monotonicity of GLP goal/clause reduction (Proposition~\ref{proposition:glp-monotonicity}) allows a simple \emph{GLP fairness requirement}: A goal that can be reduced is eventually reduced.


\subsection{GLP Safety}

Here prove that, like LP, GLP computations are deductions, but, unlike LP, a goal that can be reduced in a configuration can still be reduced in any subsequent configuration of the computation.

\mypara{GLP computations are deductions}  First we show that the extensions of GLP over LP do not take it outside of the logic programming realm.

\begin{definition}[Pure Logic Variant]\label{definition:pure-logic}
Given a GLP term or goal $T$, the \temph{pure logic variant} $L(T)$ of $T$ is defined by replacing every reader $X?$ in $T$ with its paired writer $X$. Given a GLP computation  $r$, its pure logic variant $L(r)$ is the result of replacing every configuration $(G,\sigma)$ in $r$ by $L(G)$,  removing stutter transition (every configuration identical to their predecessor), and labelling the remaining transitions by the mgu of their respective reduction.
\end{definition}

\begin{restatable}[GLP Computations are Deductions]{proposition}{GLPComputationsareDeductions}\label{theorem:glp-computation-deduction}
For any finite GLP run $r$, let $L(r) = G0\xrightarrow{\sigma_1}G_1\xrightarrow{\sigma_2}\ldots G_n$, with $\sigma = \sigma_1\cdot \ldots \cdot \sigma_n$, then  $(G_$ :- $G_n)\sigma$ is a logical consequence of $L(M)$.
\end{restatable}


We establish essential safety properties for GLP that distinguish it from standard LP. The key innovation is monotonicity—once a goal becomes reducible in GLP, it remains reducible, unlike LP where variable instantiation can cause unification to fail.

\mypara{SRSW}
\begin{restatable}[SRSW Invariant]{proposition}{SRSWInvariant}\label{proposition:srsw-preservation}
If in a $GLP$ run the initial goal $G_0$ satisfies the SRSW requirement, then every goal in the run satisfies the SRSW requirement.
\end{restatable}



\mypara{Acyclicity}
The occurs check in readers prevents the formation of circular terms.

\begin{restatable}[Acyclicity]{proposition}{Acyclicity}\label{proposition:acyclicity}
If in a $GLP$ run the initial goal $G_0$ contains no circular terms, then no goal in the run contains a circular term.
\end{restatable}

\mypara{Monotonicity}
Unlike LP where variable instantiation can cause a previously reducible goal to fail, GLP exhibits monotonicity. In a run, if a goal $A$ can be reduced at some point, it remains reducible at all future points in that run, where 
``future" implies that readers in $A$  (and only readers) have been further instantiated by other goal reductions.


\begin{restatable}[Reader-Instance]{lemma}{ReaderOnlyInstantiation}\label{lemma:reader-only}
In any $GLP$ run $G_0 \rightarrow G_1 \rightarrow \cdots$, if $G_i \rightarrow G_{i+1}$ via reduction with substitution $\sigma?$, then for any atom $A \in G_{i+1}$ that also appeared in $G_i$, we have $A = A'\tau$ where $A' \in G_i$ and $\tau$ instantiates only readers.
\end{restatable}


\begin{restatable}[Monotonicity]{proposition}{Monotonicity}\label{proposition:glp-monotonicity}
In any $GLP$ run $G_0 \rightarrow G_1 \rightarrow \cdots$, if atom $A \in G_i$ can reduce with clause $C$, then for any $j > i$, either $A$ has been reduced by step $j$, or there exists $A' \in G_j$ where $A' = A\tau$ for some reader substitution $\tau$, and $A'$ can reduce with $C$.
\end{restatable}

\section{Programming Examples}\label{section:programming-examples}

We present basic GLP programming techniques as well as utilities employed by subsequent examples.

\subsection{Guards and System Predicates}

Guards and system predicates extend GLP programs with access to the GLP runtime state, operating system and hardware capabilities.

\mypara{Guard predicates}
Guards provide read-only access to the runtime state of GLP computation. A guard appears after the clause head, separated by \verb=|=, and must be satisfied for the clause to be selected. The following guards are fundamental for concurrent GLP programming:

\begin{itemize}
\item \verb|ground(X)| succeeds if \verb|X| contains no variables. With this guard, the clause body may contain multiple occurrences of \verb|X?| without violating the single-writer requirement, enabling safe replication of ground terms to multiple concurrent consumers.
\item \verb|known(X)| succeeds if \verb|X| is not a variable, though it may not be ground.
\item \verb|writer(X)| and \verb|reader(X)| succeed if  \verb|X| is an uninstantiated writer or reader respectively.  Note that \verb|reader(X)| is non-monotonic.
\item \verb|otherwise| succeeds if all previous clauses for this procedure failed.
\item \verb|X=Y| succeed if $X$ and $Y$ are identical
\item \verb|X=\=Y| succeeds if the unification of $X$ and $Y$ fails. 
\end{itemize}

\mypara{Defined guard predicates}
To support abstract data types and cleaner code organization, GLP provides for user-defined guards, defined unit clauses \verb|p(T1,...,Tn)|.  The call \verb|p(S1,...,Sn)| in the guard is folded to the equalities \verb|T1=S1,...,Tn=Sn| for each unit goal. This mechanism is demonstrated in the channel abstractions below.

\mypara{System predicates}
System predicates execute atomically with goal/clause reduction and provide access to underlying runtime services:
\begin{itemize}
\item \verb|evaluate(Expr?,Result)| evaluates ground arithmetic expressions.
\item \verb|current_time(T)| provides system timestamps for temporal coordination.
\item \verb|variable_name(X,Name)| returns a unique identifier for variable \verb|X| and its pair.
\end{itemize}


\subsection{Basic Concurrent Communication}

The simplest Glp communication is where one process writes a value that another reads. Streams extend this to continuous communication between concurrent processes:

\Program{Concurrent Indefinite Producer-Consumer}\label{program:producer-consumer}
\begin{verbatim}
producer([N?|Xs?],N) :- N1 := N? + 1, producer(Xs,N1?).
consumer([X|Xs],Sum) :- Sum1 := Sum? + X?, consumer(Xs?,Sum1?).
\end{verbatim}
When executed with goal \verb|producer(Stream,0), consumer(Stream?,0)|, the producer continuously extends the stream while the consumer concurrently processes each element. The synchronization through reader/writer pairs ensures the consumer blocks when no data is available and resumes when the producer provides new values.  Fairness in infinite runs of this nonterminating GLP program ensures that each element produced will eventually be consumed.

\subsection{Stream Processing and Merging}

Concurrent systems often require combining inputs from multiple sources. The fair stream merger interleaves elements from two concurrent producers, as shown in Program~\ref{program:merge}.
It uses GLP's deterministic clause selection to ensures fairness. This method can be extended to dynamic scenarios where producers join at runtime:

\Program{Dynamic Stream Merger}\label{program:dynamic-merge}
\begin{verbatim}
merger(Ws,Xs,Out?) :- merge(Ws?,Xs?,Out).

merge([merge(Ws)|Xs],Ys,Zs?) :- 
   merger(Ws?,Xs?,Xs1), merge(Xs1?,Ys?,Zs).
merge(Xs,[merge(Ws)|Ys],Zs?) :- 
   merger(Ws?,Ys?,Ys1), merge(Xs?,Ys1?,Zs).
merge([X|Xs],Ys,[X?|Zs?]) :- 
    X =\= merge(_) | merge(Ys?,Xs?,Zs).
merge(Xs,[Y|Ys],[Y?|Zs?]) :- 
    Y =\= merge(_) | merge(Xs?,Ys?,Zs).
merge([],[],[]).
\end{verbatim}

Any producer can send \verb|merge(NewStream)| to dynamically add another stream to the merge network, creating a self-organizing merge tree.


\subsection{Concurrent State Management}

Stateful services in concurrent systems must handle requests from multiple clients while maintaining consistent state. The monitor demonstrates this through a counter service that threads state through tail-recursive calls:

\Program{Concurrent Monitor}\label{program:monitor}
\begin{verbatim}
monitor(Ops) :- monitor(Ops?,0).

monitor([add(N)|Ops],Sum) :- Sum1 := Sum? + N?, monitor(Ops?,Sum1?).
monitor([subtract(N)|Ops],Sum) :- Sum1 := Sum? - N?, monitor(Ops?,Sum1?).
monitor([value(V)|Ops],Sum) :- ground(Sum?) | V = Sum?, monitor(Ops?,Sum?).
monitor([],_).
\end{verbatim}

The monitor maintains its state through the \verb|Sum| parameter, threading the current value through recursive calls. Each recursive invocation receives the updated state from its predecessor - \verb|add| and \verb|subtract| operations compute the new state and pass it to the next call through \verb|Sum1?|, while \verb|value| operations read the current state without modification. This tail-recursion technique, standard in logic programming implementations, enables efficient iteration with updated state rather than stack-consuming recursion.

Multiple concurrent clients share this monitor by merging their operation streams. Each client sends operations and receives responses through the \verb|V?| variables in \verb|value(V)| requests. The monitor serializes concurrent requests through the merged stream while maintaining state consistency through the threaded state parameter.

\subsection{Stream Distribution}

Broadcasting data to multiple concurrent consumers requires careful handling of the single-writer constraint. For ground terms, distribution is straightforward:

\Program{Concurrent Stream Distribution}\label{program:distribute}
\begin{verbatim}
distribute([X|Xs],[X|Ys1],...,[X|Ysn]) :- 
    ground(X) | distribute(Xs?,Ys1?,...,Ysn?).
distribute([],[],...,[]).
\end{verbatim}



\subsection{Channel Abstractions}

Bidirectional channels are fundamental to concurrent communication in GLP. We represent a channel as the term \verb|ch(In?,Out)| where \verb|In?| is the input stream reader and \verb|Out| is the output stream writer. The following predicates encapsulate channel operations and are defined as guard predicates through unit clauses:

\Program{Channel Operations}\label{program:channel-operations}
\begin{verbatim}
send(X,ch(In,[X?|Out?]),ch(In?,Out)).
receive(X?,ch([X|In],Out?),ch(In?,Out)).
new_channel(ch(Xs?,Ys),ch(Ys?,Xs)).
\end{verbatim}

The \verb|send| predicate adds a message to the output stream, \verb|receive| removes a message from the input stream, and \verb|new_channel| creates a pair of channels where each channel's input is paired with the other's output. When used as guards in clause heads, these predicates enable readable code that abstracts the underlying stream mechanics:

\Program{Stream-Channel Relay}\label{program:relay}
\begin{verbatim}
relay(In,Out?,Ch) :- 
    In?=[X|In1], send(X?,Ch?,Ch1) | relay(In1?,Out,Ch1?).
relay(In,Out?,Ch) :- 
    receive(X,Ch?,Ch1), Out=[X?|Out1?] | relay(In?,Out1,Ch1?).
\end{verbatim}

The relay reads from its input stream and sends to the channel in the first clause, while the second clause receives from the channel and writes to the output stream. The channel state threads through the recursive calls, maintaining the bidirectional communication link.


\section{Multiagent Grassroots Logic Programs}\label{section:maGLP}

We first extend the notion of transition systems to multiagent transition systems,  then use them to extend GLP to multiagent GLP, and finally prove that multiagent GLP is grassroots.

\subsection{Multiagent transition systems and atomic transactions} 

We assume a potentially infinite set of \emph{agents} $\Pi$ (think of all the agents that are yet to be born), but consider only finite subsets of it,  so when we refer to a particular set of agents $P \subset \Pi$ we assume $P$ to be nonempty and finite.
We extend the notion of transition systems (Definition~\ref{definition:ts}) to be multiagent~\cite{shapiro2023grassrootsBA,shapiro2025atomic}:
\begin{definition}[Multiagent Transition System]\label{definition:dts-cd}
Given agents $P \subset \Pi$ and an arbitrary set $S$ of \temph{local states} with a designated \temph{initial local state} $s0\in S$, 
a \temph{multiagent transition system} over $P$ and $S$ is a transition system $TS= (C,c0,T)$ with $C:= S^P$,  $c0:= \{s0\}^P$, and $T\subseteq C^2$ being a set of \temph{multiagent transitions} over $P$ and $S$. For $c\in C$ and $p\in P$, let $c_p$ denote the $p$-indexed element of $c$, define $TS$ to be of \temph{degree} $k$  (unary, binary, $k$-ary) if $k$ is the minimal number such that for every transition $c \rightarrow c' \in T$, at most $k$ agents $p\in P$ change their local state, $c_p \neq c'_p$.
\end{definition}
%
Informally, a multiagent configuration $c$ over $P$ can be thought of as an array indexed by agents in $P$, with $c_p$, the local state of $p$ in $c$, being the array element indexed by $p$.


\begin{definition}[Transaction, Closure]\label{definition:closure}
Let $P\subset \Pi$, $S$ a set of local states, and $C:=S^P$.
A \temph{transaction} $t=(c\rightarrow c')$ over local states $S$ with \temph{participants} $Q \subset \Pi$ is but a multiagent transition over $S$ and $Q$.
For every $P\subset \Pi$ s.t.  $Q\subseteq P$, the \temph{$P$-closure of $t$}, $t{\uparrow}P$,  is the set of transitions over $P$ and $S$ defined by:
$$
t{\uparrow}P := \{ t' \in C^2  :
\forall p\in Q.(t_p = t'_p) \wedge \forall p\in P\setminus Q.(p\text{ is stationary in }t')\}
$$
If $R$ is a set of transactions, each $t\in R$ over some $Q\subseteq P$ and $S$, then the 
\temph{$P$-closure of $R$}, $R{\uparrow}P$, is the set of $P$-transitions 
$ R{\uparrow}P := \bigcup_{t\in R} t{\uparrow}P$.
\end{definition}
Namely, the closure over $P\supseteq Q$ of a transaction $t$ over $Q$ includes all transitions $t'$ over $P$ in which members of $Q$ do the same in $t$ and in $t'$, and the rest remain in their current (arbitrary) state.  A set of transactions $R$ over $S$, each with participants $Q\subseteq P$, defines a multiagent transition system as follows:

\begin{definition}[Transactions-Based Multiagent Transition System]\label{definition:tbdts}
Given agents $P \subset \Pi$, local states $S$ with initial local state $s0\in S$, 
and a set of transactions $R$, each $t\in R$ over some $Q\subseteq P$ and  $S$, a \temph{transactions-based multiagent transition system} over $P$, $S$, and $R$ is the multiagent transition system $TS= (S^P,\{s0\}^P,R{\uparrow}P)$ .
\end{definition}

In other words, one can fully specify a multiagent transition system over $S$ and $P$ simply by providing a set of atomic transactions over $S$, each with participants $Q\subseteq P$.  Reference~\cite{shapiro2025atomic} provided transactions-based specification for social networks, grassroots cryptocurrencies, and grassroots federations.  Here we do that for multiagent GLP.



\subsection{Multiagent GLP} 

We extend GLP to be multiagent by letting agents' local states to be asynchronous resolvents, have unary Reduce transitions in which agents reduce a local goal and add reader assignments to it pending assignments, and binary Communicate transitions between agents $p$ and $q$ in case $p$ has suspended $X?:=T$ and $X?$ occurs in the resolvent of $q$.

The key difference between GLP and multiagent GLP is in the initial state. In a multiagent transition systems all agents must have the same initial state $s0$.  This precludes setting up an initial configuration in which agents share logic variables, as this would imply different initial states for different agents, which need to be coordinated a priori.  Our solution is congruent with reality: Recall that GLP agents are envisioned as apps running on networked smartphones owned and operated by people. Thus, each agent is initialized with two channels, one for communicating with its `user', namely the person operating the smartphone, the other for communicating with the network.  Furthermore, we assume that agents can use the network to establish initial shared logic variables, via which subsequent logic variable-based communication can proceed.

Thus, the initial state of each agent is the atomic goal\linebreak \verb|agent(ch(UIn?,UOut),ch(NIn?,NOut))|, with the variables unique to each agent, so formally written as \verb|agent(ch(_?,_),ch(_?,_))|.  Furthermore, we assume that in a multiagent GLP transition over agents $P\subset\Pi$, the network connecting them can transfer messages from the network output stream one agent to the network input stream of another, as specified by the following GLP program template, assuming the network process holds in position $p$ the paired channel of the network channel of $p$, for every $p\in P$.

% For insertion in Section 5.2, after the paragraph discussing initial states 
% and before "The network behaviour specified below..."

Note that the initial state \verb|agent(ch(_?,_),ch(_?,_))| employs anonymous variables and is thus identical across all agents.  Upon initialization, each agent creates them as fresh, unique variables. 

The Network transaction defined below causes the multiagent GLP system to behave as if agents' network channels were paired to a \verb|network| GLP process that routes messages between them: Messages sent to agent $q$ via agent $p$'s network output stream appear on agent $q$'s network input stream, realizing communication as specified by the following GLP program.  However, the network is not another GLP agent; the purpose of the \verb|network| program is solely to provide  behavioural specification of how the network should behave. 


Thus, the following GLP program template specifies the required network behaviour rather than mandating a particular implementation:

\Program{Network switch, representative clause}~\label{program:switch}
\begin{small}
\begin{verbatim}
% clause for forwarding a message from p to q:
network(...,(p,Chp),...,(q,Chq),.... :-
    receive(Chp?,msg(q,X),Chp1),
    send(Chq?,X?,Chjq1) |
    network(...,(p,Chp1?),...,(q,Chq1?),....)
\end{verbatim}
\end{small}
To avoid notational clutter, the Network binary transition below refers to the operation of \verb|network| verbally. It is activated when agent $p$ binds its network output stream tail to a list cell with head \verb|msg|$(q,X)$, as specified by the \verb|network|.
A concrete 3-way switch is shown as Program~\ref{program:3-way-network-switch}.

We leave the specification of `user' open; assuming people have free will, their behaviour cannot be specified in GLP:)  However,  programs for testing a multiagent GLP program or for simulating specific social behaviours can of course be added.


\begin{definition}[Multiagent GLP]
The \temph{maGLP transition system} over agents $P\subset \Pi$ and GLP module $M$ is the multiagent transition system $maGLP$ over multiagent asynchronous resolvents over $M$ and the following transactions $c\rightarrow c'$:
\begin{enumerate}
    \item \textbf{Reduce $p$:} $c_p\rightarrow c'_p$ is a GLP Reduce transition, $\forall p\in P$
    \item \textbf{Communicate $p$ to $q$:}  $c_p=(G_p,\sigma_p)$, $c_q=(G_q,\sigma_q)$, $\{X?:=T\} \in \sigma_p$, $X?$ occurs in $G_q$, $c'_p=(G_p,\sigma_p \setminus \{X?:=T\})$, and $c'_q=(G_q\{X?:=T\},\sigma_q)$, $\forall p,q \in P$  (including $p=q$)
    \item \textbf{Network $p$ to $q$:} The network output stream in $c_p$ has a new message \verb|msg|$(q,X)$ and $c'_q$ is the result of adding $X?$ to the network input stream in $c_q$
\end{enumerate}
\end{definition}
Note that Reduce is unary while Communicate and Network are binary. Both transfer assignments from writers to readers: Communicate operates between agents sharing logic variables, while Network operates through the network input/output streams established in each agent's initial configuration.

Note that Reduce is unary and Communicate and Network are binary, and that Network and Communicate are essentially identical:  In both cases an assignment to a writer in $p$ results in its application to a reader in $q$.

To show that maGLP computations are deductions, $L$ is augmented so the resolvent is the union of all local resolvents, the initial goal includes also a \verb|network| goal with  $|P|$ channels paired correctly to each agent's initial network channels, and the module $M$ is augmented with the GLP definition of  \verb|network|.   Other than that, safety properties for GLP and maGLP are essentially identical. Proofs carry over directly referring to multiagent asynchronous resolvents instead of asynchronous resolvents.


\subsection{Multiagent Grassroots Logic Programs are  Grassroots}


\mypara{Overview}
Here we prove that multiagent Grassroots Logic Programs are indeed \emph{grassroots}~\cite{shapiro2023grassrootsBA}. To do so, we recall necessary mathematical foundations:
\begin{enumerate}
    \item \textbf{Protocols:} The notion of grassroots applies to protocols: A \emph{protocol} $\calF$ is an infinite family of multiagent transition systems, one $\calF(P)$  for each set of agents $P\subset\Pi$.
    \item \textbf{Grassroots:} Informally, proving that a protocol $\calF$ is grassroots requires proving for that for any two sets of agents $P\subset P'$:
        \begin{enumerate}
            \item \textbf{Oblivious:}  Any behaviours available to agents $P$ according to $\calF(P)$ are also available to them  when they operate within $P'$, namely in $\calF(P')$ 
            \item \textbf{Interactive:}  There are behaviours available to agents $P$ operating within  $P'\supset P$ not available when they operate on their own in $\calF(P)$
        \end{enumerate}
\end{enumerate}
We proceed with the definitions.

\begin{definition}[Local-states function]\label{definition:local-states}
A \temph{local-states function} $S: 2^\Pi \mapsto 2^\mathcal{S}$ maps every set of agents $P \subset \Pi$ to a set of local states $S(P) \subset \mathcal{S}$ that includes a designated initial state $s0 \in \mathcal{S}$ and satisfies $P \subset P' \subset \Pi \implies S(P) \subset S(P')$.
\end{definition}

\begin{definition}[Protocol]\label{definition:protocol}
A \temph{protocol} $\mathcal{F}$ over a local-states function $S$ is a family of multiagent transition systems that has exactly one mts $\mathcal{F}(P) = (C(P), c_0(P), T(P))$ for every $P \subset \Pi$, where $c_p \in S(P)$ and  $c0(P)_p = s0$ for every $c\in C(P)$ and $p\in P$.
\end{definition}
%
Note that maGLP over $M$ and $P$ is a protocol, parameterized by $P$. Next we recall the notion of a grassroots protocol.

\begin{definition}[Projection]\label{definition:projection}
Let $\emptyset \subset P \subset P' \subset \Pi$. If $c'$ is a configuration over $P'$ then $c'/P$, the \temph{projection of $c'$ over $P$}, is the configuration $c$ over $P$ defined by $c_p := c'_p$ for every $p \in P$.
\end{definition}
Note that in the definition above, $c_p$, the state of $p$ in $c$, is in $S(P')$, not in $S(P)$, and hence may include elements ``alien'' to $P$, e.g., logic variables shared with $q \in P' \setminus P$.
%
We use the notions of projection and closure (Definition \ref{definition:closure}) to define when a protocol is grassroots:

\begin{definition}[Oblivious, Interactive, Grassroots]\label{definition:grassroots}
A protocol $\mathcal{F}$ is:
\begin{enumerate}
    \item \temph{oblivious} if for every $\emptyset \subset P \subset P' \subseteq \Pi$, 
    $T(P){\uparrow}P'\subseteq T(P')$
    \item \temph{interactive} if for every $\emptyset \subset P \subset P' \subseteq \Pi$ and every configuration $c\in C(P')$ such that $c/P\in C(P)$, there is a computation $c\xrightarrow{*} c'$ of $\mathcal{F}(P')$ for which $c'/P\notin C(P)$.
    \item \temph{grassroots} if it is oblivious and interactive.
\end{enumerate}
\end{definition}
For protocols defined via atomic transactions, such as maGLP, we get the oblivious property ``for free'':
\begin{proposition}[\cite{shapiro2025atomic}]\label{proposition:oblivious}
A transactions-based protocol is oblivious. 
\end{proposition}

The interactive property requires that agents in $P$ can always potentially interact with agents in $P' \setminus P$, leaving "alien traces" in their local states that could not have been produced by $P$ operating alone.  In maGLP this is achieved by the Network transition, in which agent $q\in P'\setminus P$ sends a message with a logic variable to agent $p\in P$.

\begin{restatable}{theorem}{maGLPisgrassroots}\label{theorem:maglp-grassroots}
maGLP is grassroots.    
\end{restatable}


\section{The Grassroots Social Graph}\label{section:social-graph}

The grassroots social graph emerges through a protocol that enables agents to establish authenticated bidirectional communication channels. Each agent begins with an empty friends list and builds their local neighbourhood in the social graph through two mechanisms: Using the network for cold calls for initial connections between previously unconnected agents, and friend-mediated introductions for expanding the network through existing trust relationships. This section presents the complete protocol, demonstrating how the concurrent programming techniques and multiagent framework combine to realize a decentralized social network where nodes represent people, edges represent authenticated friendships, and connected components arise spontaneously through peer-to-peer interactions.

\subsection{Protocol Architecture}

Each agent maintains its social graph neighbourhood as a friends list containing named bidirectional channels to connected peers. The protocol processes three types of events: connection requests initiated by the agent's user, offers received from other agents through the network, and responses to the agent's own connection attempts. The architecture unifies all communication through a single merged input stream, with the friends list serving as both the social graph state and the routing table for outgoing messages.

The protocol achieves non-blocking asynchronous operation through careful use of GLP's synchronization mechanisms. When initiating connections, agents send offers containing unbound response variables and continue processing other messages while awaiting responses. Similarly, when receiving offers, agents query their users for approval without blocking the main protocol loop. This design enables agents to handle multiple concurrent connection attempts, process friend messages, and respond to user commands simultaneously without deadlock or starvation.

\subsection{Initialization and Message Routing}

Each agent begins with the goal \verb|agent(Id, ChUser, ChNet)| where \verb|Id| is the agent's unique identifier, \verb|ChUser| provides bidirectional communication with the user interface, and \verb|ChNet| connects to the network for initial message routing. The initialization phase establishes the unified message processing architecture:

\Program{Social Graph Initialization}\label{program:social-init}
\begin{verbatim}
agent(Id, ChUser, ChNet) :- 
    ChUser = ch(UserIn, UserOut), ChNet = ch(NetIn, NetOut) |
    merge(UserIn?, NetIn?, In),
    social_graph(Id?, In?, [(user, UserOut), (net, NetOut)]).
\end{verbatim}

The initialization extracts the input and output streams from the user and network channels, merges the input streams into a unified stream \verb|In|, and stores the output streams in the initial friends list with special identifiers "user" and "net". This design treats the user interface and network as special cases of friends, enabling uniform message sending through the \verb|lookup_send| procedure regardless of destination type.

\subsection{Cold Call Protocol}

The cold call mechanism enables agents to establish friendship without prior shared variables. When agent $p$ wishes to befriend agent $q$, the protocol proceeds through four phases: user $p$ initiation, $p$ to $q$ offer transmission, user $q$ consultation, and if the response is positive then $p-q$ channel establishment.

\Program{Social Graph Cold-Call Befriending Protocol}\label{program:social-graph}
\begin{verbatim}
% Process user request to connect (self-introduction)
social_graph(Id, [msg(user, Id, connect(Target))|In], Fs) :-
    ground(Id), ground(Target) |
    lookup_send(net, msg(Id, Target, intro(Id?, Id?, Resp)), Fs?, Fs1),
    inject(Resp?, msg(Target, Id, response(Resp)), In?, In1),
    social_graph(Id, In1?, Fs1?).

% Process received self-introduction
social_graph(Id, [msg(From, Id, intro(From, From, Resp))|In], Fs) :-
    ground(Id), attestation(intro(From, From, Resp), att(From, _)) |
    lookup_send(user, msg(agent, user, befriend(From?, Resp)), Fs?, Fs1),
    social_graph(Id, In?, Fs1?).

% Process user decision on received introduction
social_graph(Id, [msg(user, Id, decision(Dec, From, Resp?))|In], Fs) :-
    ground(Id) |
    bind_response(Dec?, From?, Resp, Fs?, Fs1, In?, In1),
    social_graph(Id, In1?, Fs1?).

% Process response to sent introduction
social_graph(Id, [msg(From, Id, response(Resp))|In], Fs) :-
    ground(Id) |
    handle_response(Resp?, From?, Fs?, Fs1, In?, In1),
    social_graph(Id, In1?, Fs1?).

% Application message handling
social_graph(Id, [msg(From, To, Content)|In], Fs) :-
    ground(Id), otherwise |
    % Forward to application layer
    social_graph(Id, In?, Fs?).

inject(X,Y,Ys,[Y?|Ys?]) :- known(X) | true.
inject(X,Y,[Y1|Ys],[Y1?|Ys1?]) :- unknown(X) | inject(X?,Y?,Ys?,Ys1).
\end{verbatim}

The first clause handles user-initiated connections by sending an offer containing an unbound response variable through the network. The \verb|inject| procedure defers insertion of the response message into the input stream until the response variable becomes bound, while allowing the stream to continue flowing. The second clause receives offers from other agents and forwards them to the user interface for approval, including the response variable that the user's decision will bind. The third clause processes user decisions, calling \verb|bind_response| to handle acceptance or rejection. The fourth clause handles responses to the agent's own offers.

When \verb|X| is known, \verb|inject| inserts the message at the output stream and terminates.  Until then, it passes input stream messages to its output. This ensures the protocol remains responsive while awaiting responses to its own connection attempts.

\subsection{Channel Establishment and Response Handling}

The protocol's response handling demonstrates sophisticated use of GLP's concurrent programming capabilities. When an offer is accepted, both agents must establish symmetric channel configurations and merge the new friend's input stream into their main processing loop:

\Program{Response Processing}\label{program:response-handling}
\begin{verbatim}
% Bind response based on user decision
bind_response(yes, From, accept(FCh), Fs, Fs1, In, In1) :-
    new_channel(ch(FIn, FOut), FCh),
    handle_response(accept(FCh?), From, Fs, Fs1, In, In1).
bind_response(no, _, no, Fs, Fs, In, In).

% Handle response (for both received and sent offers)
handle_response(accept(ch(FIn, FOut)), From, Fs, [(From, FOut)|Fs], In, In1) :-
    tag_stream(From?, FIn?, Tagged),
    merge(In?, Tagged?, In1).
handle_response(no, _, Fs, Fs, In, In).
\end{verbatim}

When accepting an offer, \verb|bind_response| creates a new channel pair using \verb|new_channel|, which produces two channels with crossed input/output streams. The acceptor retains one channel and sends the other through the response variable, ensuring both agents receive complementary channel endpoints. The \verb|handle_response| procedure, called for both accepted sent offers and accepted received offers, adds the friend's output stream to the friends list and merges the tagged input stream into the main message flow. The stream tagging preserves sender identity after merging, enabling the agent to determine message origin.




\subsection{Friend-Mediated Introductions}\label{subsection:friendly-introduction}

Beyond cold calls, the social graph protocol enables friend-mediated introductions, leveraging existing trust relationships to establish new connections. When agent $r$ is friends with both $p$ and $q$, it can introduce them to each other, creating a direct communication channel between them.

\Program{Friend-Mediated Introduction Protocol}\label{program:introduction}
\begin{verbatim}
% Friend introduces two others
social_graph(Id, [msg(user, Id, introduce(P, Q))|In], Fs) :-
    ground(Id), ground(P), ground(Q), 
    new_channel(ch(PQIn, PQOut), ch(QPIn, QPOut)) |
    lookup_send(P, msg(Id, P, intro(Q?, ch(QPIn?, PQOut?))), Fs?, Fs1),
    lookup_send(Q, msg(Id, Q, intro(P?, ch(PQIn?, QPOut?))), Fs1?, Fs2),
    social_graph(Id, In?, Fs2?).

% Process introduction - initiate attestation exchange
social_graph(Id, [msg(From, Id, intro(Other, ch(In, Out)))|In], Fs) :-
    ground(Id), attestation(intro(Other, ch(In, Out)), att(From, _)) |
    Out = [attest_req(Id?, AttResp)|Out1?],
    inject(AttResp?, msg(Other, Id, verified_intro(From?, Other?, ch(In?, Out1?))), 
           In?, In1),
    social_graph(Id, In1?, Fs?).

% Process attestation request and send verification
social_graph(Id, [msg(From, Id, attest_req(From, AttResp))|In], Fs) :-
    ground(Id), attestation(attest_req(From, AttResp), att(From, Module)) |
    AttResp = verified(Id?, Module?),
    social_graph(Id, In?, Fs?).

% Attestation verified - now ask user
social_graph(Id, [msg(Other, Id, verified_intro(Introducer, Other, Ch))|In], Fs) :-
    ground(Id), attestation(verified_intro(Introducer, Other, Ch), att(Other, Module)) |
    lookup_send(user, msg(agent, user, 
                befriend_verified(Introducer?, Other?, Module?, Ch?)), Fs?, Fs1),
    social_graph(Id, In?, Fs1?).

% User accepts verified introduction
social_graph(Id, [msg(user, Id, decision(yes, Other, ch(In, Out)))|In], Fs) :-
    ground(Id) |
    tag_stream(Other?, In?, Tagged),
    merge(In?, Tagged?, In1),
    social_graph(Id, In1?, [(Other?, Out?)|Fs?]).
\end{verbatim}

Friend-mediated introductions provide stronger trust assurance than cold calls through double verification. The introducer $r$ creates a fresh channel pair connecting $p$ and $q$, sending each party one of the paired channels, along with the identity of the other party. Recipients first verify through the signature and attestation that the introduction genuinely originates from their mutual friend $r$ running verified code. Before accepting the connection, the introduced parties $p$ and $q$ exchange signed and attested messages through the new channel, allowing each to verify the other's identity through signatures and code compatibility through attestations.

This double verification mechanism addresses two distinct security requirements. The introducer's signature and attestation prevent forgery—the signature proves the introduction came from $r$ while the attestation confirms it was produced by legitimate social graph code. The signatures and attestations exchanged between introduced parties ensure they are indeed who the introducer claims, with signatures providing cryptographic proof of identity and attestations ensuring code compatibility.

Unlike cold calls which require external identity verification, friend-mediated introductions provide both the introducer's social vouching and direct cryptographic verification from the introduced party through their signatures. The mutual friend serves as a trusted intermediary who facilitates the connection, while the exchange of signed and attested messages between parties ensures the connection's authenticity independent of the introducer's continued involvement.

\subsection{Protocol Properties}
The social graph protocol exhibits several essential properties for grassroots platforms. Non-blocking operation ensures that agents remain responsive during connection establishment, with no single operation capable of indefinitely blocking message processing. Symmetric channel establishment guarantees that successful connections result in bidirectional communication with identical capabilities for both parties. The unified message processing through stream merging provides fair handling of messages from all sources, preventing starvation of any input source.
The protocol's use of unbound variables for response coordination elegantly solves the distributed consensus problem for connection establishment. Both agents must explicitly agree to connect—the offerer by initiating and the receiver by accepting—with the shared response variable serving as the synchronization mechanism. This design ensures that connections only form through mutual consent while avoiding complex state machines or timeout mechanisms.
The friends list serves multiple roles simultaneously: it represents the agent's local view of the social graph, provides the routing table for message sending, and maintains the state needed for friend-mediated introductions. This unified structure simplifies reasoning about the protocol while enabling efficient implementation. The incremental construction of the social graph through individual connections allows multiple disconnected components to form independently and later merge through cross-component connections, embodying the grassroots principle of spontaneous emergence without central coordination.

This section presents the social graph protocol building on the established foundations while avoiding premature introduction of security features that belong in the secure GLP context. The protocol demonstrates how the concurrent programming techniques combine with the multiagent framework to realize a functioning distributed social network.


\section{Securing Multiagent Grassroots Logic Programs}

\subsection{Secure Multiagent GLP}\label{section:secturemaGLP}

Here we assume that each agent $p\in \Pi$ has a self-chosen keypair, unique whp, with a public key known to all other agents, and identify $p$ with its public key.
In addition to the standard cryptographic assumptions on the security of encryption and signatures, we assume that the underlying GLP execution mechanism can produce \emph{attestations}: A proof that a network message  $\verb|msg|(q,X)$ or a substitution message $\{X?:=T\}$  was produced by module $M$ as a result of a correct goal/clause reduction. For such a message $E$, we denote by $E_M$ the message together with its attestation, and by $E_{M,p}$ such an attestation further signed by agent $p$'s private key. Furthermore, we assume that when such a signed attestation is sent to agent $q$, it is encrypted with $q$'s public key, denoted $E_{M,p,q}$. In summary, each message  $\verb|msg|(q,X)$ or assignment to $X$ produced by agent $p$ using module $M$ is sent to the intended recipient $q$ or the holder $q$ of $X?$ attested by $M$, signed by $p$ and encrypted for $q$.\footnote{
On current smartphones, secure multiagent GLP is realized through Trusted Execution Environments (TEEs) with hardware providers (e.g., ARM TrustZone~\cite{alves2004trustzone}) as trust anchors, combined with OS-level attestation services (Google Play Integrity~\cite{google2023play}, Apple App Attest~\cite{apple2023attest}) with OS providers as trust anchors. This infrastructure authenticates and attests to the integrity of the sender and prevents tampering while ensuring confidentiality.}


Programs require the ability to inspect attestations on received messages and identify their own module for protocol decisions. GLP provides guard predicates for security operations:
\begin{itemize}
\item \verb|attestation(X, Info)| succeeds if \verb|X| carries an attestation, binding \verb|Info| to a term \verb|att(Agent, Module)| containing the attesting agent's public key and module identifier. For locally-produced terms, \verb|Agent| binds to \verb|self|. The guard fails for unauthenticated data and suspends if \verb|X| is not yet bound.
\item \verb|module(M)| binds \verb|M| to the identifier of the currently executing module. Agents use this guard to determine their own module identity when evaluating compatibility with other agents' attested modules. Future extensions will provide module metadata including version numbers and compatibility relationships.
\end{itemize}
These guards enable programs to make protocol decisions based on attestation properties and module compatibility without accessing the underlying cryptographic mechanisms directly. The social graph protocol uses these to verify cold call origins and enforce module compatibility, whilst social networking applications extract and preserve provenance chains when forwarding content.

While the formal specification requires attestation, signature and encryption for every message, a practical implementations should employ standard cryptographic optimizations~\cite{menezes1996handbook}: Attestation can be required only on initial contact and then verified intermittently rather than for every message, reducing computational overhead while maintaining security guarantees. Public keys exchanged during initial attestation can be used to establish secure agent-to-agent communication channels using ephemeral session keys through protocols such as Diffie-Hellman key exchange~\cite{diffie1976new} or ECDH~\cite{hankerson2004guide}, providing perfect forward secrecy while reducing the cost of encryption operations. These optimizations are transparent to the GLP program level, where the security properties continue to hold as specified.

\subsection{Program-Independent Security Properties}

The cryptographic mechanisms of secure maGLP guarantee three fundamental properties for all executions, regardless of the specific GLP program:

\begin{enumerate}
\item \textbf{Integrity:} Any entity $E_{M,p,q}$ transmitted from agent $p$ to agent $q$ either arrives unmodified or is rejected upon signature verification failure. Tampering with $E$ invalidates $p$'s signature, which cannot be forged without $p$'s private key.

\item \textbf{Confidentiality:} The content of $E_{M,p,q}$ remains inaccessible to all agents except $q$, as decryption requires $q$'s private key. Combined with the SRSW invariant ensuring exclusive reader/writer pairing, this prevents both direct cryptographic attacks and indirect access through shared variables.

\item \textbf{Non-repudiation:} Agent $p$ cannot deny sending any entity successfully verified as $E_{M,p,q}$, as the valid signature constitutes cryptographic proof of authorship that only $p$ could have created.
\end{enumerate}

These properties provide the cryptographic foundation for secure maGLP communication. Authentication and trust propagation properties depend on program-specific behaviour and are analysed for particular protocols such as the grassroots social graph.


\subsection{Security of the Social Graph Protocol}

Multiagent GLP assumes all participating agents execute correctly. However, secure multiagent GLP must handle Byzantine agents who may attempt to impersonate others, run malicious code, or violate protocols. While secure multiagent GLP automatically generates attestations for all inter-agent messages, programs must explicitly verify these attestations to make security decisions. The social graph protocol requires modification to leverage the attestation guard for Byzantine resistance.

\mypara{Attestation Verification in the Social Graph Protocol}
The key modification occurs when processing received messages. The original protocol (Program~\ref{program:social-graph}) trusts the sender field in messages. The secure version verifies attestations:

\begin{verbatim}
% Secure clause - verifies attestation
social_graph(Id, [msg(From, Id, offer(Resp))|In], Fs) :-
    ground(Id), attestation(offer(Resp), att(Sender, Module)) |
    verify_offer(Sender?, From?, Module?, Resp, Fs?, Fs1, In?, In1),
    social_graph(Id, In1?, Fs1?).
\end{verbatim}
The attestation guard extracts the actual sender's public key (\verb|Sender|) and module identifier from the cryptographic attestation. The protocol then calls \verb|verify_offer| (defined in Appendix~\ref{appendix:verify-offer}) to verify that \verb|Sender| matches the claimed \verb|From| field, preventing impersonation, and checks module compatibility before forwarding offers to users. Byzantine agents cannot forge attestations for other agents' keys or fake module identities due to cryptographic binding. Similar attestation checks apply to all protocol messages, ensuring decisions rely on cryptographically verified information rather than trust.

\mypara{Authenticated Connection Establishment}
Cold call offers carry attestation $(\verb|msg|(q,\verb|offer|(\verb|Resp|)))_{M,p,q}$ proving agent $p$ executes module $M$. Acceptance returns $(\verb|Resp:=accept(FCh)|)_{M,q,p}$, establishing mutual authentication. The signature mechanism proves control of private keys and attestation verifies code execution, but neither establishes real-world identity—this requires external verification through existing social channels.

\mypara{Authentication Exchange Protocol}
The authenticated connection establishment proceeds through a sequence of cryptographic operations ensuring mutual verification. When agent $p$ initiates a cold call to agent $q$, the offer message undergoes three layers of protection: attestation by module $M$, signature with $p$'s private key, and encryption with $q$'s public key, denoted $(msg(q,offer(Resp)))_{M,p,q}$.

Upon receipt, agent $q$ processes the message through the inverse sequence:
\begin{enumerate}
\item \textbf{Decryption:} Using $q$'s private key to access the message content
\item \textbf{Signature verification:} Using $p$'s public key to verify authenticity
\item \textbf{Attestation validation:} Confirming the message originated from module $M$
\end{enumerate}

If any verification step fails, the message is silently discarded. When all succeed, $q$ processes the offer as specified in the protocol. Upon acceptance, $q$ returns $(Resp:=accept(FCh))_{M,q,p}$ through the same cryptographic layers, enabling $p$ to perform reciprocal verification. This bidirectional attestation exchange establishes that both parties control their claimed private keys and execute verified code, forming the cryptographic foundation for all subsequent communication through the established channel.

The critical security property is that successful completion of this exchange proves to each party that their counterpart possesses the private key corresponding to their claimed public key and executes an attested instance of module $M$. Without both properties, the exchange cannot complete successfully.

\mypara{Authentication Exchange Protocol}
The authenticated connection establishment proceeds through a sequence of cryptographic operations ensuring mutual verification. When agent $p$ initiates a cold call to agent $q$, the offer message undergoes three layers of protection: attestation by module $M$, signature with $p$'s private key, and encryption with $q$'s public key, denoted $(msg(q,offer(Resp)))_{M,p,q}$.

Upon receipt, agent $q$ processes the message through the inverse sequence:
\begin{enumerate}
\item \textbf{Decryption:} Using $q$'s private key to access the message content
\item \textbf{Signature verification:} Using $p$'s public key to verify authenticity
\item \textbf{Attestation validation:} Confirming the message originated from module $M$
\end{enumerate}

If any verification step fails, the message is silently discarded. When all succeed, $q$ processes the offer as specified in the protocol. Upon acceptance, $q$ returns $(Resp:=accept(FCh))_{M,q,p}$ through the same cryptographic layers, enabling $p$ to perform reciprocal verification. This bidirectional attestation exchange establishes that both parties control their claimed private keys and execute verified code, forming the cryptographic foundation for all subsequent communication through the established channel.

The critical security property is that successful completion of this exchange proves to each party that their counterpart possesses the private key corresponding to their claimed public key and executes an attested instance of module $M$. Without both properties, the exchange cannot complete successfully.

\mypara{Trust Propagation}
Friend-mediated introductions strengthen identity assurance. When $p$ introduces friends $q$ and $r$, recipients verify the introduction originates from $p$ through attestation. The established channel provides ongoing mutual attestation. The introducer vouches for cryptographic-to-social identity mappings, combining cryptographic proof with social trust.

\mypara{Attack Prevention}
The protocol prevents three attack categories through integrated cryptographic and language-level mechanisms. Sybil attacks are mitigated through the requirement that agents know each other's public keys through external social verification before connecting - an adversary cannot create meaningful fake identities without corresponding social relationships. Man-in-the-middle attacks fail because messages are encrypted for specific recipients and the SRSW invariant ensures exclusive reader/writer channels that cannot be intercepted. Impersonation attempts are detected through signature verification on every message, with invalid signatures causing silent drops. These mechanisms combine to ensure that successful communication occurs only between authenticated parties running verified code.


\mypara{Code Compatibility}
Attestations include module identifiers, enabling agents to verify protocol compatibility and enforce specialized requirements cryptographically rather than through trust.

\subsection{Streams as Blockchains, Interlaced Streams as Blocklace}


\mypara{GLP Streams Enjoy Blockchain Security} 
Blockchains provide specific security properties: immutability, unforkability, non-repudiation, and acyclicity~\cite{nakamoto2008peer,garay2015bitcoin}. We prove that authenticated GLP streams achieve these properties through language-level guarantees.

A blockchain is a growing list of cryptographically linked blocks providing specific security properties~\cite{nakamoto2008peer}. GLP streams achieve equivalent properties through language mechanisms:

\begin{enumerate}
\item \textbf{Immutability:} Once a stream element \verb=[X|Xs]= is created with \verb=X= bound to value \verb=T=, the single-assignment semantics of logic variables prevents any subsequent binding of \verb=X=. This provides immutability without cryptographic hashing.

\item \textbf{Unforkability:} The SRSW invariant ensures each writer \verb~Xs~ has exactly one occurrence. Attempting to create two continuations \verb~Xs=[Y|Ys]~ and \verb~Xs=[Z|Zs]~ would require two occurrences of writer \verb~Xs~, violating SRSW. This prevents forks at the language level.

\item \textbf{Non-repudiation:} Stream extensions communicated between agents carry attestations $(\verb=Xs:=[Y|Ys]=)_{M,p,q}$. The signature by agent $p$ provides cryptographic proof of authorship that $p$ cannot deny.

\item \textbf{Acyclicity:} Proposition~\ref{proposition:acyclicity} guarantees no circular terms. The occurs check prevents any writer from being bound to a term containing its paired reader, ensuring strict temporal ordering of stream elements.
\end{enumerate}

These properties establish that authenticated GLP streams provide blockchain security guarantees through logical foundations rather than proof-of-work or proof-of-stake mechanisms.

\mypara{Cooperative Extension}
Traditional blockchains employ competitive consensus where multiple parties race to extend the chain~\cite{garay2015bitcoin}. GLP's single-writer constraint makes competitive extension impossible—only the agent holding the tail writer can extend a stream. However, this enables elegant cooperative protocols through explicit handover, as demonstrated in Program~\ref{program:cooperative}. The writer capability transfers exclusively between agents, enabling round-robin production, priority-based scheduling, or dynamic producer pools without consensus overhead.

\mypara{Interlaced Streams are a Blocklace}
Program~\ref{program:interlaced-streams} demonstrates how multiple agents maintaining streams that reference each other naturally form a blocklace~\cite{almeida2024blocklace}—a DAG where each block references multiple predecessors. Modern consensus protocols increasingly adopt DAG structures for improved throughput and responsiveness, including Hashgraph~\cite{baird2016swirlds}, DAG-KNIGHT~\cite{sompolinsky2022dag}, Avalanche~\cite{rocket2018snowflake}, Cordial Miners~\cite{keidar2023cordial}, Morpheus~\cite{lewis2025morpheus}, and Grassroots Consensus~\cite{keidar2025constitutional}.

The resulting structure provides eventual consistency equivalent to Byzantine fault-tolerant CRDTs~\cite{shapiro2011conflict} while maintaining blockchain integrity guarantees.

This technique gains additional power in secure multiagent GLP. Mutual attestations ensure all participating agents are authenticated and running verified code. Consequently, consensus protocols in GLP need only handle network and fail-stop failures, not Byzantine behaviour. This simplified threat model allows DAG-based consensus protocols~\cite{keidar2023cordial,lewis2025morpheus,ls2025cgc} to eliminate Byzantine fault tolerance mechanisms when implemented using interlaced streams, significantly reducing complexity while maintaining safety guarantees.


The resulting structure provides eventual consistency equivalent to Byzantine fault-tolerant CRDTs~\cite{shapiro2011conflict} while maintaining blockchain integrity guarantees.

This technique gains additional power in secure multiagent GLP. Mutual attestations ensure all participating agents are authenticated and running verified code. Consequently, consensus protocols in GLP need only handle network and fail-stop failures, not Byzantine behaviour. This simplified threat model allows DAG-based consensus protocols~\cite{keidar2023cordial,lewis2025morpheus,ls2025cgc} to eliminate Byzantine fault tolerance mechanisms when implemented using interlaced streams, significantly reducing complexity while maintaining safety guarantees.

These properties demonstrate that GLP's reader/writer synchronization naturally realizes advanced distributed data structures, providing blockchain security through logical foundations rather than computational puzzles.

\section{Social Networking Applications}\label{section:social-networking}

Building upon the authenticated social graph, this section demonstrates how GLP enables secure social networking applications. The established friend channels and attestation mechanisms provide verifiable content authorship and provenance guarantees impossible in centralised platforms.

\subsection{Direct Messaging}

Direct messaging establishes dedicated conversation channels between friends, separate from the protocol control channels. When accepting friendship, the acceptor creates a messaging channel and includes it in the acceptance response:

\Program{Direct Messaging Channel Establishment}\label{program:direct-messaging}
\begin{verbatim}
% Modified establishment for direct messaging
% Secure version - verifies DM channel attestation
establish(yes, From, Resp, Fs, Fs1, In, In1) :-
    new_channel(ch(FIn, FOut), FCh),
    new_channel(ch(DMIn, DMOut), DMCh),
    Resp = accept(FCh, DMCh),
    attestation(DMCh, att(From, _)) |  % Verify DM channel from authenticated friend
    handle_friend(From?, FIn?, FOut?, DMIn?, DMOut?, Fs?, Fs1, In?, In1).

handle_friend(From, FIn, FOut, DMIn, DMOut, Fs, 
             [(From, FOut), (dm(From), DMOut)|Fs], In, In1) :-
    tag_stream(From?, FIn?, Tagged),
    merge(In?, Tagged?, In1),
    forward_to_app(dm_channel(From?, DMIn?)).
\end{verbatim}

The protocol maintains separation between control and messaging channels. The friend channel handles protocol messages whilst the direct messaging channel carries conversation data. Each message through the DM channel carries attestation, ensuring non-repudiation and authenticity of the conversation history.

\subsection{Feed Distribution with Verified Authorship}

Content feeds leverage the \verb|ground| guard's relaxation of SRSW constraints to broadcast to multiple followers whilst maintaining cryptographic proof of authorship:

\Program{Authenticated Feed Distribution}\label{program:feed}
\begin{verbatim}
% Post distribution with attestation preservation
post(Content, Followers, Followers1) :-
    ground(Content), current_time(Time) |
    create_post(Content?, Time?, Post),
    broadcast(Post?, Followers?, Followers1).

broadcast(_, [], []).
broadcast(Post, [(Name,Out)|Fs], [(Name,[Post|Out1?])|Fs1]) :-
    broadcast(Post?, Fs?, Fs1).

% Defined guard for attestation preservation  
preserve_attestation(Post, Author, forward(Author?, Post)).

% Forward with attestation verification
forward(Post, Followers, Followers1) :-
    ground(Post), attestation(Post, att(Author, _)),
    preserve_attestation(Post?, Author?, Forward) |
    broadcast(Forward?, Followers?, Followers1).
\end{verbatim}

Each post carries the creator's attestation $(Post)_{M,p,q}$. When forwarding, the original attestation is preserved whilst adding the forwarder's attestation, creating a cryptographically verifiable provenance chain. Recipients can verify both the original author and the complete forwarding path, preventing misattribution and enabling accountability for content distribution.

\subsection{Group Communication}

Groups in GLP follow a founder-administered model where users create groups with selected friends. The founder invites authenticated friends who decide whether to join. Group messages use interlaced streams, creating natural causal ordering without consensus.

\mypara{Group Formation}
Users initiate groups with a name and friend list. The globally unique group identifier is (founder, name), preventing naming conflicts:

\Program{Group Formation Protocol}\label{program:group-formation}
\begin{verbatim}
% User creates group with friend list
social_graph(Id, [msg(user, Id, create_group(Name, Friends))|In], Fs) :-
    create_group_streams([Id|Friends]?, Streams),
    send_invitations(Friends?, Id?, Name?, Streams?, Fs?, Fs1),
    social_graph(Id, In?, [((Id,Name), group(admin, Streams?))|Fs1?]).

% Send invitations through friend channels
send_invitations([], _, _, _, Fs, Fs).
send_invitations([Friend|Friends], Founder, Name, Streams, Fs, Fs1) :-
    lookup(Friend, Fs?, Ch),
    Ch = [inv(Founder?, Name?, Streams?)|Ch1?],
    send_invitations(Friends?, Founder?, Name?, Streams?, [(Friend,Ch1?)|Fs2?], Fs1).

% Receive invitation from friend
social_graph(Id, [msg(From, Id, inv(Founder, Name, Streams))|In], Fs) :-
    attestation(inv(Founder, Name, Streams), att(From, _)) |
    lookup_send(user, msg(agent, user, 
                join_group(From?, Founder?, Name?)), Fs?, Fs1),
    social_graph(Id, In?, Fs1?).

% User decision on invitation
social_graph(Id, [msg(user, Id, join(yes, Founder, Name, Streams))|In], Fs) :-
    social_graph(Id, In?, [((Founder,Name), group(member, Streams?))|Fs?]).
social_graph(Id, [msg(user, Id, join(no, _, _, _))|In], Fs) :-
    social_graph(Id, In?, Fs?).
\end{verbatim}

The founder creates interlaced stream structures for all members and sends invitations through authenticated friend channels. Recipients verify the invitation's attestation before consulting their user. Accepted groups are stored with key (Founder, Name), ensuring uniqueness whilst clarifying ownership.

\mypara{Group Messaging via Interlaced Streams}
Group members maintain independent message streams whilst observing others' messages, creating causal ordering through the interlaced streams mechanism:

\Program{Group Messaging}\label{program:group-messaging}
\begin{verbatim}
% Member participates in group
group_member(Id, (Founder, Name), Streams) :-
    lookup((Founder,Name), Fs?, group(Role, Streams)),
    compose_messages(Id?, Name?, Messages),
    find_my_stream(Id?, Streams?, MyStream),
    interlace(Messages?, MyStream?, [], Streams?).

compose_messages(Id, Name, [Msg|Msgs]) :-
    await_user_input(Id?, Name?, Input),
    format_message(Input?, Id?, Msg),
    compose_messages(Id?, Name?, Msgs?).
compose_messages(_, _, []).

format_message(reply(Text), Id, msg(Id, reply, Text)).
format_message(post(Text), Id, msg(Id, post, Text)).
\end{verbatim}

Members post independently without control tokens. The interlaced streams mechanism (Program~\ref{program:interlaced-streams}) ensures each member's block references all observed messages. When member p replies to message m, the reply appears in p's stream only after p has observed m, creating natural causality where replies follow what they reply to whilst independent messages remain unordered.

Security derives from authenticated friend channels—all group communication occurs through channels established via the social graph protocol, with automatic attestation on every message. Byzantine agents outside the group cannot inject messages as they lack authenticated channels to members. The interlaced structure provides causal consistency equivalent to consensus protocols whilst eliminating their overhead, demonstrating how authenticated channels combined with GLP's concurrent programming primitives enable efficient group communication without centralisation or Byzantine agreement.

\subsection{Content Authenticity and Provenance}

Content authenticity in GLP derives from the attestation mechanism applied recursively through forwarding operations. When agent p creates post P, it carries attestation $(P)_{M,p,*}$. When agent q forwards this post, the forward operation wraps the entire attested post: `forward(p, P)`, which receives attestation $(forward(p,P))_{M,q,*}$. Recipients can verify both q's forwarding attestation and p's original creation attestation, with the nesting depth revealing the complete forwarding chain.

This mechanism addresses three vulnerabilities in conventional social networks. First, impersonation becomes cryptographically impossible—agents cannot forge attestations for other agents' keys. Second, misattribution is prevented—the original author's attestation remains embedded regardless of forwarding depth. Third, conversation manipulation is detectable—group messages through interlaced streams create a tamper-evident partial order where altered histories fail attestation verification. These properties emerge from the language-level integration of attestations with GLP's communication primitives, requiring no external trust infrastructure or consensus protocols.

\section{Implementation}

The implementation of Grassroots Logic Programs on smartphones requires cross-platform mobile deployment, garbage-collected memory management, lightweight concurrency, cryptographic operations, and TEE attestation access. The Dart programming language~\cite{dartIsolates}, deployed via Flutter~\cite{flutter}, satisfies these requirements. Flutter compiles to native iOS and Android applications from a single codebase, while Dart's event loop with microtask scheduling maps naturally to GLP's operational semantics. Flutter plugins provide access to Google Play Integrity~\cite{googlePlayIntegrity} and Apple App Attest~\cite{appleAppAttest}, enabling TEE-based peer verification. Server infrastructure supports initial attestation and NAT traversal via STUN~\cite{rfc5389}, TURN~\cite{rfc5766}, and ICE~\cite{rfc8445}, but core GLP execution remains peer-to-peer on smartphones.

\mypara{Architecture}
The Dart implementation maps the formal `implementation-ready' multiagent GLP semantics (detailed in Appendix~\ref{appendix:IR-maGLP}) to concrete smartphone operations. Each agent maintains its resolvent as Dart microtasks with three goal categories: active (queued for reduction), suspended (awaiting variable bindings), and failed (permanently blocked). A shared variable table tracks creator-holder relationships for distributed variables, enabling message routing without consensus protocols.

The implementation preserves GLP's three core transactions. \textbf{Reduce} performs goal/clause reduction within Dart microtasks, generating assignments for remote readers that enter the message queue $M_p$. \textbf{Communicate} delivers these assignments across agents via encrypted, signed, and attested messages routed through variable creators, with the Dart event loop processing received messages and updating the variable table $V_p$. \textbf{Network} handles initial channel establishment for cold calls using platform-specific APIs (WebRTC for peer-to-peer, HTTPS for NAT traversal). The single-reader/single-writer invariant eliminates distributed unification and is enforced through exclusive variable table tracking, while creator-mediated routing ensures messages reach their destinations despite variable migration. Variable abandonment detection runs as a periodic microtask, scanning for unreachable variables and generating appropriate abandonment messages.

\mypara{Security} Security enforcement occurs at message boundaries as specified in Section~\ref{section:secturemaGLP}. While the formal specification in Appendix~\ref{appendix:irmaGLP} requires attestation, signature and encryption for every message, practical implementations employ the standard cryptographic optimizations described in Section~\ref{section:secturemaGLP}—including intermittent attestation verification and session-key-based channels—to reduce computational overhead while maintaining security guarantees. 


\section{Related Work}\label{section:related-work}

Implementing grassroots platforms imposes distinctive requirements on a programming language. Agents must verify each other's cryptographic identity and application-level code integrity upon first contact, establishing authenticated communication channels that form the grassroots social graph. Since the same agent may run multiple grassroots platforms concurrently (social networks, currencies, governance) and participate in multiple independent instances of each platform simultaneously, agents must verify not only that counterparts execute trusted runtime code but also which specific application protocols they implement and whether those protocols are compatible for interoperation. This application-level attestation must integrate into the language's operational semantics, enabling programs themselves to inspect attestation evidence and make protocol-compatibility decisions. Multiple independent platform instances must emerge without coordination and coalesce spontaneously when instances meet through peer-initiated connections, requiring no global infrastructure beyond peer-to-peer networking. Additionally, the language should support metaprogramming—the ability to write programs that reason about and manipulate its own programs—enabling development of programming tools, debuggers, and runtime environments within the language itself, essential for a productive platform development ecosystem.
We examine existing work in distributed programming languages and secure frameworks to assess how they address these requirements.





\mypara{Distributed actor and process languages}
Actor-based and process-oriented languages~\cite{agha1986actors} provide foundations for distributed computation through message-passing concurrency and isolation. Erlang/OTP~\cite{armstrong2013programming} achieves fault isolation through separate memory spaces and location-transparent messaging, whilst active object languages~\cite{boer2017survey,boer2024active} provide structured concurrency with asynchronous method calls and futures. Pony~\cite{clebsch2015deny} achieves compile-time prevention of data races through capability-based type systems, whilst Swift's distributed actors~\cite{swift2021distributed} extend local actor isolation to distributed systems with location transparency. These languages excel at building distributed systems where processes communicate through well-defined channels. However, we are not aware of mechanisms in these languages enabling application code to inspect attestation evidence about which specific protocols counterpart agents implement. While these systems may employ transport-level security (TLS, mutual authentication), verification remains at the infrastructure level rather than enabling applications to programmatically reason about protocol compatibility. These frameworks typically assume deployment within pre-established clusters or service meshes with coordinated configuration.

\mypara{Capability security and distributed object languages}
E~\cite{miller2006robust} provides capability-based security through unforgeable object references with automatic encryption of all distributed communication. While E's unforgeable references ensure object uniqueness and provide robust access control, they do not address GLP's requirements for verifying the real-world identity of agents or attesting which protocol implementation they execute. For grassroots platforms, agents must verify both social identity (who holds this key?) and protocol compatibility (what code are they running?). These are distinct security concerns from E's capability-based authorization model.


\mypara{Session types in programming languages}
Session types~\cite{honda1993types} ensure protocol conformance through compile-time type checking. Languages including Links~\cite{cooper2007links,lindley2017lightweight}, Rust~\cite{jespersen2015session}, Scala~\cite{scalas2016lightweight}, and Go~\cite{castro2019distributed} verify that programs follow communication protocols statically. However, grassroots platforms require runtime verification of participants' identities and which protocol implementations they execute—properties beyond type system scope. Session types ensure code follows protocols; attestation verifies which protocols agents run.

\mypara{Authorization and policy languages}
Declarative authorization languages achieve mainstream adoption for policy specification and enforcement. OPA/Rego~\cite{opa2021} provides Datalog-based policy-as-code for cloud infrastructure, whilst Cedar~\cite{hicks2023cedar} introduces verification-guided authorization with formally proven security properties including default deny and forbid-overrides-permit semantics. These languages excel at expressing authorization policies declaratively, separating policy from application logic and enabling independent auditing. However, they are specialized for policy evaluation rather than general-purpose programming, and whilst they can consume authentication tokens or credentials as inputs, they do not integrate attestation evidence as first-class primitives enabling applications to verify what code remote parties execute. 

\mypara{Concurrent logic programming languages}
Concurrent logic programming languages~\cite{shapiro1989family} extend logic programming with concurrent execution, where multiple concurrent processes communicate and synchronize by binding shared logic variables. Concurrent Prolog~\cite{shapiro1987concurrent} introduced read-only variables ($?$-annotated) paired with write-once variables, enabling asynchronous communication between processes—writers bind variables whilst readers suspend until values become available. PARLOG~\cite{clark1986parlog}, GHC~\cite{ueda1986guarded}, and others employed static mode declarations or guards to distinguish read and write access to shared logic variables. However, these languages do not associate exclusive read-and-write capabilities with individual variables—a key requirement for establishing secure point-to-point communication channels in distributed settings. GLP borrows the notion of read-only variables from Concurrent Prolog but enforces the Single-Reader/Single-Writer (SRSW) restriction: each variable (reader or writer) occurs at most once in any configuration. Each reader/writer pair serves as a single-message communication channel from the writer to the reader. Since messages may contain logic variables (both readers and writers), sophisticated bidirectional communication protocols emerge through exchanging streams—incrementally constructed lists where each element may contain further shared variables. The SRSW invariant enables signed and encrypted point-to-point communication, as the single writer-to-single reader relationship provides the cryptographic foundation for authenticated messaging, whilst eliminating the need for distributed atomic unification~\cite{kleinman1990distributed}. 

Unlike the languages reviewed above, logic programming languages are inherently suited for metaprogramming due to their homoiconic nature—programs are themselves terms in the language, enabling programs to naturally reason about and manipulate program structures through unification and clause definition. This property proves essential for GLP platform development: debugging tools can inspect program execution through meta-interpretation~\cite{safra1988meta,lichtenstein1988concurrent}, development environments can analyse protocol compatibility between modules, and runtime systems can verify attestation properties by examining program structure~\cite{shapiro1984systems}. GLP inherits this metaprogramming capability whilst adding security properties, enabling the development of self-contained platform development tools within the language itself.

In summary, the surveyed literature reveals no published work combining declarative policy languages with TEE attestation for distributed trust management, despite both technologies being mature independently.

\bibliography{bib}

\appendix

\section{Logic Programs Syntax}\label{appendix:lp}


\begin{definition}[Logic Programs Syntax]\label{definition:lp-syntax}
The syntax of Logic Programs is defined thus:
\begin{itemize}
    \item A \temph{variable} is an alphanumeric string beginning with uppercase letter, e.g. \verb|X, X1, Xs|. We use $V$ to denote the set of all variables.
    
    \item A \temph{constant} is a string beginning with a lowercase letter, e.g. a, a1, and foo, as well as any quoted string, e.g. \verb|","| and \verb|"X"|.
    
    \item A \temph{number} is a numeric string, which may include a decimal point, e.g. 0, 1, 103.65.
    
    \item A \temph{logic term}, or \temph{term} for short is a variable in $V$, a constant, a number, as well as a \temph{composite term} of the form $f(T_1,T_2,\ldots,T_n)$, $n \ge 1$, where $f$ is a constant and each $T_i$ is a term, $i \in [n]$, referred to as a \temph{subterm} of $T$.
    \item A term $T$ \temph{occurs} in term $T'$, denoted $T \in T'$, if $T=T'$ or if $T'$ is an $n$-ary term
    $f(T_1,T_2,\ldots,T_n)$ for some constant $f$ and $T$ occurs in $T_i$ for some $i \in [n]$. A term is \temph{ground} if it contains no variables, namely $X \notin T$ for any $X \in V$. We let $\calT$ denote the set of all terms.

    \item \temph{Lists:} By convention the constant \verb|[]| (read ``nil'') represents an empty list, the binary term \verb=[X|Xs]= represents a (linked) list with the first element \verb|X| and (a link to the) rest \verb|Xs|, the term \verb|[X]| is a shorthand for \verb=[X|[]]= and the term \verb=[X1,X2,...Xn]= is a shorthand for the nested term \verb=[X1|[X2|...[Xn|[]]...]]=. 
    
    \item An \temph{atom} is a constant or a composite term.
    
    \item A \temph{goal} is a term of the form $a_1, a_2,\ldots a_n$, $n\ge 0$, where each $a_i$ is an atom, $i \in [n]$. Such a goal is \temph{empty} if $n=0$, in which case it may also be written as \verb|true|, \temph{atomic} if $n=1$, and \temph{conjunctive} if $n \ge 2$. A conjunctive goal can be written equivalently as $(a_1,(a_2,(\ldots a_n)\ldots))$, where $(a,b)$ is a shorthand for \verb|","|$(a,b)$. As goal order is immaterial here, a conjunctive goal is identified with a multiset of its atoms and an atomic goal with its singleton. Let $\calA$ denote the set of all atoms and $\calG$ the set of all goals.

     \item A \temph{clause} is a term of the form $A$ \verb|:-| $B$ (read `$A$ if $B$'), where $A$ is an atom, referred to as the clause's \temph{head}, and $B$ is a (possibly empty) goal, referred to as the clause's \temph{body}. If $B$ is empty then the clause is called \temph{unit} and can be written simply as $A$. The underscore symbol \verb|_| is a \emph{don't-care variable} that stands for a variable occurring only once, which can be bound to any value that subsequently cannot be unified.
    
    \item A \temph{logic program} is a finite sequences of ``.''-separated clauses.
  As a convention, clauses for the same predicate (name and arity) are grouped together and are referred to as the \temph{procedure} for that predicate.  Given logic program $M$, let $\calA(M)$ and $\mathcal{G}(M)$ be the subsets of $\calA$ and $\calG$, respectively, that include only the vocabulary (constant, function, and predicate symbols) of $M$. 
\end{itemize}
\end{definition}


\section{Proofs}\label{appendix:proofs}

\LPComputationisDeduction*
\begin{proof}
We prove by induction on the length of the run that each step preserves logical consequence.

\mypara{Base case} For $n=0$, we have $G_0 = G_0$ with empty substitution $\epsilon$. The outcome $(G_0 \verb|:-| G_0)$ is a tautology, hence a logical consequence of any program.

\mypara{Inductive step} Assume the proposition holds for runs of length $k$. Consider a proper run of length $k+1$:
$$\rho: G_0 \xrightarrow{\sigma_1} \cdots \xrightarrow{\sigma_k} G_k \xrightarrow{\sigma_{k+1}} G_{k+1}$$

By the inductive hypothesis, $(G_0 \verb|:-| G_k)\sigma'$ is a logical consequence of $M$, where $\sigma' = \sigma_1 \circ \cdots \circ \sigma_k$.

For the transition $G_k \xrightarrow{\sigma_{k+1}} G_{k+1}$:
\begin{itemize}
   \item There exists atom $A \in G_k$ and clause $(H \verb|:-| B) \in M$ renamed apart
   \item $\sigma_{k+1}$ is the mgu of $A$ and $H$
   \item $G_{k+1} = (G_k \setminus \{A\} \cup B)\sigma_{k+1}$
\end{itemize}

Since $(H \verb|:-| B)$ is a clause in $M$ and $\sigma_{k+1}$ unifies $A$ with $H$, we know that:
\begin{itemize}
   \item The instance $(H \verb|:-| B)\sigma_{k+1}$ is a logical consequence of $M$ (by instantiation of a program clause)
   \item Since $A\sigma_{k+1} = H\sigma_{k+1}$ (by the mgu property), we can replace $A$ with $B$ under substitution $\sigma_{k+1}$
   \item Therefore, the implication $(G_k \verb|:-| G_{k+1})$ is a logical consequence of $M$ when we consider that $G_{k+1}$ was obtained by replacing $A$ in $G_k$ with $B$ and applying $\sigma_{k+1}$
\end{itemize}

By the transitivity of logical consequence, if $(G_0 \verb|:-| G_k)\sigma'$ is a logical consequence of $M$ and $(G_k \verb|:-| G_{k+1})$ follows from $M$ under the additional substitution $\sigma_{k+1}$, then $(G_0 \verb|:-| G_{k+1})(\sigma' \circ \sigma_{k+1})$ is a logical consequence of $M$.

Since $\sigma = \sigma' \circ \sigma_{k+1} = \sigma_1 \circ \cdots \circ \sigma_{k+1}$, we conclude that the outcome $(G_0 \verb|:-| G_{k+1})\sigma$ is a logical consequence of $M$.
\qed\end{proof}



In any $GLP$ run $G_0 \rightarrow G_1 \rightarrow \cdots$, if $G_i \rightarrow G_{i+1}$ via reduction with substitution $\sigma?$, then for any atom $A \in G_{i+1}$ that also appeared in $G_i$, we have $A = A'\tau$ where $A' \in G_i$ and $\tau$ instantiates only readers.




\ReaderOnlyInstantiation*
\begin{proof}
Consider the transition $G_i \rightarrow G_{i+1}$ via reduction of some atom $A' \in G_i$ with clause $C$. Let $(H \verb|:-| B)$ be the renaming of $C$ apart from $A'$, with writer mgu $\sigma$ and reader counterpart $\sigma?$.

By Definition~\ref{definition:glp-ts}, the Reduce transition specifies that $G_{i+1} = (G_i \setminus \{A'\} \cup B)\sigma$, and the configuration's reader substitution is updated with $\sigma?$.

For any atom $A \in G_{i+1}$ that also appeared in $G_i$, we have:

\begin{enumerate}
\item $A \neq A'$ (A was not the reduced atom). Then $A \in G_i \setminus \{A'\}$. The reduction applies $\sigma$ to all atoms in the resolvent. Since $A$ was in $G_i$ and the clause was renamed apart from the entire goal (including $A$), any writers in $A$ are distinct from $V_\sigma$. Therefore $\sigma$ does not instantiate variables in $A$. Only the reader counterpart $\sigma?$ can affect $A$. Since $\sigma?$ is a reader substitution with $V_{\sigma?} \subset V?$, we have $A$ in $G_{i+1}$ equals $A'\tau$ where $A' \in G_i$ and $\tau = \sigma?$ instantiates only readers.

\item $A = A'$ (A was the reduced atom). This case cannot occur since $A'$ is removed from the resolvent during reduction and thus cannot appear in $G_{i+1}$.
\end{enumerate}

Therefore, any atom persisting from $G_i$ to $G_{i+1}$ is instantiated only by the reader substitution $\sigma?$.
\qed
\end{proof}


\GLPComputationsareDeductions*
\begin{proof}
Follows from the correspondence between GLP reductions and LP reductions on pure logic variants, combined with Proposition~\ref{proposition:LP-computation-deduction}.
\qed
\end{proof}


\SRSWInvariant*
\begin{proof}
By induction on run length. The base case holds by assumption. For the inductive step, consider $G_i \rightarrow G_{i+1}$ via reduction with clause $C$ renamed apart. The renamed clause has fresh variables satisfying the SRSW syntactic constraint. The reduction replaces atom $A$ with body $B$ and applies $\sigma?$. Since $\sigma?$ replaces variables with terms (eliminating variable occurrences rather than duplicating them), and $B$ has fresh variables distinct from $G_i$, the SRSW invariant is preserved in $G_{i+1}$.
\qed\end{proof}


\Acyclicity* 
\begin{proof}
By induction on run length. For the base case, $G_0$ contains no circular terms by assumption. For the inductive step, assume $G_i$ contains no circular terms and consider the transition $G_i \rightarrow G_{i+1}$ via reduction of atom $A$ with clause $C$. Let $(H \verb|:-| B)$ be the renaming of $C$ apart from $A$, with writer mgu $\sigma$ and reader counterpart $\sigma?$. The reader counterpart exists only if for all $X \in V_\sigma$, $X? \notin X\sigma$ (occurs check). This ensures no writer is bound to a term containing its paired reader. Since $G_{i+1} = (G_i \setminus \{A\} \cup B)\sigma?$, and the occurs check prevents circular bindings, $G_{i+1}$ contains no circular terms.
\qed\end{proof}


\mypara{Monotonicity}
Unlike LP where variable instantiation can cause a previously reducible goal to fail, GLP exhibits monotonicity. In a run, if a goal $A$ can be reduced at some point, it remains reducible at all future points in that run, where 
``future" implies that readers in $A$  (and only readers) have been further instantiated by other goal reductions.


\begin{restatable}{lemma}{ReaderOnlyInstantiation}\label{lemma:reader-only}
In any $GLP$ run $G_0 \rightarrow G_1 \rightarrow \cdots$, if $G_i \rightarrow G_{i+1}$ via reduction with substitution $\sigma?$, then for any atom $A \in G_{i+1}$ that also appeared in $G_i$, we have $A = A'\tau$ where $A' \in G_i$ and $\tau$ instantiates only readers.
\end{restatable}





\Monotonicity*
\begin{proof}
By induction on $j - i$. For the base case ($j = i$), the atom $A \in G_i$ can reduce with $C$ by assumption. For the inductive step, assume the property holds for $j = k$ and consider $j = k + 1$. 

If $A$ was reduced at some step between $i$ and $k$, then case (1) holds. Otherwise, by the inductive hypothesis, there exists $A' \in G_k$ where $A' = A\tau$ for some reader substitution $\tau$, and $A'$ can reduce with $C$.

Consider the transition $G_k \rightarrow G_{k+1}$. If the reduction involves $A'$, then case (1) holds for $j = k + 1$. If the reduction involves a different atom $B \in G_k$, then $A'$ persists in $G_{k+1}$, possibly further instantiated. Specifically, the reduction applies substitution $\sigma?$ where $\sigma?$ instantiates only readers (by definition of reader counterpart). Thus there exists $A'' \in G_{k+1}$ where $A'' = A'\sigma? = A(\tau \circ \sigma?)$, and $\tau \circ \sigma?$ is a reader substitution.

Since $A'$ could reduce with $C$ (renamed apart) via some writer mgu at step $k$, and $\sigma?$ only instantiates readers, the unification of $A''$ with the head of $C$ (appropriately renamed) still succeeds: reader instantiation preserves unifiability and cannot introduce new writer instantiation requirements. Therefore $A''$ can reduce with $C$ at step $k + 1$.
\qed\end{proof}



\maGLPisgrassroots*    
\begin{proof}
We prove that maGLP is oblivious and interactive.
\begin{enumerate}
    \item \textbf{maGLP is Oblivious:}  Follows directly from Proposition~\ref{proposition:oblivious}.
    \item \textbf{maGLP is Interactive:}  We have to show that in any configuration $c$ of a run of maGLP over $P$, if this configuration is in fact  configuration over $P'\supset P$, then members of $P$ have a behaviour not available to them if this was a run over $P$. The answer, of course, is that in such a case any agent $q\in P'\setminus P$ can send a network message to some agent $p\in P$, resulting in the local state of $p$ having an `alien trace'—a variable produced by an agent not in $P$—a behaviour not available to $P$ on their own.
\end{enumerate}
We conclude that maGLP is grassroots.
\qed\end{proof}


\section{GLP Programs}\label{appendix:additional-techniques}

This appendix presents GLP programs that were referenced in the main text, as well as additional programs that demonstrate the language's capabilities.


\subsection{Stream Tagging for Source Identification}

When multiple input streams merge into a single stream, the source identity of each message is lost. Stream tagging preserves this information by wrapping each message with its source identifier:

\Program{Stream Tagging}\label{program:tag-stream}
\begin{verbatim}
tag_stream(Name, [M|In], [msg(Name?, M?)|Out]) :-
    tag_stream(Name?, In?, Out?).
tag_stream(_, [], []).
\end{verbatim}

The procedure recursively processes the input stream, wrapping each message \verb|M| in a \verb|msg(Name, M)| term that includes the source name. The tagged stream can then be safely merged with other tagged streams while preserving source information, essential for multiplexed message processing where receivers must determine message origin.

\subsection{Stream Observation}


For non-ground data requiring observation without consumption, the observer technique forwards communication bidirectionally while producing a replicable audit stream:

\Program{Concurrent Observer}\label{program:observer}
\begin{verbatim}
observe(X?, Y, Z) :- observe(Y?, X, Z).
observe(X, X?, X?) :- ground(X) | true.
observe(Xs, [Y1?|Ys1?], [Y2?|Ys2?]) :-
    Xs? = [X|Xs1] |
    observe(X?, Y1, Y2),
    observe(Xs1?, Ys1, Ys2).
\end{verbatim}

\subsection{Cooperative Stream Production}

While the single-writer constraint prevents competitive concurrent updates, GLP enables sophisticated cooperative techniques where multiple producers coordinate through explicit handover:

\Program{Cooperative Producers}\label{program:cooperative}
\begin{verbatim}
producer_a(control(Xs,Next)) :-
    produce_batch_a(Xs,Xs1,Done),
    handover(Done?,Xs1,Next).

producer_b(control(Xs,Next)) :-
    produce_batch_b(Xs,Xs1,Done),
    handover(Done?,Xs1,Next).

handover(done,Xs,control(Xs,Next)).

produce_batch_a([a,b,c|Xs],Xs,done).
produce_batch_b([d,e,f|Xs],Xs,done).
\end{verbatim}

The \verb|control(Xs,Next)| term encapsulates both the stream tail writer and the continuation for transferring control, enabling round-robin production, priority-based handover, or dynamic producer pools.

These examples demonstrate GLP as a powerful concurrent programming language where reader/writer pairs provide natural synchronization, the single-writer constraint ensures race-free concurrent updates, and stream-based communication enables scalable concurrent architectures.



\subsection{Network Switch}

For three agents \verb|p, q ,r| and three channels  with them \verb|Chp, Chq, Chr|, it is initialized with 
\verb|network((p,Chp?),(q,Chq?),(r,Chr?))|.


\Program{3-Way Network Switch}\label{program:3-way-network-switch}
\begin{verbatim}
% P to Q forwarding
network((P,ChP),(Q,ChQ),(R,ChR)) :-
    ground(Q), receive(ChP?,msg(Q,X),ChP1), send(ChQ?,X?,ChQ1) |
    network((P,ChP1?),(Q,ChQ1?),(R,ChR?)).

% P to R forwarding  
network((P,ChP),(Q,ChQ),(R,ChR)) :-
    ground(R), receive(ChP?,msg(R,X),ChP1), send(ChR?,X?,ChR1) |
    network((P,ChP1?),(Q,ChQ?),(R,ChR1?)).

% Q to P forwarding
network((P,ChP),(Q,ChQ),(R,ChR)) :-
    ground(P), receive(ChQ?,msg(P,X),ChQ1), send(ChP?,X?,ChP1) |
    network((P,ChP1?),(Q,ChQ1?),(R,ChR?)).

% Q to R forwarding
network((P,ChP),(Q,ChQ),(R,ChR)) :-
    ground(R), receive(ChQ?,msg(R,X),ChQ1), send(ChR?,X?,ChR1) |
    network((P,ChP?),(Q,ChQ1?),(R,ChR1?)).

% R to P forwarding
network((P,ChP),(Q,ChQ),(R,ChR)) :-
    ground(P), receive(ChR?,msg(P,X),ChR1), send(ChP?,X?,ChP1) |
    network((P,ChP1?),(Q,ChQ?),(R,ChR1?)).

% R to Q forwarding
network((P,ChP),(Q,ChQ),(R,ChR)) :-
    ground(Q), receive(ChR?,msg(Q,X),ChR1), send(ChQ?,X?,ChQ1) |
    network((P,ChP?),(Q,ChQ1?),(R,ChR1?)).
\end{verbatim}

\subsection{The Grassroots Social Graph Protocol}

\Program{Social Graph Cold-Call Befriending Protocol}\label{program:social-graph}
\begin{verbatim}
% Process user request to connect
social_graph(Id, [msg(user, Id, connect(Target))|In], Fs) :-
    ground(Id), ground(Target) |
    lookup_send(net, msg(Id, Target, offer(Resp)), Fs?, Fs1),
    inject(Resp?, msg(Target, Id, response(Resp)), In?, In1),
    social_graph(Id, In1?, Fs1?).

% Process received offer
social_graph(Id, [msg(From, Id, offer(Resp))|In], Fs) :-
    ground(Id) |
    lookup_send(user, msg(agent, user, befriend(From?, Resp)), Fs?, Fs1),
    social_graph(Id, In?, Fs1?).

% Process user decision on received offer
social_graph(Id, [msg(user, Id, decision(Dec, From, Resp?))|In], Fs) :-
    ground(Id) |
    bind_response(Dec?, From?, Resp, Fs?, Fs1, In?, In1),
    social_graph(Id, In1?, Fs1?).

% Process response to sent offer
social_graph(Id, [msg(From, Id, response(Resp))|In], Fs) :-
    ground(Id) |
    handle_response(Resp?, From?, Fs?, Fs1, In?, In1),
    social_graph(Id, In1?, Fs1?).

% Application message handling
social_graph(Id, [msg(From, To, Content)|In], Fs) :-
    ground(Id), otherwise |
    % Forward to application layer
    social_graph(Id, In?, Fs?).


inject(X,Y,Ys,[Y?|Ys?]) :- known(X) | true.
inject(X,Y,[Y1|Ys],[Y1?|Ys1?]) :- unknown(X) | inject(X?,Y?.Ys?,Ys1).


\end{verbatim}

The first clause handles user-initiated connections by sending an offer containing an unbound response variable through the network. The \verb|wait_merge| procedure creates a suspended stream that will merge the response when the variable becomes bound, enabling non-blocking continuation. The second clause receives offers from other agents and forwards them to the user interface for approval, including the response variable that the user's decision will bind. The third clause processes user decisions, calling \verb|bind_response| to handle acceptance or rejection. The fourth clause handles responses to the agent's own offers.

\verb|inject| defers the injection of a message into a stream  until variable X becomes bound,
enabling responsive systems that can continue processing other operations while
waiting for specific events. The social graph protocol uses this technique to
handle asynchronous connection responses without blocking the main message
processing loop.

The protocol's response handling demonstrates sophisticated use of GLP's concurrent programming capabilities. When an offer is accepted, both agents must establish symmetric channel configurations and merge the new friend's input stream into their main processing loop:

\Program{Response Processing}\label{program:response-handling}
\begin{verbatim}
% Bind response based on user decision
bind_response(yes, From, accept(FCh), Fs, Fs1, In, In1) :-
    new_channel(ch(FIn, FOut), FCh),
    handle_response(accept(FCh?), From, Fs, Fs1, In, In1).
bind_response(no, _, no, Fs, Fs, In, In).

% Handle response (for both received and sent offers)
handle_response(accept(ch(FIn, FOut)), From, Fs, [(From, FOut)|Fs], In, In1) :-
    tag_stream(From?, FIn?, Tagged),
    merge(In?, Tagged?, In1).
handle_response(no, _, Fs, Fs, In, In).
\end{verbatim}

When accepting an offer, \verb|bind_response| creates a new channel pair using \verb|new_channel|, which produces two channels with crossed input/output streams. The acceptor retains one channel and sends the other through the response variable, ensuring both agents receive complementary channel endpoints. The \verb|handle_response| procedure, called for both accepted sent offers and accepted received offers, adds the friend's output stream to the friends list and merges the tagged input stream into the main message flow. The stream tagging preserves sender identity after merging, enabling the agent to determine message origin.

\mypara{Friend-Mediated Introductions}
Beyond cold calls, the social graph protocol enables friend-mediated introductions, leveraging existing trust relationships to establish new connections. When agent $r$ is friends with both $p$ and $q$, it can introduce them to each other, creating a direct communication channel between them.

\Program{Friend-Mediated Introduction Protocol}\label{program:introduction}
\begin{verbatim}
% User requests to introduce two friends
social_graph(Id, [msg(user, Id, introduce(P, Q))|In], Fs) :-
    ground(Id), ground(P), ground(Q),
    lookup(P, Fs?, ChP), lookup(Q, Fs?, ChQ) |
    facilitate_introduction(Id?, P?, Q?, ChP?, ChQ?, Fs?, Fs1),
    social_graph(Id, In?, Fs1?).

% Create introduction with fresh channel for p and q
facilitate_introduction(R, P, Q, ChP, ChQ, Fs, Fs) :-
    new_channel(ch(PQIn, PQOut), ch(QPIn, QPOut)),
    ChP = [intro(R?, Q?, ch(QPIn?, PQOut?))|ChP1?],
    ChQ = [intro(R?, P?, ch(PQIn?, QPOut?))|ChQ1?].

% Process introduction from friend
social_graph(Id, [msg(From, Id, intro(R, Other, Ch))|In], Fs) :-
    ground(Id), attestation(intro(R, Other, Ch), att(R, _)) |
    lookup_send(user, msg(agent, user, 
                intro_offer(R?, Other?, Ch?)), Fs?, Fs1),
    social_graph(Id, In?, Fs1?).

% User accepts introduction
social_graph(Id, [msg(user, Id, accept_intro(Other, Ch))|In], Fs) :-
    ground(Id) |
    Ch = ch(InStream, OutStream),
    tag_stream(Other?, InStream?, Tagged),
    merge(In?, Tagged?, In1),
    social_graph(Id, In1?, [(Other?, OutStream?)|Fs?]).

% User rejects introduction
social_graph(Id, [msg(user, Id, reject_intro(_, _))|In], Fs) :-
    social_graph(Id, In?, Fs?).
\end{verbatim}

Friend-mediated introductions provide stronger trust assurance than cold calls. The introducer $r$ creates a fresh channel pair connecting $p$ and $q$, sending each party the appropriate channel endpoint along with the identity of the other party. Recipients verify through attestation that the introduction genuinely originates from their mutual friend. 

This mechanism leverages the transitive nature of trust: if $p$ trusts $r$ and $r$ trusts $q$, then $p$ has reason to trust the introduction to $q$. The mutual friend serves as both a technical facilitator (creating and distributing the channel) and a social voucher (implicitly endorsing the connection). Unlike cold calls which require external identity verification, friend-mediated introductions carry the introducer's implicit assertion about the identity and trustworthiness of the introduced parties.

\subsection{Attestation Verification in the Social Graph Protocol}\label{appendix:verify-offer}

The social graph protocol requires verification of attestations when processing connection offers. The \verb|verify_offer| procedure checks both sender identity and module compatibility:

\begin{verbatim}
% Verify offer - check sender identity and module compatibility
verify_offer(Sender, From, Module, Resp, Fs, Fs1, In, In1) :-
    Sender = From,       % Verify claimed identity matches attestation
    module(Module) |     % Accept only identical module
    lookup_send(user, msg(agent, user, 
                befriend_verified(From?, Module?, Resp)), Fs?, Fs1),
    social_graph(Id, In?, Fs1?).
verify_offer(_, _, _, _, Fs, Fs, In, In) :- otherwise | true.  % Drop invalid offers
\end{verbatim}

This verification ensures that the attested sender matches the claimed identity (preventing impersonation) and that both agents run identical modules (ensuring protocol compatibility). Offers failing either check are silently dropped, preventing malicious or incompatible agents from establishing connections.

\subsection{Replication of Non-Ground Terms}

While the main text demonstrated distribution of ground terms to multiple consumers, many applications require replicating incrementally-constructed terms that may contain uninstantiated readers. The following replicator procedure handles nested lists and other structured terms, provided the input contains no writers. This technique suspends when encountering readers and resumes as values become available, enabling incremental replication of partially instantiated data structures.

\Program{Non-Ground Term Replicator}\label{program:replicator}
\begin{verbatim}
replicate(X, X?,..., X?) :- 
    ground(X) | true.                          % Ground terms can be shared
replicate(Xs, [Y1?|Ys1?],..., [Yn?|Ysn?]) :-   % List recursion on both parts
    Xs? = [X|Xs1] |
    replicate(X?, Y1,..., Yn),
    replicate(Xs1?, Ys1,..., Ysn).
\end{verbatim}

The replicator operates recursively on list structures, creating multiple copies that maintain the same incremental construction behavior as the original. When the input list head becomes available, all replica heads receive the replicated value simultaneously. This technique extends naturally to tuples through conversion to lists of arguments, enabling replication of arbitrary term structures that contain readers but no writers.

\subsection{Interlaced Streams as Distributed Blocklace}

A blocklace represents a partially-ordered generalization of the blockchain where each block contains references to multiple preceding blocks, forming a directed acyclic graph. This structure maintains the essential properties of blockchains while enabling concurrent block creation without consensus. GLP's concurrent programming model naturally realizes blocklace structures through interlaced streams, where multiple concurrent processes maintain individual streams while observing and referencing each other's progress.

\Program{Interlaced Streams (Blocklace)}\label{program:interlaced-streams}
\begin{verbatim}
% Three agents maintaining interlaced streams
% Initial goal:
%   p(streams(P_stream, [Q_stream?, R_stream?])),
%   q(streams(Q_stream, [P_stream?, R_stream?])),
%   r(streams(R_stream, [P_stream?, Q_stream?]))

streams(MyStream, Others) :-
    produce_payloads(Payloads),
    interlace(Payloads?, MyStream, [], Others?).

interlace([Payload|Payloads], [block(Payload?,Tips?)|Stream?], PrevTips, Others) :-
    collect_new_tips(Others?, Tips, Others1),
    interlace(Payloads?, Stream, Tips?, Others1?).
interlace([], [], _, _).

% Using reader(X) to identify fresh tips not yet incorporated
collect_new_tips([[Block|Bs]|Others], [Block?|Tips?], [Bs?|Others1?]) :-
    reader(Bs) |  % Bs unbound means Block is the current tip
    collect_new_tips(Others?, Tips, Others1).
collect_new_tips([[B|Bs]|Others], Tips?, [[Bs]?|Others1?]) :-
    % Skip B as it's already been referenced
    collect_new_tips([[Bs]?|Others?], Tips, Others1).
collect_new_tips([], [], []).
\end{verbatim}

Each concurrent process maintains its own stream of blocks containing application payloads and references to the most recent blocks observed from other processes. The `reader(X)` guard predicate identifies unprocessed blocks by detecting unbound tail variables, enabling each process to reference exactly those blocks it has not previously incorporated. This creates a distributed acyclic graph structure where the partial ordering reflects the causal relationships between blocks produced by different processes.

The interlaced streams technique demonstrates how GLP's reader/writer synchronization mechanism naturally implements sophisticated distributed data structures. The resulting blocklace provides eventual consistency guarantees similar to CRDTs while maintaining the integrity and non-repudiation properties of blockchain structures. This technique has applications in distributed consensus protocols, collaborative editing systems, and Byzantine fault-tolerant dissemination networks.


\section{Workstation Implementation-Ready Transition System for GLP}\label{apendix:irGLP}

This section specifies the implementation-ready semantics for GLP with deterministic execution. All variables are local, requiring no distributed coordination.
Its goal is to serve as a specification for a `workstation based' implementation of GLP, that can be the basis of a GLP program development environment, written in GLP.


This section presents implementation-ready semantics for single-agent GLP with deterministic scheduling. Unlike standard GLP which uses nondeterministic goal selection, irGLP employs a queue to ensure fair goal processing and explicit tracking of suspension states.

\begin{definition}[irGLP Configuration]
An \emph{irGLP configuration} over program $M$ is a triple $R = (Q, S, F)$ where:
\begin{itemize}
\item $Q \in \mathcal{A}^*$ is a sequence of active goals
\item $S \subseteq \mathcal{A} \times 2^{V?}$ contains suspended goals with their suspension sets
\item $F \subseteq \mathcal{A}$ contains failed goals
\end{itemize}
\end{definition}

The irGLP reduction extends GLP reduction by activating goals that were suspended on variables instantiated by the reduction, and explicitly failing goals that do not succeed or suspend.

\begin{definition}[irGLP Goal/Queue Reduction]
Given configuration $(Q, S, F)$ with $Q = A\cdot Q'$ and clause $C \in M$, the \emph{irGLP reduction} of $A$ with $C$:
\begin{itemize}
\item \textbf{succeeds with} $(B, \hat\sigma, R)$ if the GLP reduction of $A$ with $C$ succeeds with $(B, \hat\sigma)$ and $R = \{G : (G, W) \in S \wedge X?\in W \wedge X?\hat\sigma? \neq X?\}$
\item \textbf{suspends with} $W_C$ if GLP reduction of $A$ with $C$ suspends on readers $W_C$
\item \textbf{fails} otherwise
\end{itemize}
\end{definition}


\begin{definition}[Implementation-Ready GLP Transition System]
The transition system $\text{irGLP} = (\mathcal{C}, c_0, \mathcal{T})$ over $M$ and initial goal $G_0$ has configurations $\mathcal{C}$ being all irGLP configurations over $M$, with initial configuration $c_0 = (G_0, \emptyset, \emptyset)$, and transitions $\mathcal{T}$ being all transitions $(Q, S, F) \rightarrow (Q', S', F')$ where $Q = A \cdot Q_r$ and:
    \begin{enumerate}
    \item \textbf{Reduce:} If GLP reduction of $A$ with first applicable clause $C \in M$ succeeds with $(B, \hat\sigma,R)$:
        \begin{itemize}
        \item \textbf{Activate:}  $S' = S \setminus \{(G, W) : G \in R\}$,  $F' = F$
        \item \textbf{Schedule:} $Q' = (Q_r \cdot B \cdot R)\hat\sigma\hat\sigma?$
        \end{itemize}
    \item \textbf{Suspend:} Else if $W = \bigcup_{C \in M} W_{C} \neq \emptyset$ then $Q' = Q_r$, $S' = S \cup \{(A, W)\}$, $F' = F$
    \item \textbf{Fail:} Else,  $Q' = Q_r$, $S' = S$, $F' = F \cup \{A\}$.
    \end{enumerate}
\end{definition}

A key restriction compared to the GLP operational semantics is the immediate application of reader substitutions during reduction rather than through asynchronous communication. This simplification is appropriate for workstation execution where all variables are local.



\section{Smartphone Implementation-ready Multiagent Transition System for GLP}\label{appendix:irmaGLP}

This section combines the implementation-ready structure of irGLP (Section~\ref{appendix:irGLP}) with the multiagent framework of maGLP (Section~\ref{section:maGLP}). While irGLP provides deterministic scheduling and suspension management for single agents, and maGLP defines cross-agent communication through shared variables, irmaGLP specifies the concrete data structures and message-passing mechanisms suitable for smartphone implementation.

A variable $X$ is \emph{local} to agent $p$ if $X$ occurs in $p$'s resolvent. Non-local variables require coordination through variable tables and explicit message passing, replacing maGLP's abstract shared-variable communication with concrete routing mechanisms.

The fundamental invariant: assignments produced by Reduce transactions are immediately applied if the reader is local, otherwise they become messages routed through the variable tables. This realizes maGLP's Communicate transaction as actual inter-agent message transfer.

\begin{definition}[Implementation-Ready maGLP Transition System]
The implementation-ready maGLP transition system over agents $P \subset \Pi$ and GLP module $M$ is the multiagent transition system $\text{IRmaGLP} = (C, c_0, T)$ where:
\begin{itemize}
\item $C$ is the set of all configurations where for each $p \in P$, the local state $c_p$ is an implementation-ready resolvent as in Definition~\ref{definition:IRmaGLP-local-state}
\item $c_0$ is the initial configuration where for each $p \in P$:
  \begin{itemize}
  \item $R_p = ([\texttt{agent}(p, \texttt{ch}(_?, _), \texttt{ch}(_?, _))], \emptyset, \emptyset)$
  \item $V_p = \emptyset$  
  \item $M_p = \emptyset$
  \end{itemize}
\item $T$ is the union of all transitions generated by:
  \begin{itemize}
  \item Unary Reduce transactions for each $p \in P$ (Definition~\ref{definition:IRmaGLP-reduce})
  \item Binary Communicate transactions for each $(p, q) \in P \times P, p \neq q$ (Definition~\ref{definition:IRmaGLP-communicate})
  \item Binary Network transactions for each $(p, q) \in P \times P, p \neq q$ (Definition~\ref{definition:IRmaGLP-network})
  \end{itemize}
\end{itemize}
\end{definition}

 
\subsection{Local States}

\begin{definition}[Implementation-Ready maGLP Local State]\label{definition:IRmaGLP-local-state}
The local state of agent $p \in \Pi$ is an \temph{implementation-ready resolvent} $s_p = (R_p, V_p,M_p)$ where:
\begin{enumerate}
\item $R_p = (A_p, S_p, F_p)$ separates the resolvent goals into three types:
    \begin{itemize}
    \item \textbf{Active: }$A_p\in \calA^*$ 
    \item \textbf{Suspended:} $S_p \subseteq \mathcal{A} \times 2^{V?}$ 
    \item \textbf{Failed:} $F_p \subseteq \mathcal{A}$
    \end{itemize}
    
   \item $V_p \subseteq \calV \times \Pi \times (\mathcal{T} \cup \Pi \cup \{\bot\})$ maintains shared variable state as a set of triples where each $(Y, q, s) \in V_p$:
        \begin{itemize}
        \item \textbf{Writer:} $Y \in V$,  $s \in \mathcal{T}$ is the value of $Y$, else $s=\bot$
        \item \textbf{Created Reader:} $Y \in V?$, $q = p$, $s \in \Pi$ is the read-requesting agent, else $s=\bot$
        \item  \textbf{Imported Reader:} $Y \in V?$ (reader),  $q \neq p$, $s =q$ indicates a read request has been sent from $p$ to $q$, else  $s=\bot$ 
        \end{itemize}
        
\item $M_p$ is a set of pending messages as pairs (content, destination) where destination $q \in \Pi$:
    \begin{itemize}
    \item assignments $(X?:=T, q)$ 
    \item read requests $(request(X?, p), q)$ where $p$ requests $X?$ from $q$
    \item abandonment notifications $(abandon(X), q)$
    \end{itemize}
\end{enumerate}
\end{definition}


The resolvent $R_p$ partitions goals into three categories. Active goals $A_p$ contains a queue of goals to be reduced in FIFO order. Suspended goals $S_p$ pairs each atom with the set of readers preventing its reduction—for $(A, W) \in S_p$, the set $W$ contains all readers from the suspension sets across all clause attempts. When any reader $X? \in W$ receives a value or is abandoned, $A$ moves to the tail of $A_p$. Failed goals $F_p$ contains atoms for which every reduction attempt either failed outright or suspended only on abandoned variables.

The variable table $V_p$ maintains shared variables where one element of each reader/writer pair is local to $p$ while its counterpart is non-local. For writers, the table stores the creator and any binding to enable response to read requests. For created readers, it records which agent has requested the value. For imported readers, it tracks whether a read request has been sent to the creator. This unified structure ensures variables referenced by non-local counterparts are not prematurely garbage collected and provides routing information for cross-agent communication.

The variable table $V_p$ maintains an invariant: it contains exactly those variables whose paired counterparts are non-local. When $p$ receives a term containing a variable from $V_p$, that variable becomes local and must be removed from $V_p$. When $p$ exports a term, the export helper function updates $V_p$ accordingly: variables created by $p$ are added when first exported, while variables created by others are removed (except for requested readers which require relay variables).



\mypara{Helper Routines for Implementation-Ready Transactions, agent $p$}


The \texttt{abandon} helper notifies other agents when variable $Y$ becomes unreachable. For imported variables, it notifies the creator $q$. For created readers with a requester $s$, it notifies that requester. The paired variable $Y'$ is sent in the message to indicate which part of the pair was abandoned.



\begin{definition}[routine abandon(Y)]
\begin{itemize}
\item If $(Y, q, s) \in V_p$ where $q \neq p$: remove from $V'_p$ and add $(abandon(Y'), q)$ to $M'_p$
\item If $(Y, p, s) \in V_p$ and $s \neq \bot$: remove from $V'_p$ and add $(abandon(Y'), s)$ to $M'_p$
\item Otherwise: just remove $(Y, \cdot, \cdot)$ from $V'_p$ if present
\end{itemize}
where $Y' = Y?$ if $Y \in V$, else $Y' = Y$ if $Y \in V?$ (the paired variable)
\end{definition}


The \texttt{request} helper sends a read request for an imported reader that hasn't been requested yet. It updates the table entry from $(X?, q, \bot)$ to $(X?, q, q)$ to record that the request was sent, preventing duplicate requests.


\begin{definition}[routine request(X?)]
If $(X?, q, \bot) \in V'_p$ and $q \neq p$ then:
\begin{itemize}
\item Update to $(X?, q, q)$ in $V'_p$ 
\item Add $(request(X?, p), q)$ to $M'_p$
\end{itemize}
\end{definition}

The \texttt{export} helper updates the variable table when term $T$ is sent outside agent $p$. Variables created by $p$ are added to $V_p$ when first exported. Imported variables are typically removed since they're no longer local, except for requested readers which require special handling: a fresh relay pair $(Z, Z?)$ is created with a forwarding goal to maintain the request relationship while allowing the original reader to leave $p$'s scope.


\begin{definition}[routine export$(T)$ returns $T'$]
\begin{itemize}
Set $T' := T$
\item For each variable $Y$ occurring in $T$:
    \begin{itemize}
    \item \textbf{Local:} If $Y$ created by $p$ and $(Y, p, \cdot) \notin V'_p$: add $(Y, p, \bot)$ to $V'_p$
    \item \textbf{Non-local:} If $Y$ created by $q \neq p$ then
        \begin{itemize}
        \item \textbf{Writer or Non-requested Reader:} If $Y \in V$ or $(Y, q, \bot) \in V'_p$ then remove $(Y, q, \cdot)$ from $V'_p$
        \item \textbf{Requested Reader:} If $(Y, q, q) \in V'_p$  then create fresh pair $(Z, Z?)$, replace $Y$ with $Z?$ in $T'$, add $\text{export\_reader}(Y, Z)$ to $A'_p$, add $(Z?, p, \bot)$ to $V'_p$
        \end{itemize}
    \end{itemize}
\end{itemize}
$T'$ is the result of applying variable replacements (if any) to $T$.
\end{definition}

\begin{definition}[routine reactivate(X?) for agent p returns R]
\begin{itemize}
\item Let $R = \{G : (G, W) \in S'_p, X? \in W\}$
\item $S'_p := S'_p \setminus \{(G, W) : G \in R\}$
\item Return $R$
\end{itemize}
\end{definition}


\subsection{Transactions}

Next, we describe the implementation-ready maGLP transactions one by one:


\mypara{Abandoned variables}
During goal reduction, variables may become abandoned when their paired counterparts disappear from the computation without being instantiated. This happens when a variable that occurs in the reduced atom is neither instantiated by the reduction nor occurring in the resulting body. The implementation should detect such abandonment to prevent indefinite suspension or shared-variable entries for variables that can never receive values. Abandoned variables allow garbage-collection in shared variable tables and cause dependent suspended goals to fail rather than wait indefinitely.


\begin{definition}[Variable Abandonment in Reduction]
When reducing atom $A$ with clause $C$ yielding body $B$ and substitution $\hat\sigma$, a variable $Y$ is \emph{abandoned} if its paired variable $Y'$ satisfies all three conditions: $Y'$ occurs in $A$, $Y'$ is not instantiated by $\hat\sigma$ or $\hat\sigma?$  , and $Y'$ does not occur in $B$.
\end{definition}



\begin{definition}[Implementation-Ready Reduce Transaction]\label{definition:IRmaGLP-reduce}
The unary Reduce transaction for agent $p$ transitions $(R_p, V_p, M_p) \rightarrow (R'_p, V'_p, M'_p)$ where $R_p = (A_p, S_p, F_p)$,  $(R'_p, V'_p, M'_p): = (R_p, V_p, M_p)$ with $A_p = A \cdot A_r$ for head goal $A$:


\begin{enumerate}
\item \textbf{Reduce:} If GLP reduction of $A$ with first applicable clause $C \in M$ succeeds with $(B,\hat\sigma)$:
\begin{itemize}
    \item Let $R = \bigcup_{X? \in V_{\hat\sigma?}} \text{reactivate}(X?)$ (modifies $S'_p$)
    \item $A'_p := (A_r \cdot B \cdot R)\hat\sigma\hat\sigma?$
    \item Update $V'_p$: for each $X? \in W$ where $(X?, q, \bot) \in V'_p$, update to $(X?, q, q)$
    \item Update $M'_p$: add $(X?:=T, r)$ for each $\{X?:=T\} \in \hat\sigma?$ where $(X?, p, r) \in V'_p, r \neq \bot$
    \item Call abandon$(Y)$ for each abandoned variable $Y$
\end{itemize}
\item \textbf{Suspend:} Else if $W = \bigcup_{C \in M} W_{C} \neq \emptyset$:
\begin{itemize}
    \item $A'_p := A_r$
    \item $S'_p := S'_p \cup \{(A, W)\}$
    \item Call request$(X?)$ for each $X? \in W$ (modifies $V'_p$ and $M'_p$)
\end{itemize}

\item \textbf{Fail:} Else:
\begin{itemize}
    \item $A'_p := A_r$
    \item $F'_p := F'_p \cup \{A\}$
    \item Call abandon$(Y)$ for each variable $Y$ in $A$ (modifies $V'_p$ and $M'_p$)
\end{itemize}
\end{enumerate}
Then $R'_p := (A'_p, S'_p, F'_p)$.
\end{definition}


\begin{definition}[Implementation-Ready Communicate Transaction]\label{definition:IRmaGLP-communicate}
The binary Communicate transaction $(c_p,c_q) \rightarrow (c'_p,c'_q)$ where $p \neq q$ and $(m, q) \in M_p$. Set $(c'_p, c'_q) := (c_p, c_q)$,
remove $(m, q)$ from $M'_p$, and case:
\begin{enumerate}
\item \textbf{Assignment} $m = (X?:=T)$ where $X?$ is local to $q$: 
\begin{itemize}
    \item Let $R = $ reactivate$(X?)$ for agent $q$ (modifies $S'_q$)
    \item If $T \neq \bot$: $A'_q := (A_q \cdot R)\{X?:=T\}$, and apply $\{X?:=T\}$ to $S'_q$ and $F_q$
    \item Else: $A'_q := A_q \cdot R$
    \item Remove $(X?, \cdot, \cdot)$ from $V'_q$
    \item For each variable $Y$ in $T$ not already local to $q$ and created by $r$: add $(Y, r, \bot)$ to $V'_q$
\end{itemize}

 
\item \textbf{Read Request} $m = \text{request}(X?, p)$:
\begin{itemize}
    \item If $p = \bot$ then call abandon$(X?)$ for agent $q$ (modifies $V'_q$ and $M'_q$)
    \item Else if $(X?, q, \bot) \in V'_q$ then update to $(X?, q, p)$ in $V'_q$
    \item Else if $(X, q, T) \in V'_q$ then add $(X?:=T, p)$ to $M'_q$
\end{itemize}
\end{enumerate}
\end{definition}

\begin{definition}[Implementation-Ready Network Transaction]\label{definition:IRmaGLP-network}
The binary Network transaction $(c_p,c_q) \rightarrow (c'_p,c'_q)$ where $p \neq q$ and a new \verb|msg|$(q,X)$ appears in $p$'s network output stream. Set $(c'_p, c'_q) := (c_p, c_q)$:
\begin{itemize}
\item Let $X' := \text{export}(X)$ for agent $p$ (modifies $V'_p$ and $M'_p$)
\item Add $X'$ to $q$'s network input stream
\item For each variable $Y$ in $X'$ not already local to $q$ and created by $r$: add $(Y, r, \bot)$ to $V'_q$
\end{itemize}
\end{definition}



The scheduler operates deterministically by selecting the head of the active queue $A_p$. When any reader $X? \in W$ for a suspended goal $(A, W) \in S_p$ receives a value or is marked abandoned, the goal $A$ is moved from $S_p$ to $A_p$ for re-evaluation. Goals in $F_p$ remain terminal, preserving logical completeness while enabling runtime fault analysis.

\subsection{Extensions for Secure Multiagent GLP}

To extend the implementation-ready semantics to Secure maGLP, the following cryptographic mechanisms augment the definitions without modifying their structure:

\subsubsection{Agent Identity and Cryptography}

Each agent $p \in \Pi$ is augmented with:
\begin{itemize}
\item A self-chosen keypair $(pk_p, sk_p)$ where the public key $pk_p$ serves as the agent's identity
\item The agent identifier $p$ is synonymous with $pk_p$ throughout the system
\item We assume knowledge of  other agents' public keys through social contacts
\end{itemize}

\subsubsection{Message Authentication and Encryption}

All messages in $M_p$ are cryptographically protected. A message $(m, q) \in M_p$ becomes $(m_{M,p,q}, q)$ where the subscript notation indicates:
\begin{itemize}
\item $M$: Attestation by the GLP runtime proving $m$ resulted from correct execution of module $M$
\item $p$: Digital signature using agent $p$'s private key $sk_p$
\item $q$: Encryption using agent $q$'s public key $pk_q$
\end{itemize}

\subsubsection{Transaction Augmentations}

\paragraph{Reduce Transaction}
When generating messages $(X?:=T, r)$ for remote readers, the implementation creates $(X?:=T)_{M,p,r}$ with attestation proving the assignment resulted from correct goal/clause reduction using module $M$.

\paragraph{Communicate Transaction}
Before processing any received message $(m_{M,p,q}, q)$:
\begin{enumerate}
\item Decrypt using $q$'s private key $sk_q$
\item Verify signature using $p$'s public key $pk_p$
\item Validate attestation for module $M$
\item Discard the message if any verification fails
\item Process according to Definition~\ref{definition:IRmaGLP-communicate} only if all verifications succeed
\end{enumerate}

\paragraph{Network Transaction}
Network messages \verb|msg|$(q,X)$ are similarly protected as (\verb|msg|$(q,X))_{M,p,q}$ ensuring authenticated channel establishment.

\subsubsection{Module Verification}

\begin{itemize}
\item Each agent executes a verified GLP module $M$ with a cryptographic hash identifier
\item Attestations include the module hash, enabling recipients to verify code compatibility
\item Guard predicates \verb|attestation(X, att(Agent, Module))| and \verb|module(M)| provide program-level access to verification results
\end{itemize}

\subsubsection{Security Properties Achieved}

These extensions ensure:
\begin{itemize}
\item \textbf{Integrity}: Messages cannot be modified without detection
\item \textbf{Confidentiality}: Only intended recipients can decrypt messages
\item \textbf{Non-repudiation}: Senders cannot deny authenticated messages
\item \textbf{Authentication}: All inter-agent communication is mutually authenticated
\end{itemize}

The implementation-ready semantics with these cryptographic extensions realizes Secure maGLP while maintaining the same operational behavior for correctly authenticated participants. Byzantine agents who fail verification are effectively excluded from the computation through message rejection.

\subsection{Implementation Correctness Properties}

\begin{proposition}[Goal State Integrity]\label{proposition:goal-integrity}
For any configuration $(R_p, V_p, M_p)$ where $R_p = (A_p, S_p, F_p)$ in an IRmaGLP run, every goal of agent $p$ appears in exactly one of $A_p$, $S_p$, or $F_p$. Furthermore, $F_p$ is monotonically increasing: once a goal enters $F_p$, it remains there.
\end{proposition}

\begin{proof}
By induction on transition steps. Initially all goals are in $A_p$. The Reduce transaction (Definition~\ref{definition:IRmaGLP-reduce}) moves goals between sets atomically: from $A_p$ to $S_p$ on suspension, from $S_p$ to $A_p$ on reactivation, and to $F_p$ on failure. No transition removes goals from $F_p$.
\end{proof}

\begin{proposition}[SRSW Preservation in Implementation]\label{proposition:impl-srsw}
If the initial configuration of IRmaGLP satisfies SRSW, then for any reachable configuration and any variable $Y$, at most one agent holds $Y$ locally (in their resolvent) and at most one agent holds $Y'$ locally.
\end{proposition}

\begin{proof}
The variable table $V_p$ tracks all non-local variable references. When agent $p$ exports a variable $Y$ through the export helper (Definition~\ref{definition:IRmaGLP-local-state}), $Y$ is added to $V_p$ marking it as created by $p$ but referenced externally. The Communicate and Network transactions maintain exclusivity by transferring variables between agents rather than duplicating them. The export helper's relay mechanism for requested readers preserves the single-reader property through fresh variable pairs.
\end{proof}

\begin{proposition}[Suspension Correctness]\label{proposition:suspension-correct}
If goal $G$ is suspended on reader set $W$ at agent $p$, then $G$ transitions to active exactly when either: (1) some $X? \in W$ receives a value through a Communicate transaction, or (2) some $X? \in W$ is abandoned.
\end{proposition}

\begin{proof}
The reactivate helper (Definition~\ref{definition:IRmaGLP-local-state}) is called precisely when assignments arrive or abandonment occurs. It removes $(G, W)$ from $S_p$ if $X? \in W$, adding $G$ to the tail of $A_p$. No other operation modifies suspended goals.
\end{proof}


\end{document}

\section{=======================}


\section{Programming Grassroots Platforms in GLP}

Pure GLP provides the foundational logic programming framework with reader/writer communication and synchronization. To build practical grassroots platforms, we extend it with guards and system predicates that provide controlled access to GLP's internal runtime state, operating system services, and hardware resources. These extensions preserve GLP's core safety properties while enabling realistic applications.

\subsection{Guard and System Predicates}

\mypara{GLP Guards}
Guards provide read-only access to the runtime state of GLP computation, enabling conditional clause selection based on variable instantiation status, term structure, and resolvent content. A guard predicate appears after the clause head, separated by \verb=|=, and must be satisfied for the clause to be selected.

\begin{definition}[Guard Evaluation]\label{definition:guard-evaluation}
A guard evaluation function $\Gamma$ maps a guard $g$ and substitution $\sigma$ to \{true, false, suspend\} with three properties:
\begin{enumerate}
\item \textbf{Monotonicity}: If $\Gamma(g,\sigma) = v$ where $v \in \{true, false\}$, then $\Gamma(g,\sigma\tau) = v$ for any $\tau$
\item \textbf{Indecision}: $\Gamma(g,\sigma) = suspend$ iff there exist $\tau_1, \tau_2$ such that $\Gamma(g,\sigma\tau_1) = true$ and $\Gamma(g,\sigma\tau_2) = false$
\item \textbf{Conjunction}: $\Gamma(g_1 \land g_2, \sigma) = true$ iff $\Gamma(g_1,\sigma) = true$ and $\Gamma(g_2,\sigma) = true$
\end{enumerate}
\end{definition}
Definition~\ref{definition:goal-clause-reduction} is extended to handle guards by adding
 ``and $\Gamma(D\sigma)$ succeeds'', as follows:
\begin{definition}[GLP Reduction with guards]\label{definition:goal-clause-reduction}
 Given GLP goal $A$ and clause $C$,  with $H \verb|:- D| B$ being the result of renaming $C$ apart from $A$,
 the \temph{GLP reduction} of $A$ with $C$ \temph{succeeds with result} $(B,\sigma?)$ if $A$ and $H$ have writer mgu $\sigma$ and $\Gamma(D\sigma)$ succeeds; \temph{suspends} if $A$ has a reader-instance $A'$ for which the GLP reduction of $A'$ with $C$ succeeds; else \temph{fails}.
\end{definition}

\mypara{Guards list} The core guard predicates include:
\begin{itemize}   
    \item \verb|X=Y| succeeds if \verb|X| and \verb|Y| are identical. Can be used to increase readability by moving goal-heard unification into the guard.  
For example, using \verb|=|, the first \verb|merge| clause can be written equivalently:
\begin{verbatim}
merge(Xs,Ys,Zs?) :- Xs?=[X|Xs1], Zs=[X?|Zs1?] | merge(Ys?,Xs1?,Zs1). 
\end{verbatim}
    \item \verb|X=\=Y| succeeds if \verb|X=Y| fails.
    \item \verb|known(X)| succeeds if \verb|X| is not a variable (but may be non-ground---a term that contains variables). 
    \item \verb|ground(X)| succeeds when \verb|X| is ground.  A key advantage of this guard predicate is that if \verb|ground(X)| occurs in the guard, then the body may contain multiple copies of \verb|X?| without violating the single-writer requirement.  Hence, the SRSW invariant is appropriately relaxed for clauses with this guard. 
    \item \verb|writer(X)| succeeds if \verb|X| is an uninstantiated writer
    \item \verb|reader(X)| succeeds if \verb|X| is an uninstantiated reader (not monotonic!)
\item \verb|abandoned(X)|: Succeeds if X's paired variable no longer appears in the resolvent
\item \verb|otherwise|: Succeeds if all previous clauses for this procedure failed
\end{itemize}
Note that by Definition~\ref{definition:guard-evaluation}, \verb|known(X)| and \verb|reader(X)| fail if \verb|X| is a writer,
and \verb|ground(X)| fails if \verb|X| is or includes a writer.


\mypara{Relaxing SRSW with ground guards}
The \verb|ground(X)| guard enables a crucial relaxation of the SRSW constraint: when X is ground (contains no variables), multiple occurrences of the reader X? are permitted in a clause body. This is safe because ground terms can be replicated without violating the single-writer property—no variable bindings can occur within ground terms.

\mypara{Defined guard predicates for abstract data types}
To support abstract data types, we also provide for user-defined guards. A user defined guard is defined by a unit clause \verb|p(T1,...,Tn)| and a call \verb|p(S1,...,Sn)| in the guard is equivalent to including the equalities \verb|T1=S1,..., Sn=Tn| in the guard.
Guard definition clauses must also satisfy the SRSW syntactic restriction.

\mypara{System predicates}
System predicates provide immediate access to runtime services, operating system functions, and hardware resources. Unlike guards and goals that may suspend, system predicates execute atomically with the goal/clause reduction and must succeed. Calls to `sensitive' system predicates must be preceded with checks that ensure their success.
For now we don't need system predicates.  Here are two basic ones:
\begin{itemize}
\item \verb|evaluate(Expr?, Result)|: Arithmetic evaluation of a ground arithmetic expression
\item \verb|current_time(T)|: System timestamp
\end{itemize}

\subsection{Basic programming techniques}  Here we show basic programs that either illustrate techniques or serve as utilities, by the social graph and application layers. 


\mypara{Distributing a ground stream} Using  \verb|ground(X)|, a stream of ground terms can be distributed to arbitrarily-many consumers using the following program skeleton:


\Program{Stream Distributor}\label{program:stream-distributor}
\begin{small}
\begin{verbatim}
distribute([X|Xs],[X|Ys1],...,[X|Ysn]) :- ground(X) | 
    distribute(Xs?,Ys1?,...,Ysn?)
distribute([],[],...,[]).
\end{verbatim}
\end{small}


\mypara{Using defined guards for channel operations}
Below we employ extensively bidirectional channels, represented with the term \verb|ch(In?,Out)|, and define guard predicates for channel receiving and sending, called with \verb|send(X?,Ch?,Ch1)| and \verb|receive(X,Ch?,Ch1)| to send and receive a message \verb|X| on a channel \verb|Ch|, respectively:

\Program{Channel operations}\label{program:channel-operations}
\begin{verbatim}
send(X,ch(In,[X?|Out?)),ch(In?,Out)).

receive(X?,ch([X|In],Out?),ch(In?,Out)).

new_channel(ch(Xs?,Ys),ch(Ys?,Xs)).
\end{verbatim}
\verb|new_channel| creates a pair of channels consisting of two variable pairs, where the input of each channel is paired to the output of the other channel. To demonstrate their use, here is a simple relay program with ordinary input and output streams that sends on the channel messages it receives on its input stream, and sends on its output stream messages it receives on the channel.  It is called with \verb|relay(In,Out,Ch)| with \verb|Ch| bound to a bidirectional channel.

\Program{Streams to Channel Relay}\label{program:stream-to-challen}
\begin{verbatim}
relay(In,Out?,Ch) :- 
    In?=[X|In1], send(X?,Ch?,Ch1) | relay(In1?,Out,Ch1?).
relay(In,Out?,Ch) :- 
    receive(X,Ch?,Ch1), Out=[X?|Out1?] | relay(In?,Out1,Ch1?).
\end{verbatim}

Termination clauses can be added if needed. The unfolded program, with guard unifications applied, exposes the internal representation of the channels and may be a bit less readable to humans:

\begin{verbatim}
relay([X|In],Out?,ch(In,[X?|Out?)) :-  relay(In?,Out,ch(In?,Out)).

relay(In,[X?|Out?],ch([X|In],Out?)) :- relay(In?,Out,ch(In?,Out)).
\end{verbatim}



\mypara{State threading through tail-recursion}
Note that the standard implementation of tail-recursion is via iteration with the updated state of the recursive call.

\Program{State Threading Through Tail-Recursion}\label{program:counter}
\begin{small}
\begin{verbatim}
% Counter maintaining state through recursive calls
counter(Count, [inc|Ops]) :- 
    Count1 := Count? + 1,
    counter(Count1?, Ops?).
counter(Count, [get(C)|Ops]) :-
    C = Count?,
    counter(Count?, Ops?).
counter(Count, []).
\end{verbatim}
\end{small}


The counter demonstrates how state is threaded through recursive calls in GLP. Each operation transforms the state, passing the updated value to the next recursive call. This technique is fundamental to maintaining the Friends list in the boot protocol.

\mypara{Channels}

\Program{Interaction via Channels}\label{program:interact}
\begin{small}
\begin{verbatim}
% Interactive session with query-response protocol
interact(Ch, State) :-
    send(prompt(State?, Action), Ch?, Ch1),
    process_action(Action?, State?, State1),
    interact(Ch1?, State1?).

process_action(update(Value), _, Value).
process_action(query(Result), State, State) :-
    Result = State?.
process_action(quit, _, done).
\end{verbatim}
\end{small}

The interaction protocol demonstrates sending incomplete messages (queries with unbound response variables) through channels and waiting for responses---the mechanism used for obtaining user approval in the boot protocol.

These techniques combine in the boot protocol: state threading maintains the Friends list, accumulation adds approved friendships, and channel-based interaction obtains user consent for each cold-call offer.

\mypara{Non-blocking merge}

\Program{Non-blocking merger}
\begin{small}
\begin{verbatim}
wait_merge(X, Xs, Ys, Zs) :- known(X) | merge(Xs, Ys, Zs).
\end{verbatim}
\end{small}

\mypara{Sending to an indexed  output stream}
\begin{small}
\begin{verbatim}
lookup_send(Name, Msg, [(Name, Out)|Fs], [(Name, Out1)|Fs]) :-
    Out = [Msg|Out1].
lookup_send(Name, Msg, [F|Fs], [F|Fs1]) :-
    lookup_send(Name, Msg, Fs?, Fs1).
\end{verbatim}
\end{small}

\mypara{Network switch}
%
Assume messages have the format \verb|msg(From,To,Content)|. A network switch that has a list of identified channels, verifies  sender identity and forwards the message to its intended recipient can be defined as follows.
We show only the $(i\times j)^{th}$ clause, for $1<i<j<n$, other clauses are similar:

\Program{Network switch}~\label{program:switch}
\begin{small}
\begin{verbatim}
switch((1,Ch1),...,(i,Chi),...,(j,Chj),...,(n,Chn)). :-
    receive(Chi,M,Chi1),
    M = msg(i,j,X)
    send(Chj,M,Chj1) |
    switch((1,Ch1),...,(i,Chi1),...,(j,Chj1),...,(n,Chn)).
\end{verbatim}
\end{small}


\subsection{Programming Multiagent Systems in GLP}

Recall that our target setting is cryptographically-identified people running a grassroots platform on their mobile device.  Furthermore, we assume that the smartphone runs a certified \emph{GLP App}, which in turn may participate in  multiple instances of grassroots platforms by running GLP programs on the GLP App.  At the current level of abstraction, we refer to the GLP App an \emph{agent}, assume it has a unique identifier and two channels—bidirectional streams—one to the 'user' of the GLP App, namely the person owning and operating the smartphone, through the smartphone UI, and one to network.  In terms of GLP code, such an agent is initialized by the goal \verb|agent(Id,ChUser?,ChNet?)|.  We assume that the user can communicate with the agent using the \verb|ChUser| and that agents can communicate with each other through their network channel, for example through the network switch \verb|switch| Program~\ref{program:switch} above.


\mypara{Initializing a multiagent system} 
A multiagent system with agents $P$ is initialized with the goal
$$G_0 = \bigwedge_{p\in P} \texttt{agent}(p, \texttt{ch}(\texttt{UIn}_p, \texttt{UOut}_p), \texttt{ch}(\texttt{NetIn}_p, \texttt{NetOut}_p)) \wedge \texttt{switch}(...)$$
where the network switch  \verb|switch| has arguments $\texttt{(p, ch(NetOut}_p\texttt{?, NetIn}_p\texttt{))}$ for every $p \in P$.

\subsection{Social Graph Formation}

The social graph emerges through a protocol allowing agents to establish direct communication channels among them. The protocol handles two scenarios: cold calls for initial connections between disconnected agents, presented here, and friend-mediated introductions, presented later. 

Each agent starts with is neighbourhood in the social graph being an empty friends list, and processes three types of events: connection requests from their user, offer messages from the other agents, received from the net, and responses to their own offers. The protocol aims to use the network's message routing only for the initial offer—once accepted, the agents establish shared variables that enable all future communication, as well as introducing their friends to each other,  without external network routing.


Each agent initializes its local neighbourhood in the social graph to be the empty friends list.
Upon receipt of a friendship offer from another agent, the user is consulted, and if accepted the person is added to the list of friends and a dedicated  communication channel with the new friend is established.

\mypara{Programming principles}
The social graph protocol demonstrates key GLP programming techniques for building decentralized social applications. 
The architecture treats network and user interfaces as special entries in a friends list, unifying all message sending. All inputs merge into a single stream, enabling uniform message processing through a recursive loop where clause heads unify with different message structures.


\mypara{Non-blocking communication}
The protocol achieves asynchronous communication without blocking the main message loop. When initiating connections, an offer containing an unbound variable is sent and processing continues immediately. The response merges into the input stream when ready through a suspended stream that waits for the variable to be bound. Similarly, user queries include the offer variable, allowing the user's decision to bind it asynchronously.

\mypara{Bidirectional channel establishment}
Friend connections use bidirectional channels created with paired input/output streams. When befriending succeeds, each agent keeps their output stream in the friends list while merging the paired input stream into their main input. This creates symmetric communication where each agent can send to their output knowing it arrives at their friend's input.


\Program{Social Graph Protocol}\label{program:social-graph-complete}
\begin{small}
\begin{verbatim}
% Initial: agent(Id, ChUser, ChNet)
agent(Id, ChUser, ChNet) :- 
    ChUser = ch(UserIn, UserOut), ChNet = ch(NetIn, NetOut) |
    merge(UserIn?, NetIn?, In),
    social_graph(Id?, In?, [(user, UserOut), (net, NetOut)]).

% Process user decision to offer
social_graph(Id, [msg(user, Id, connect(Target))|In], Fs) :-
    ground(Id), ground(Target) |
    lookup_send(net, msg(Id, Target, offer(Resp)), Fs?, Fs1),
    wait_merge(Resp?, In?, [msg(Target, Id, response(Resp))], In1),
    social_graph(Id, In1?, Fs1?).
% Process offer via network
social_graph(Id, [msg(From, Id, offer(Resp))|In], Fs) :-
    ground(Id) |
    lookup_send(user, msg(agent, user, befriend(From?, Resp)), Fs?, Fs1),
    social_graph(Id, In?, Fs1?).
% Process user decision on received offer
social_graph(Id, [msg(user, Id, decision(Dec, From, Resp?))|In], Fs) :-
    ground(Id) |
    bind_response(Dec?, From?, Resp, Fs?, Fs1, In?, In1),
    social_graph(Id, In1?, Fs1?).
% Process response to user offer
social_graph(Id, [msg(From, Id, response(Resp))|In], Fs) :-
    ground(Id) |
    handle_response(Resp?, From?, Fs?, Fs1, In?, In1),
    social_graph(Id, In1?, Fs1?).
% Catch-all for other messages
social_graph(Id, [msg(From, To, Content)|In], Fs) :-
    ground(Id), otherwise |
    % Application-specific handling
    social_graph(Id, In?, Fs?).
    
% Bind response based on user decision (for offers we received)
bind_response(yes, From, accept(FCh), Fs, Fs1, In, In1) :-
    new_channel(ch(FIn, FOut), FCh),
    handle_response(accept(FCh), From, Fs, Fs1, In, In1).
bind_response(no, _, no, Fs, Fs, In, In).

% Handle response (called by bind_response or directly for responses to our offers)
handle_response(accept(ch(FIn, FOut)), From, Fs, [(From, FOut)|Fs], In, In1) :-
    merge(In, [msg(From, FIn?)|[]], In1).
handle_response(no, _, Fs, Fs, In, In).
\end{verbatim}
\end{small}

\mypara{Code walkthrough}
The initialization clause extracts input/output streams from the user and network channels, merges the inputs, and stores the outputs as special friends "user" and "net". This unified friends list enables all sending through \verb|lookup_send|.

\textbf{Initiating connections (clause 1):} User command \verb|connect(Target)| triggers sending \verb|offer(Resp)| via network. The \verb|wait_merge| creates a suspended stream containing \verb|response(Resp)| that merges when \verb|Resp| is bound by the remote agent.

\textbf{Receiving offers (clause 2):} Network message \verb|offer(Resp)| triggers a user query including the same \verb|Resp| variable. The protocol continues processing while awaiting the user's decision.

\textbf{User decisions (clause 3):} The user's \verb|decision(Dec, From, Resp?)| binds the offer variable. The \verb|bind_response| predicate creates a channel for acceptance and delegates to \verb|handle_response| for the common logic of adding friends and merging streams.

\textbf{Handling responses (clause 4):} Response messages from our offers call \verb|handle_response| directly. Both acceptance paths (user accepting others, others accepting us) converge here.

\textbf{Catch-all (clause 5):} The \verb|otherwise| guard processes application-specific messages.

The protocol elegantly handles the asymmetry between initiating and receiving connections while maintaining non-blocking operation. The use of shared variables for responses eliminates complex state tracking.


\section{The Social Graph is Grassroots}

\subsection{Overview}

Here we prove that the GLP social graph is \emph{grassroots}~\cite{shapiro2023grassrootsBA}.   To do so, we recall necessary mathematical foundations:
\begin{enumerate}
    \item \textbf{Protocols:} The notion of grassroots applies to protocols: A \emph{protocol} $\calF$ is an infinite family of multiagent transition systems, $\calF(P)$  for each set of agents $P\subset\Pi$.
    \item \textbf{Multiagent transition system:} A \emph{multiagent transition system (mts)}~\cite{shapiro2021multiagent} over a set of \emph{agents} $P\subset \Pi$ is a transition system in which states, referred to in mts as \emph{configurations}, are the product of the \emph{local states} of a given set of the agents. An mts is  \emph{$k$-ary} (unary, binary, etc.) if $k$ is the minimal number such that at most $k$ agents change their local state in any transition.
    \item \textbf{Atomic transactions:}  It turns out that a natural way to specify an mts over $P$ is via \emph{atomic transactions}, each being a multiagent transition over a set of \emph{participants} $Q\subseteq P$, some of which may  be \emph{active} (change their local state in the transaction) the others passive (do not change their state, but vital since the transaction depends on their local states being what they are)~\cite{shapiro2025atomic}.  Each atomic transaction may specify an infinite number of mts transitions over $P$, in which members of $P\setminus Q$ remain in their arbitrary local states. 
    \item \textbf{Grassroots:} Informally, proving that a protocol $\calFi$ grassroots requires proving for each two sets of agents $P\subset P'$ that:
        \begin{enumerate}
            \item \textbf{Oblivious:}  Any behaviours available to agents $P$ according to $\calF(P)$ are also available to them  when they operate within $P'$, namely in $\calF(P')$, 
            \item \textbf{Interactive:}  The set of behaviours available to agents $P$, when operating within a  $P'\supset P$, is larger then when they operate alone, namely in $\calF(P)$
        \end{enumerate}
    \item While proving that a protocol is grassroots may not be trivial in general~\cite{shapiro2023grassrootsBA}, one advantage of defining a protocol  via atomic transactions is that it is oblivious by construction~\cite{shapiro2025atomic}. All that needs to be proven is that it is interactive.  In the GLP Social Graph, we get this property thanks to the network:  in $\calF(P')$, agents in $P$ can send cold-call befriending offers to agents in $P'\setminus P$, something they cannot do in $\calF(P)$.
\end{enumerate}

\subsection{Mathematical Foundations}

\mypara{From transition systems to multiagent transition systems}
A multiagent transition system is a transition system with a given set of agents and a set of local states, in which transition system states, referred to here as configurations, are the product of the local states of the agents.

\begin{definition}[Multiagent Transition System]\label{definition:mts}
A \temph{multiagent transition system (mts)} over a set of \temph{agents} $P \subset \Pi$ and an arbitrary set of \temph{local states} $S$, with initial state $s_0\in S$, is a transition system $(C, c_0, T)$ where:
\begin{itemize}
\item $C = S^P$, referred to as \temph{configurations}, with the local state of agent $p\in P$ in configuration $c\in C$ is denoted by $c_p$.
\item $c_0 = \{s_0\}^P$ is the \temph{initial configuration}
\item $T \subseteq C \times C$ is the transition relation
\end{itemize}
An mts is  \emph{$k$-ary} (unary, binary, etc.) if $k$ is the minimal number such that at most $k$ agents change their local state in any transition.
\end{definition}

Informally, a configuration $c \in S^P$ can be thought of as an array indexed by agents in $P$, with $c_p$, the local state of $p$ in $c$, being the array element indexed by $p$.


\mypara{Defining multiagent transition systems via atomic transactions}
The key insight is that in practice  mts behaviour can often be specified through simple atomic transactions involving a minimal set of participants. A binary transaction between any two agents, when embedded in a larger system, generates transitions for all configurations where other agents maintain their states.

\begin{definition}[Atomic Transaction]\label{definition:atomic-transaction}
An \temph{atomic transaction} over agents $Q \subset \Pi$ and local states $S$ is a multiagent transition $(c, c') \in S^Q \times S^Q$ where some agents in $Q$ may be \temph{active} (change local state: $c_q \neq c'_q$) and others \temph{passive} (maintain local state: $c_q = c'_q$).
\end{definition}

\begin{definition}[Transaction Closure]\label{definition:closure}
Given transaction $t = (c, c')$ over $Q$ and set $P \supseteq Q$, the \temph{closure} $t{\uparrow}P$ is the set of all transitions over $P$ where agents in $Q$ behave as in $t$ and agents in $P \setminus Q$ remain in arbitrary local states:
$$t{\uparrow}P = \{(d, d') \in S^P \times S^P : d_q = c_q \text{ and } d'_q = c'_q \text{ for all } q \in Q\}$$
Given a set of transactions $R$ over subsets of $P$, then $R{\uparrow}P := \bigcup_{t \in R} t{\uparrow}P$.
\end{definition}

\begin{definition}[Transaction-Based Multiagent Transition System]\label{definition:transaction-mts}
Given a set of atomic transactions $R$ and agents $P$ with local states $S$ and initial state $s0\in S$, the \temph{transaction-based mts} over $P$, $S$, and $R$ is $(S^P, \{s_0\}^P,  R{\uparrow}P)$.
\end{definition}

This construction means that a single binary transaction (e.g., agent $p$ sends message to agent $q$) automatically defines transitions for all configurations of any agent set containing $p$ and $q$, with other agents as ``spectators'' maintaining their local states. See~\cite{shapiro2025atomic} for examples.

\mypara{Protocols as families of multiagent transition systems}
A protocol captures the behaviour of varying sets of agents, each operating according to the same rules but potentially interacting with different peers.

\begin{definition}[Local-states function]\label{definition:local-states}
A \temph{local-states function} $S: 2^\Pi \mapsto 2^\mathcal{S}$ maps every set of agents $P \subset \Pi$ to a set of local states $S(P) \subset \mathcal{S}$ that includes a designated initial state $s_0 \in \mathcal{S}$ and satisfies $P \subset P' \subset \Pi \implies S(P) \subset S(P')$.
\end{definition}

\begin{definition}[Protocol]\label{definition:protocol}
A \temph{protocol} $\mathcal{F}$ over a local-states function $S$ is a family of multiagent transition systems that has exactly one mts $\mathcal{F}(P) = (C(P), c_0(P), T(P))$ for every $P \subset \Pi$, where $C(P) = S(P)^P$ and $c_0(P) = \{s_0\}^P$.
\end{definition}

\mypara{Protocols defined via atomic transactions}
When protocols are defined using atomic transactions, they inherit structural properties that simplify proving grassroots.

\begin{definition}[Transactions over Local-States Function]\label{definition:transactions-over-S}
A set of transactions $R$ is \temph{over} local-states function $S$ if every transaction $t \in R$ is over agents $Q$ and states $S(Q')$ for some $Q, Q' \subseteq \Pi$. For $P \subseteq \Pi$:
$$R(P) = \{t \in R : t \text{ is over } Q \text{ and } S(Q'), Q \cup Q' \subseteq P\}$$
\end{definition}

\begin{definition}[Transactions-Based Protocol]\label{definition:transactions-protocol}
Let $S$ be a local-states function and $R$ a set of transactions over $S$. A \temph{transactions-based protocol} $\mathcal{F}$ over $R$ and $S$ is the protocol where for each $P \subset \Pi$, $\mathcal{F}(P)$ is the transaction-based mts over $P$, $S(P)$, and $R(P)$,  $\calF(P) := (S(P)^P,\{s0\}^P,R(P){\uparrow}P)$.
\end{definition}

\begin{theorem}[From~\cite{shapiro2025atomic}]\label{theorem:oblivious}
Any transactions-based protocol is oblivious.
\end{theorem}

Therefore, to prove a transactions-based protocol is grassroots, we need only establish that it is interactive.


\mypara{Defining grassroots}
Informally, in a grassroots protocol a set of agents $P$, if embedded within a larger set $P'$, can still behave as if on its own, but has additional behaviours at its disposal due to possible interactions with members of $P' \setminus P$. To define this notion formally we employ the notion of projection.

\begin{definition}[Projection]\label{definition:projection}
Let $\emptyset \subset P \subset P' \subset \Pi$. If $c'$ is a configuration over $P'$ then $c'/P$, the \temph{projection of $c'$ over $P$}, is the configuration $c$ over $P$ defined by $c_p := c'_p$ for every $p \in P$.
\end{definition}
Note that in the definition above, $c_p$, the state of $p$ in $c$, is in $S(P')$, not in $S(P)$, and hence may include elements ``alien'' to $P$, e.g., befriending offer from $q \in P' \setminus P$.
%
We use the notions of projection and closure (Definition \ref{definition:closure}) to define when a protocol is grassroots:

\begin{definition}[Oblivious, Interactive, Grassroots]\label{definition:grassroots}
A protocol $\mathcal{F}$ is:
\begin{enumerate}
    \item \temph{oblivious} if for every $\emptyset \subset P \subset P' \subseteq \Pi$, 
    $T(P){\uparrow}P'\subseteq T(P')$
    \item \temph{interactive} if for every $\emptyset \subset P \subset P' \subseteq \Pi$ and every configuration $c\in C(P')$ such that $c/P\in C(P)$, there is a computation $c\xrightarrow{*} c'$ of $\mathcal{F}(P')$ for which $c'/P\notin C(P)$.
    \item \temph{grassroots} if it is oblivious and interactive.
\end{enumerate}
\end{definition}

The interactive property requires that agents in $P$ can always potentially interact with agents in $P' \setminus P$, leaving "alien traces" in their local states that could not have been produced by $P$ operating alone.
In the case of the Social Graph,  the ``alien trace'' may include a shared logic variable produced by some $q\in P'\setminus P$.








==========



Hence, we first define the notion of multiagent transition systems.  Previous work showed how one can define a multiagent transition systems eleganctly via the notion of atomic transactions,

we first show that the GLP social graph program, together with its specific initialization structure (multiple agents each starting with \texttt{agent(Id, ChUser?, ChNet?)}), defines a protocol. We show this protocol is both oblivious and interactive, hence grassroots.



\subsection{Proving that the GLP Social Graph is Grassroots}

We now employ the transactions-based protocol framework to prove that the GLP Social Graph is grassroots.


\mypara{The social graph as a multiagent transition system}
Given agents $P \subset \Pi$, let $P^+ = P \cup \{\texttt{net}\}$ where $\texttt{net} \notin \Pi$ is the network infrastructure agent. The initial goal is:
$$G_0 = \bigwedge_{p\in P} \texttt{agent}(p, \texttt{ch}(\texttt{UIn}_p, \texttt{UOut}_p), \texttt{ch}(\texttt{NetIn}_p, \texttt{NetOut}_p)) \wedge \texttt{switch}(...)$$
where the network switch  \verb|switch| has arguments $\texttt{(p, ch(NetOut}_p\texttt{?, NetIn}_p\texttt{))}$ for every $p \in P$.


Consider the GLP transition system $\mathcal{T}_M = (\mathcal{G}, G_0, T)$ where $M$ is the social graph and switch programs.  To define it as an mts, we have to show how each transition in $T$ affects the local states of the agents.  We do it by the specifying the set of atomic transactions that induce these transition.

\mypara{GLP reductions as atomic transactions}
Let $G \in \mathcal{G}$ be a configuration (resolvent) that can be partitioned as $G = \bigwedge_{q \in P^+} G_q$ where $G_q$ is agent $q$'s local goal. A GLP reduction of $G$ using clause $C$ from module $M$ defines an atomic transaction as follows:

\begin{definition}[GLP Reduction Transaction]\label{definition:glp-transaction}
A GLP reduction where agent $p$ reduces atom $A \in G_p$ with clause $H \texttt{:-} B$ using writer mgu $\sigma$ defines transaction $t = (c, c')$ over participants:
$$Q = \{p\} \cup \{q \in P^+ : q \text{ holds reader } X? \text{ for some } X \in \text{dom}(\sigma)\}$$
The transaction $(c, c') \in (S^Q \times S^Q)$ is defined by:
\begin{itemize}
\item For the reducing agent $p$: $c_p = G_p$, $c'_p = (G_p \setminus \{A\} \cup B)\sigma?$
\item For other participants $q \in Q \setminus \{p\}$: $c_q = G_q$, $c'_q = G_q\theta$ where $\theta = \{X? \mapsto X\sigma : q \text{ holds } X?\}$
\end{itemize}
\end{definition}

\begin{observation}[GLP defines Transaction-Based MTS]
The transition system $\mathcal{T}_M$ is a transaction-based MTS over $P^+$ where each transition in $T$ is the closure $t{\uparrow}P^+$ of a GLP reduction transaction $t$.
\end{observation}


======================

\begin{observation}[Social Graph is MTS]
$\mathcal{T}_M$ is a multiagent transition system over $P^+$ where the local state of each agent is its portion of the resolvent.
\end{observation}

\begin{observation}[Reductions are Atomic Transactions]
Each GLP reduction in $\mathcal{T}_M$ defines an atomic transaction with participants being the reducing agent and agents holding readers of bound writers.
\end{observation}


=========


\mypara{The social graph as a multiagent transition system}
Given a set of agents $P$, consider the GLP transition system $\mathcal{T}_M = (\mathcal{G}, G_0, T)$ where:
\begin{itemize}
\item $G_0 = \bigwedge_{p\in P} \texttt{agent}(p, \texttt{ch}(\texttt{UIn}_p, \texttt{UOut}_p), \texttt{ch}(\texttt{NetIn}_p, \texttt{NetOut}_p)) \wedge \texttt{switch}(...)$
\item $M$ is the social graph program module together with the switch program
\item $T$ consists of GLP reductions using clauses from $M$
\end{itemize}

\begin{observation}
The transition system $\mathcal{T}_M$ is a multiagent transition system over $P$ and $\mathcal{G}$ where:
\begin{itemize}
\item The local state of agent $p \in P$ is the instantiated goal $\texttt{social\_graph}(p, in, fs)\sigma$ 
\item The initial local state $s_0$ is $\texttt{agent}(p, \texttt{ch}(\texttt{UIn}_p, \texttt{UOut}_p), \texttt{ch}(\texttt{NetIn}_p, \texttt{NetOut}_p))$
\item The SRSW invariant ensures each agent's variables are disjoint, so the global goal naturally factors into local states $c_p$ for each $p \in P$
\item The switch operates as background infrastructure, not tracked as an agent
\end{itemize}
\end{observation}

\begin{lemma}[Social Graph Reductions are Atomic Transactions]
Each GLP reduction in $\mathcal{T}_M$ defines an atomic transaction where:
\begin{itemize}
\item Participants are the reducing agent plus all agents holding readers of bound writers
\item The transaction is k-ary where k equals the number of participants
\item Due to SRSW, local state changes are well-defined and affect only participants
\end{itemize}
\end{lemma}





===========
\mypara{Multiagent social graph system}



Given agents $P$, the social graph multiagent system initializes with goal:
$$G_0 = \bigwedge_{p\in P} \texttt{agent}(p, \texttt{ch}(\texttt{UIn}_p, \texttt{UOut}_p), \texttt{ch}(\texttt{NetIn}_p, \texttt{NetOut}_p)) \wedge \texttt{switch}(...)$$
where the network switch  \verb|switch| has arguments $\texttt{(p, ch(NetOut}_p\texttt{?, NetIn}_p\texttt{))}$ for every $p \in P$.

\begin{lemma}[The Social Graph System is an MTS]\label{lemma:sg-system-mts}
The GLP transition system $\mathcal{T}_{SG} = (\mathcal{G}, G_0, T)$ where $T$ consists of reductions using the social graph and switch programs, is an mts with:
\begin{itemize}
\item Agents: $P$ (the switch is infrastructure, not an agent)
\item Local state of $p \in P$: Its instantiated \texttt{social\_graph} goal
\item The switch operates as system infrastructure, routing messages between agents
\item The SRSW invariant ensures disjoint variable sets between agents
\end{itemize}
\end{lemma}



\begin{lemma}[Social Graph Reductions are Atomic Transactions]
Each reduction in $\mathcal{T}_{SG}$ defines an atomic transaction with participants being the reducing agent plus all agents holding readers of bound writers.
\end{lemma}



\mypara{The GLP social graph transition system}
Given a set of agents $P$, consider the GLP transition system $\mathcal{T}_M = (\mathcal{G}, G_0, T)$ where:
\begin{itemize}
\item $G_0 = \bigwedge_{p \in P} \texttt{agent}(p, \texttt{ch}(in_p, out_p), \texttt{ch}(net\_in_p, net\_out_p))$ is the initial goal with concrete channel structures (not readers)
\item $M$ is the social graph program module  
\item $T$ is the transition relation defined by GLP reductions using clauses from $M$
\end{itemize}

\begin{lemma}[Social Graph Transition System is an MTS]\label{lemma:sg-mts}
The transition system $\mathcal{T}_M$ is an mts where:
\begin{itemize}
\item The local state of agent $p$ is its component goal in the conjunction
\item The SRSW invariant ensures disjoint variable sets between agents
\item Each transition affects only participating agents (those involved in the reduction)
\end{itemize}
\end{lemma}

\begin{lemma}[GLP Reductions Define Atomic Transactions]\label{lemma:glp-atomic}
Each GLP reduction in $\mathcal{T}_M$ corresponds to an atomic transaction where participants are the reducing agent and all agents holding readers of bound writers.
\end{lemma}


=============




\mypara{Local states function for the social graph}
\begin{definition}[Social Graph Local States]\label{definition:sg-local-states}
The local states function $S_{SG}$ for the social graph is defined as follows. For each $P \subseteq \Pi$:
\begin{itemize}
\item $\mathcal{S}$ is the set of all possible instantiated goals of the form $\texttt{social\_graph}(id, in, fs)\sigma$ where $\sigma$ is a substitution
\item $s_0 = \texttt{agent}(id, ch_{user}?, ch_{net}?)$ with empty substitution
\item $S_{SG}(P)$ is the set of local states reachable by agents in $P$ through reductions of the social graph program with initial configuration $\{s_0\}^P$
\end{itemize}
\end{definition}

\begin{definition}[Social Graph Configuration]\label{definition:sg-configuration}
A configuration $c \in C(P)$ for the social graph assigns to each agent $p \in P$ its current instantiated goal. Due to the SRSW invariant, each agent's variables are disjoint from other agents' variables.
\end{definition}

\begin{definition}[GLP Reduction as Transaction]\label{definition:glp-transaction}
A GLP reduction where agent $p$ reduces goal $G$ with clause $C$ using writer mgu $\sigma$ defines an atomic transaction $t = (c, c')$ where:
\begin{itemize}
\item Participants: $Q = \{p\} \cup \{q \in P : \exists X \in V_\sigma, q \text{ holds } X?\}$
\item For $p$: $c'_p = (G \setminus \{A\} \cup B)\sigma?$ where $A$ is the reduced atom and $B$ is the clause body
\item For $q \in Q \setminus \{p\}$: $c'_q = c_q\{X? \mapsto X\sigma\}$ for all $X$ where $q$ holds $X?$
\item For $r \notin Q$: $c'_r = c_r$
\end{itemize}
\end{definition}


===============



=============

\section{OLD STUFF}
\subsection{Concept}
GLP extends logic programming with reader/writer variable pairs, similar to futures and promises in concurrent programming~\cite{haller2012futures,dauth2019futures}. A writer is a single-assignment logic variable (promise) and a reader provides read-only access to its eventual value (future). This design is inspired by Concurrent Prolog~\cite{shapiro1983subset}, which introduced read-only variables for synchronization.

The critical innovation in GLP is the single-reader/single-writer (SRSW) invariant: each writer and its paired reader can appear at most once in the resolvent (aka local state, or configuration in the multiagent case). This restriction fundamentally distinguishes GLP from prior concurrent logic languages. While Concurrent Prolog allowed multiple processes to compete for instantiating the same variable—enabling powerful synchronization mechanisms~\cite{shapiro1989family}—the implementation of its basic step of goal reduction required distributed atomic unification~\cite{kleinman1990distributed}. The SRSW invariant eliminates distributed unification: the binding by a correct agent $p$ of a writer $X$ must succeed, since the sole occurrence of $X$ is with $p$.  And upon binding $X$ to term $T$, only the agent $q$ holding the sole occurrence of the reader $X?$ needs notification. This replaces distributed atomic unification with the point-to-point passing of the message $X:= T$ from $p$ to $q$, signed by $p$'s private key and encrypted with $q$'s public key.

A simple syntactic restriction, easily verified at compile-time, ensures the SRSW invariant: at most one occurrence of each reader and one writer per clause. This restriction excludes certain logic programs, notably the standard definition of equality $X=X$, which has two occurrences of the writer $X$. 

While the SRSW invariant prevents programming techniques based on competitive variable instantiation~\cite{shapiro1983subset}, it enables efficient distributed implementation without locking or consensus. As we prove in Section~\ref{section:glp-safety}, this syntactic restriction ensures the invariant is maintained throughout distributed execution.

Next we specify GLP's syntax and operational semantics and prove some of its properties.
%A reader not interested in the logical or mathematical foundations of GLP can skip to Section~\ref{section:programming-examples}.

\subsection{Syntax and the Single-Reader/Single-Writer Constraint}\label{subsection:syntax}

GLP syntax follows standard Prolog with the crucial addition of reader/writer variable pairs, similar to read-only variables in Concurrent Prolog~\cite{shapiro1983subset}. A \temph{writer} variable \verb|X| can be instantiated once, while its paired \temph{reader} \verb|X?| provides read-only access to the eventual value, enabling secure point-to-point communication between agents.

Consider the quintessential concurrent logic program for merging two streams, written in GLP.  Its first two arguments are the input streams to be merged, and the third it the merged output stream:

\Program{GLP Fair Stream Merger}\label{program:merge}
\begin{small}
\begin{verbatim}
merge([X|Xs],Ys,[X?|Zs?]) :- merge(Ys?,Xs?,Zs). % output from first stream
merge(Xs,[Y|Ys],[Y?|Zs?]) :- merge(Xs?,Ys?,Zs). % output from second stream
merge([],[],[]).                                % terminate on empty streams
\end{verbatim}
\end{small}

As GLP chooses the first-available clause for reduction, this program fairly merges two input streams (potentially unbounded lists) into an output stream, alternating between the two input streams as long as both have values available; else it outputs whatever input value is available; else suspends until the next input is available. The readers \verb|Xs?|, \verb|Ys?|, in the recursive calls wait for values from their paired writers, enabling dataflow synchronization.

The critical syntactic restriction in GLP is the \temph{single-reader/single-writer (SRSW) constraint}: each reader and writer variable may appear at most once per clause. This restriction, easily verified at compile-time, ensures that variable bindings can be communicated as simple point-to-point messages rather than requiring distributed atomic unification~\cite{kleinman1990distributed}. For instance, the standard logic program equality definition \verb|X=X| violates this constraint as it contains two occurrences of writer \verb|X|.

For complete formal syntax definition, including terms, goals, clauses, and programs, see Appendix~\ref{appendix:syntax}.


\subsection{Transition Systems and Logic Programs}

Here we introduce transition systems, use them to define Logic Programs (LP), and prove that a logic program computation is a deduction.


\begin{definition}[Transition System]\label{definition:simple-ts}
A \temph{transition system} is a tuple $TS = (S, s_0, T)$ where:
\begin{itemize}
    \item $S$ is a set of \temph{states}
    \item $s_0 \in S$ is the \temph{initial state}
    \item $T \subseteq S \times S$ is a \temph{transition relation}. A transition $(s,s')\in T$ is also written as $s\rightarrow s' \in T$.
\end{itemize}
A \temph{computation} is a (finite or infinite) sequence $s_0, s_1, s_2, \ldots$ where $s_i \rightarrow s_{i+1} \in T$ for each $i$. A \temph{run} is a computation starting from $s_0$.
\end{definition}


An \emph{LP term/clause/program} is a GLP term/clause/program that does not include readers.  The following definition is for LP terms;  we later extend it to GLP terms.
The basic step of a logic program is the unification of a goal with a clause head.

\begin{definition}[Substitution, Renaming, Unifier, Equivalence, Most-General Unifier]\label{definition:substitution}
A \temph{substitution} $\sigma$ is an idempotent function $\sigma: V \xrightarrow{} \calT$, namely a mapping from variables to terms applied to completion. By convention, $\sigma(x)=x\sigma$.
\begin{itemize}
    \item Given a substitution $\sigma$, $V_\sigma := \{ X \in V ~|~ X\sigma \ne X\}$.
    \item Given a term $T \in \calT$ and a substitution $\sigma$, then $T\sigma$ is term obtained from $T$ by replacing every variable $X \in T$ by the term $X\sigma$.
    \item The partial order on terms $\preceq \subset \calT \times \calT$ is defined by $T \preceq T'$, or $T'$ is an \temph{instance} of $T$, if there is a substitution $\sigma$ for which $T\sigma = T'$, and 
    $T \simeq T'$ if $T \preceq T'$ and $T' \preceq T$.
    If $T \ne T\sigma$ we say that $\sigma$ \temph{instantiates} $T$. 
   
    \item For substitutions $\sigma$ and $\sigma'$, $\sigma \preceq \sigma'$ if for every $T \in \calT$, $T\sigma \preceq T\sigma'$, and $\sigma \simeq \sigma'$ if for every $T \in \calT$, $T\sigma \simeq T\sigma'$.
    
    \item A substitution $\sigma$ is \temph{as general as} substitution $\sigma'$ if $V_\sigma \subseteq V_{\sigma'}$ and $\sigma \preceq \sigma'$.
    \item A substitution $\sigma$ is a \temph{unifier} of two terms $T, T' \in \calT$ if $T\sigma = T'\sigma$; it is a \temph{most-general unifier (mgu)} of $T, T'$ if in addition it is as general as any other unifier of $T$ and $T'$.
\end{itemize}
\end{definition}

Namely, a most general unifier is frugal both in its domain (not instantiating variables unnecessarily) and in its range (not instantiating variables more than necessary).



\begin{definition}[LP Renaming, Rename apart]\label{definition:renaming}
An \temph{LP renaming} is a substitution $\sigma: V \mapsto V$ that maps variables to variables.
A renaming $\sigma$ renames $T'$ \temph{apart from} $T$ if $T$ and $T'\sigma$ have no variable in common.
\end{definition}
We assume a deterministic renaming-apart function, so that the result of renaming $T'$ apart from $T$ is well defined.
Next we define the operational semantics of Logic Programs via a transition system.
 
\begin{definition}[LP Goal/Clause Reduction]\label{definition:logic-goal-clause-reduction}
Given LP goal $A$ and clause $C$,  with $H \verb|:-| B$ being the result of renaming $C$ apart from $A$, the \temph{LP reduction} of $A$ with $C$ \temph{succeeds with result} $(B,\sigma)$ if $A$ and $H$ have an mgu $\sigma$,  else \temph{fails}.
\end{definition}

\begin{definition}[Logic Programs Transition System]\label{definition:lp-ts}
Given LP program $M$ and initial goal $G_0$, the \temph{LP transition system} is $LP = (S, s_0, T)$ where:
\begin{itemize}
    \item $S$ is the set of all logic goals.
    \item $s_0 = G_0$ 
    \item $G \rightarrow G' \in T$ if there exists an atom $A \in G$ and the LP reduction of $A$ with some $C\in M$ succeeds with result $(B,\sigma)$ then $G' = (G \setminus \{A\} \cup B)\sigma$
\end{itemize}
We write $G \xrightarrow{\sigma} G'$ when we want to make the substitution explicit.
\end{definition}
Note that $LP$ is nondeterministic in its choices of both $A\in G$ (called \emph{and-nondeterminism}) and  $C\in M$ (called \emph{or-nondeterminism}).  As such, it is closely-related to \emph{alternating Turing machines}, a generalization of nondeterministic Turing machines~\cite{shapiro1984alternation}.

\begin{definition}[Proper Run and Outcome]\label{definition:proper-run}
A run $\rho: G_0 \xrightarrow{\sigma_1} G_1 \xrightarrow{\sigma_2} \cdots \xrightarrow{\sigma_n} G_n$ of $LP$ is \temph{proper} if any $1\le i<  n$,  a variable that occurs in  $G_{i+1}$ but not in  $G_i$ also does not occur in any $G_j$, $j<i$.   If proper, the \temph{outcome} of $\rho$ is $(G_0 \verb|:-| G_n)\sigma$ where $\sigma = \sigma_1 \circ \sigma_2 \circ \cdots \circ \sigma_n$.
\end{definition}
While we use LP transition systems to define the operational semantics of Logic Programs, it so happens that the set of all outcomes of all proper runs of a logic program constitutes its fully-abstract compositional semantics~\cite{gaifman1989fully}.

\begin{proposition}[LP Computation is Deduction]\label{proposition:lp-deduction}
The outcome $(G_0 \verb|:-| G_n)\sigma$ of a proper run $\rho: G_0 \xrightarrow{\sigma_1} G_1 \xrightarrow{\sigma_2} \cdots \xrightarrow{\sigma_n} G_n$ of $LP$  is a logical consequence of $M$, where $\sigma = \sigma_1 \circ \sigma_2 \circ \cdots \circ \sigma_n$.
\end{proposition}
\begin{proof}
We prove by induction on the length of the run that each step preserves logical consequence.

\mypara{Base case} For $n=0$, we have $G_0 = G_0$ with empty substitution $\epsilon$. The outcome $(G_0 \verb|:-| G_0)$ is a tautology, hence a logical consequence of any program.

\mypara{Inductive step} Assume the proposition holds for runs of length $k$. Consider a proper run of length $k+1$:
$$\rho: G_0 \xrightarrow{\sigma_1} \cdots \xrightarrow{\sigma_k} G_k \xrightarrow{\sigma_{k+1}} G_{k+1}$$

By the inductive hypothesis, $(G_0 \verb|:-| G_k)\sigma'$ is a logical consequence of $M$, where $\sigma' = \sigma_1 \circ \cdots \circ \sigma_k$.

For the transition $G_k \xrightarrow{\sigma_{k+1}} G_{k+1}$:
\begin{itemize}
   \item There exists atom $A \in G_k$ and clause $(H \verb|:-| B) \in M$ renamed apart
   \item $\sigma_{k+1}$ is the mgu of $A$ and $H$
   \item $G_{k+1} = (G_k \setminus \{A\} \cup B)\sigma_{k+1}$
\end{itemize}

Since $(H \verb|:-| B)$ is a clause in $M$ and $\sigma_{k+1}$ unifies $A$ with $H$, we know that:
\begin{itemize}
   \item The instance $(H \verb|:-| B)\sigma_{k+1}$ is a logical consequence of $M$ (by instantiation of a program clause)
   \item Since $A\sigma_{k+1} = H\sigma_{k+1}$ (by the mgu property), we can replace $A$ with $B$ under substitution $\sigma_{k+1}$
   \item Therefore, the implication $(G_k \verb|:-| G_{k+1})$ is a logical consequence of $M$ when we consider that $G_{k+1}$ was obtained by replacing $A$ in $G_k$ with $B$ and applying $\sigma_{k+1}$
\end{itemize}

By the transitivity of logical consequence, if $(G_0 \verb|:-| G_k)\sigma'$ is a logical consequence of $M$ and $(G_k \verb|:-| G_{k+1})$ follows from $M$ under the additional substitution $\sigma_{k+1}$, then $(G_0 \verb|:-| G_{k+1})(\sigma' \circ \sigma_{k+1})$ is a logical consequence of $M$.

Since $\sigma = \sigma' \circ \sigma_{k+1} = \sigma_1 \circ \cdots \circ \sigma_{k+1}$, we conclude that the outcome $(G_0 \verb|:-| G_{k+1})\sigma$ is a logical consequence of $M$.
\qed\end{proof}

Next we extend the transition system of Logic Programs to define the operational semantics of Grassroots Logic Programs.


\subsection{GLP Operational Semantics}

We now extend Logic Programs to Grassroots Logic Programs by introducing reader/writer variable pairs. This section presents a standard interleaving semantics commonly used for defining the operational semantics of concurrent programming languages, where concurrent processes are modelled as nondeterministic interleaving of atomic computational steps. While this captures concurrency adequately for sequential and parallel execution, it cannot address the essential requirements of distributed systems where safety, liveness, and privacy properties in the face of potentially-faulty agents must be formally established.

To do so requires a model where agents are first-class entities with explicit identities, boundaries, means of communication, and failure modes.  The multiagent semantics in subsequent sections addresses this requirement by making agents explicit entities with cryptographic identities, separate state spaces, and controlled communication through shared variables. This provides the formal foundation necessary for proving that GLP maintains safety invariants across agents, ensures liveness under fair scheduling, and preserves privacy through controlled variable sharing. We defer these proofs to Section~\ref{section:GLP-safety}, establishing them directly for the multiagent case.


First we extend the standard notion of unification to Grassroots Logic Programs. While standard unification may succeed or fail, grassroots unification may also suspend, in case a reader (`future') may receive in the future a value `from the outside' (via another process instantiating the paired writer, or `promise'). It succeeds if the two terms can be unified via an mgu $\sigma$ that instantiates only writers, upon which $\sigma$ is extended so that if it instantiates a writer $X$, it also instantiates its paired reader $X?$ with the same value $X\sigma$.


\begin{definition}[Writer and Reader Substitution, Reader Counterpart, Unification Result]\label{definition:glp-unification}
A substitution $\sigma$ is a \temph{writer} if $V_\sigma \subset V$ and if $X\ne X\sigma$ then $X\sigma\notin V$, a \temph{reader}
if for every $X\in V$, either $X\sigma = X?\sigma$ or $X\sigma=X$ and $X?\sigma=X?$.
Given a writer substitution $\sigma$, its \temph{reader counterpart} $\sigma?$ exists if $X?$ does not occur in $X\sigma$ for any $X \in V_\sigma$, and if so it is the reader substitution satisfying, for every $X \in V$, $X\sigma?= X?\sigma? = X\sigma$.
%
The \temph{unification} of two terms:
\begin{enumerate}
    \item \temph{succeeds} if they have a writer mgu $\sigma$ and a reader counterpart $\sigma?$, upon which the outcome is $\sigma?$,
    \item \temph{fails} if they are not unifiable, or if the writer mgu exists but its reader counterpart does not exist,
    \item \temph{suspends} otherwise.
\end{enumerate}
\end{definition}

\begin{remark}
The constraint that $X\sigma \notin V$ when $X \neq X\sigma$ prohibits writer-to-writer bindings. By the single-writer restriction, in such a case $X$ and $X\sigma$ are the only occurrences of these two writers, and hence such unification would leave their two paired readers \emph{abandoned}, namely without a writer that can provide them with a value. 
The restriction prevents other goals from suspending indefinitely on the abandoned readers.
\end{remark}

The occurs check condition for the reader counterpart ensures that no writer is bound to a term containing its paired reader, preventing the formation of circular terms, as proven in Proposition~\ref{proposition:acyclicity-preservation}.

Note that suspension occurs when the terms are unifiable, but only by an mgu $\sigma$ for which $V_\sigma \not\subset V$, namely their unification requires writing on readers.
Also note that the empty/identity substitution is both a writer and a reader substitution, and is the only one such.

\begin{definition}[GLP Renaming]\label{definition:gs-renaming}
Two GLP terms $T, T'$ have a variable in common if for some writer $X$, $X$ or $X?$ occur in $T$ and  $X$ or $X?$ occur in $T'$.
A \temph{GLP renaming} is a renaming substitution $\sigma: \calV \mapsto \calV$ that respects variable types and pairing, namely for each $X\in \calV$, $X\sigma = X\sigma$ and $X?\sigma=X\sigma?$.
A GLP renaming of $\sigma$ renames $T'$ \temph{apart from} $T$ if $T$ and $T'\sigma$ have no variable in common.
\end{definition}


\begin{definition}[GLP Goal/Clause Reduction]\label{definition:goal-clause-reduction}
 Given GLP goal $A$ and clause $C$,  with $H \verb|:-| B$ being the result of renaming $C$ apart from $A$,
 the \temph{GLP reduction} of $A$ with $C$ \temph{succeeds with result} $(B,\sigma?)$ if $A$ and $H$ have writer mgu $\sigma$; \temph{suspends} if $A$ has a reader-instance $A'$ for which the GLP reduction of $A'$ with $C$ succeeds; else \temph{fails}.
\end{definition}

The following transition system defines the operational semantics of GLP. 
\begin{definition}[GLP Transition System]\label{definition:glp-ts}
Given a GLP program $M$ and initial goal $G_0$, the \temph{GLP transition system} is $GLP = (S, s_0, T)$ where:
\begin{itemize}
    \item $S$ is the set of all GLP goals.
    \item $s_0 = G_0$ 
    \item $G \rightarrow G' \in T$ if there exists an atom $A \in G$ and $C\in P$ is the first clause in $P$ for which the GLP reduction of $A$ with $C$ succeeds, with result $(B,\sigma?)$,  in which case $G' = (G \setminus \{A\} \cup B)\sigma?$
\end{itemize}
\end{definition}
The operational semantics of GLP is very similar to that of LP, with two differences.  In GLP:
\begin{enumerate}
    \item  The first applicable clause is chosen for reduction, not nondeterministically as in LP; this restriction facilitates writing fair concurrent programs, such as fair merge (Program~\ref{program:fair-merge}). 
    \item A writer mgu is used, hence a GLP goal/clause reduction may also suspend, not only succeed or fail as in LP, and the result upon success includes the reader counterpart of then writer mgu.
\end{enumerate}


\subsection{Fairness and Liveness in GLP}


Since writers cannot be externally modified, once a goal can be reduced with a clause it remains reducible regardless of other agents' actions—only becoming more instantiated as its readers receive values. 


\begin{definition}[Reader-Instance]
A goal $A'$ is a \temph{reader-instance} of goal $A$ if there exists a substitution $\sigma$ such that $A' = A\sigma$ and for any writer $X\in A$, $X\sigma=X$.
\end{definition}

Note that the single-writer invariant ensures that if, during a run, a goal $A$ that is not reduced is instantiated to $A'$, then $A'$ is a reader-instance of $A$.

The following monotonicity property exposes perhaps the core difference between LP and GLP:
An LP reduction of a less-instantiated goal $A$ with clause $C$ that succeeds now may fail later when $A$ becomes more instantiated by other goal reductions, resulting in $A$ no longer unifying with the head of $C$.
A GLP reduction of a goal $A$ with clause $C$ that succeeds now will always succeed in the future, no matter what other goal reductions occur.   Due to the single-writer invariant, any subsequent instance $A'$ of $A$ must be a reader-instance of $A$, and we argue next that this is a sufficient condition for this monotonicity property to hold.


\begin{proposition}[GLP Goal/Clause Reduction Monotonicity]
Given GLP goal $A$ and clause $C$, if $A$ can be reduced with $C$ than any reader-instance $A'$ of $A$ can be reduced with $C$.
\end{proposition}
\begin{proof}
Let $C = H \verb|:-| B$ be the clause renamed apart from $A$. By assumption, the GLP reduction of $A$ with $C$ succeeds, which means $A$ and $H$ have a writer mgu $\sigma$ with reader counterpart $\sigma?$.

Let $A'$ be a reader-instance of $A$. By definition, there exists a substitution $\rho$ such that $A' = A\rho$ where for any writer $X \in A$, we have $X\rho = X$.

We need to show that $A'$ can be reduced with $C$ (renamed apart from $A'$).

Since $\sigma$ is a writer mgu of $A$ and $H$, we have $A\sigma = H\sigma$. 

Now consider $A' = A\rho$. We claim that $\sigma$ is also a writer mgu of $A'$ and $H$:
\begin{itemize}
    \item Since $\rho$ preserves all writers in $A$, for any writer $X$ in $A$: $X\rho = X$
    \item Therefore $A'\sigma = (A\rho)\sigma = A(\rho \circ \sigma)$
    \item Since $\sigma$ only instantiates writers and $\rho$ preserves writers in $A$, we have $A'\sigma = A\sigma = H\sigma$
    \item Thus $\sigma$ unifies $A'$ and $H$
    \item $\sigma$ remains most general among writer substitutions since the writer variables in $A'$ are identical to those in $A$
\end{itemize}

Since $\sigma$ is a writer mgu for $A'$ and $H$, and the reader counterpart $\sigma?$ still exists (as the occurs check condition is unchanged), the GLP reduction of $A'$ with $C$ succeeds.

Therefore, any reader-instance of a reducible goal remains reducible with the same clause.
\qed\end{proof}

This monotonicity property allows to pose a simple fairness requirement for GLP in terms of goal reduction:

\begin{definition}[Fair Single-Agent GLP Execution]\label{definition:fair-glp}
An infinite run of GLP is \temph{fair} if any goal in a configuration of a run that can be reduced is eventually reduced.
\end{definition}
%Note that due to the SRSW invariant the variables of a non-ground goal that occurs in a run endow it with a unique identity retained throughout the run, until if ever it becomes ground.


This definition captures fairness at the goal/process level, ensuring that enabled computations eventually proceed. In the multiagent setting (Section~\ref{section:fairness-multiagent}), we extent the fairness requirement to agents, so that each agent with enabled goals eventually gets to execute transitions.

\section{GLP as a Multiagent Programming Language}\label{section:GLP-multiagent}

Here we extend the single-agent concurrent semantics to the multiagent setting.



\subsection{Multiagent Transition Systems and Atomic Transactions}~\label{subsection:multiagent-glp-mts}



%A configuration $c$ is \emph{reachable} if there exists a finite run from $c_0$ to $c$.


We specify GLP as a multiagent transition system~\cite{shapiro2021multiagent},  defined through atomic transactions involving multiple agents~\cite{shapiro2025atomic}.
This framework provides a mathematical foundation for multiagent distributed systems and an established path for proving that such a system is grassroots~\cite{shapiro2023grassrootsBA}.  
Here we recall the essential concepts: multiagent transition systems, atomic transactions, protocols, and the conditions under which such systems are grassroots. Full mathematical background is available in reference~\cite{shapiro2025atomic}.

We assume a potentially infinite set of \emph{agents} $\Pi$ (think of all the agents that are yet to be born), each with a self-chosen key pair, unique whp, and identify each agent $p\in \Pi$ with its public key $p$.  We consider only finite subsets of $\Pi$,  so when we refer to a particular set of agents $P \subset \Pi$ we assume $P$ to be nonempty and finite.  We use $\subset$ to denote the strict subset relation and $\subseteq$ when equality is also possible, and $a\ne b \in X$ to denote $a\ne b \wedge a \in X \wedge b\in X$.

In the context of multiagent systems it is common to refer to the state of the system  as \emph{configuration}, so as not to confuse it with the \emph{local states} of the agents.
As standard, we use $S^P$ to denote the set $S$ indexed by the set $P$, and if $c\in S^P$ we use $c_p$ to denote the member of $c$ indexed by $p\in P$.  Intuitively, think of such a $c\in S^P$ as an array indexed by the members of $P$ with values in $S$.

%Specifically, given an arbitrary set $S$ of \emph{local states} with  an initial state $s0\in S$, then $S^P$ is the set of \emph{configurations} over $P$ and $S$ and $\{s0\}^P$ is the \emph{initial configuration}. Namely, each configuration $c \in C$ consists of a set of local states in $S$ indexed by $P$, in which case $c_p$ denotes the local state in $S$ of $p \in P$ in configuration $c \in C$, and in the initial configuration the local state of each agent is $s0$. 

\begin{definition}[Local States, Configuration, Transitions, Active \& Stationary Participants, Degree]
Given agents $P \subset \Pi$ and an arbitrary set $S$ of \temph{local states} with a designated \temph{initial local state} $s0\in S$, a \temph{configuration} over $P$ and $S$ is a member of $C:= S^P$ and the \temph{initial configuration} is $c0:= \{s0\}^P$.  A \temph{multiagent transition} over $P$ and $S$ is any pair of configurations $t=c\rightarrow c' \in C^2$ s.t. $c\ne c'$, with $t_p := c_p \rightarrow c'_p$ for any $p\in P$, and with $p$ being an \temph{active} in $t$ if $c_p\ne c'_p$, \temph{stationary participant} otherwise.  The \temph{degree} of $t$ (unary, binary,\ldots $k$-ary)
%\temph{active participants} $\alpha(t) := \{ p\in P :  t_p \text{ is not silent}\}$   (unary, binary, etc.)  
is the number of active participants in $t$.
A unary transition with active participant $p$ is a \temph{$p$-transition}, and the degree of a set of transitions is the maximal degree of any of its members.
%Such a transaction is a \temph{unary $p$-transition} if $c_p\ne c'_p$ and $c_q=c'_q$ for every $q\ne p \in P$.
\end{definition}
The condition $c \neq c'$ on a transition ensures at least one agent changed it states. 
%Agents are \emph{active} if their local state changes, \emph{stationary} if they participate but remain unchanged.


\begin{definition}[Multiagent Transition System]\label{definition:dts-cd}
Given agents $P \subset \Pi$ and an arbitrary set $S$ of local states with a designated initial local state $s0\in S$, 
a \temph{multiagent transition system} over $P$ and $S$ is a transition system $TS= (C,c0,T)$ with $C:= S^P$,  $c0:= \{s0\}^P$, and $T\subseteq C^2$ being a set of multiagent transitions over $P$ and $S$.
\end{definition}

Unary multiagent transition systems were introduced in~\cite{shapiro2021multiagent} and were employed to define the notion of grassroots protocols~\cite{shapiro2023grassrootsBA} and to provide unary specifications for various grassroots platforms~\cite{shapiro2023gsn,shapiro2024gc,lewis2023grassroots}.
Here, we employ $k$-ary transition systems, for any $k\le |P|$, in which several agents can change their state simultaneously.
Rather than specifying transition systems directly, we specify them via atomic transactions~\cite{lynch1988theory} that define which agents participate and how their states change atomically.

Informally, an atomic transaction:
\begin{enumerate}
    \item Can have several active participants (be binary, $k$-ary) that change their local states atomically as specified. 
    \item Specifies explicitly its participants (both active and stationary),  thus implicitly defining infinitely-many multiagent transitions where all non-participants remain in their arbitrary state.
\end{enumerate}
In addition to being atomic, the description above implies that transactions are asynchronous~\cite{shapiro2021multiagent}, in the sense that if a transaction can be carried out by its participants, with non-participants being in arbitrary states, it can still be carried out no matter what the non-participants do. In particular, the active participants in a transaction need not synchronize its execution with any non-participant (but they must synchronize, of course, with stationary participants, as changing the local state of any participant would disable the transaction).  Informally, a transaction is but a multiagent transition over its participants, which defines a potentially-infinite set of multiagent transitions over any larger set of agents.

This informal description is made precise by the formal framework described in~\cite{shapiro2025atomic}.  It shows how  a multiagent transition system over $S$ and $P$ is fully specified by providing a set of atomic transactions over $S$, each with participants $Q\subseteq P$. This formal treatment was carried out in~\cite{shapiro2025atomic} for grassroots social networks, grassroots cryptocurrencies, and grassroots federations. Here we follow the same mathematical path in defining the multiagent operational semantics of Grassroots Logic Programs.

Next, we define the local state function for GLP, define GLP via transactions, prove safety properties of GLP, that GLP computations are deduction, and that the resulting GLP protocol it is grassroots.




\subsection{Defining GLP via Agent States and Transactions}

We now apply the atomic transactions framework to specify the full multiagent GLP. 


\mypara{GLP-specific definitions} 
The multiagent semantics uses the GLP-specific definitions from the single-agent case:
\begin{itemize}
\item Writer and reader substitutions, reader counterpart, and unification (Definition~\ref{definition:glp-unification})
\item GLP renaming that respects variable pairing (Definition~\ref{definition:gs-renaming})
\item Goal/clause reduction with writer mgu (Definition~\ref{definition:goal-clause-reduction})
\end{itemize}
These definitions apply unchanged in the multiagent setting, where each agent owns variables in their namespace $\mathcal{V}_p$.


\mypara{Agent Identity and Attestation}
Attestations serve several purposes in GLP: They authenticate agents during initial contact (via the Offer transaction) and introduction via a mutual friend (via the Attest transaction), as well as enable ongoing verification of program compatibility between established peers (via the Attest transaction). The signature $Sig_p$ cryptographically binds the agent's identity to their current program module, while the fresh writer $W$ establishes a new communication channel for the recipient's response.


\begin{definition}[Attestation]\label{definition:attestation-term}
An \temph{attestation} by agent $p$ is the act of creating a term of the form
$\verb|attestation|(p, Sig_p, W)$, where
 $Sig_p$ is a signature by $p$ of the (cryptographic hash of the) program module executed by $p$ and $W\in \mathcal{V}_p$ is a fresh writer.
\end{definition}
%
A system predicate \verb|attestation| enables verification of attestations and extraction of their components, allowing agents to ensure they communicate only with authenticated peers running compatible programs.

\mypara{Bootstrapping the social graph}
Agents initially have no shared variables and must establish communication channels without central authorities, the hallmark of being grassroots. While the preferred method is introduction by mutual friends, initial cold-call contact between agents is necessary to bootstrap the social graph and connect hitherto disconnected components. Each agent $p$ maintains an offers stream writer $Os_p$ shared with distinguished pseudo-agent $o \notin \Pi$. 


The \textbf{Offer} transaction enables authenticated cold-call communication: agent $p$ may `cold-call' any agent $q\in \Pi$ by sending an attestation containing a local writer $X$ to $q$'s offers stream, allowing $q$ to verify $p$'s identity and program compatibility before agreeing to communicate via the shared logic variable $X$ received.   Acceptance of an offer creates the first shared logic variable pair between previously unconnected agents, enabling them to subsequently communicate as well as introduce each other to their respective friends via friend-mediated introduction, avoiding the more complex cold-call mechanism.


\mypara{Agent-to-Agent Communication} The key extension of multiagent GLP compared to the single-agent operational semantics is that variable bindings can propagate across agents when shared variables are instantiated. In the multiagent setting, each agent $p\in \Pi$ \emph{owns} the variables in their namespace $\mathcal{V}_p$. 

Ownership of variables can transfer between agents as a result of shared-variable binding. When agent $p$ reduces a goal and binds writer $X$ to term $T$, the agent $q$ holding the paired reader $X?$ must receive this binding. This results in binding $X := T$ communicated from $p$ to $q$, and if $T$ itself contains variables, their ownership is transferred as well from $p$ to $q$.  In particular, if $Y$ is a shared variable in $T$  then its ownership is simply transferred from $p$ to $p$, and if $Y$ is a local variable in $T$, then in addition $Y$ becomes a new shared variable, with $p$ retaining its paired variable $Y'$.  

Additionally, agents must be able to establish new communication channels and verify each other's authenticity. Since grassroots systems do not rely on central coordination, decentralised mechanisms for initial contact and ongoing peer verification are needed. In the atomic transactions framework established above, these requirements are addressed through three specific transactions for GLP, which we define below.

\mypara{GLP states} The following definition establishes the state function $S(P)$ required by the notion of a protocol, mapping each set of agents $P\subset \Pi$ to the corresponding set of possible local states.

\begin{definition}[Agent Local State]\label{definition:agent-state}
Let $o\notin\Pi$ be a distinguished agent.
Given a set of agents $P\subset \Pi$, for each agent $p \in P$ let $\mathcal{V}_p$ denote p's variable namespace, with $\mathcal{V}_p \cap \mathcal{V}_q = \emptyset$ for $p \neq q$.
The GLP set of local states $S(P)$ consists of all pairs $(G_p,Shared_p)$ for every agent $p\in P$ such that:
\begin{itemize}
    \item \textbf{Resolvent:} $G_p \subseteq \calG$ is a set of goals.
    \item \textbf{Shared variables:} $Shared_p \subseteq \calV \times (P\cup\{o\})$.
\end{itemize}
The \temph{initial state} of each agent $p\in P$ is $s_0 = (\{\verb|boot|(\verb|In|_p?, \verb|Out|_p, \verb|Os|_p?)\}, \{(\verb|Os|_p,o)\})$ where $\verb|In|_p, \verb|Out|_p, \verb|Os|_p \in \mathcal{V}_p$.
\end{definition}
We assume a fixed boot program module $M$ that includes a definition of the \verb|boot| predicate, with which agent execution commences. Example code for $M$ is shown in Section~\ref{section:examples}.

A pair $(X,q) \in Shared_p$ indicates that variable $X$ is shared with agent $q$, meaning that $q$ holds the variable $X'$ paired to $X$.  It is a consistency requirement on configurations over $P$ that  $(X,q) \in Shared_p$ iff $(X',p) \in Shared_q$ for any variables pair $(X,X')$ and any $p,q\in P$.


\mypara{GLP transactions} We recall (Section~\ref{subsection:multiagent-glp-mts}) that given $P\subset\Pi$ and local states $S(P)$, a set of transactions over $P$ and $S(P)$ induces a multiagent transition system with configurations $C(P)= S(P)^P$ and transitions $T(P) \subseteq C\times C$.

GLP includes reserved \emph{system predicates}, presented in Section~\ref{section:glp-guards}, which cannot occur as defined procedures in a GLP program module.  They include $\verb|attest|$ and $\verb|offer|$ 


\begin{definition}[GLP Transactions and Multiagent Transition System]\label{definition:multiagent-transactions}
Given a grassroots logic program $M$ and agents $P \subseteq \Pi$, a \temph{grassroots logic programs transition system} over $P$, $GLP(P)$, is the multiagent transition system over $P$ and $S(P)$ induced by all transactions $c \rightarrow c'$ over $Q\subset P$ with $c_p= (G_p,Shared_p)$ and $c'_p= (G'_p, Shared'_p)$ for every $p\in Q$, as follows:

Let  $A$ be a goal in $G_p$ for which one of the following rules apply:
\begin{enumerate}
    \item \textbf{Reduce \& Communicate:} For some $p\in Q$:
    \begin{itemize}
        \item \textbf{Reduce:} Let $C$ be the first clause in $M$,  renamed apart from $A$, for which the reduction of $A$ with $C$ succeeds with result $(B,\sigma?)$, if there is one. Then
        $G'_p = (G_p \setminus \{A\} \cup B)\sigma?$.
        \item \textbf{Identify communicating agents:} $Q = \{p\} \cup \{q \mid \exists X \in V_\sigma : (X, q) \in Shared_p\}$, let $G'_q = G_q$ for every $q\ne p\in Q$ and  $Shared'_q = Shared_q$ for every $q\in Q$.
         \item  \textbf{Communicate:} For each $X \in V_\sigma$ such that $(X, q) \in Shared_p$:
         \begin{itemize}
             \item apply $G'_q := G'_q\{X' \mapsto X\sigma?\}$ and remove $(X, q)$ from $Shared'_p$, and
             \item for every variable $Y \in \calV$ occurring in $X\sigma?$:
            \begin{itemize}
                \item If $Y$ is local to $p$: add $(Y, q)$ to $Shared'_p$ and $(Y', p)$ to $Shared'_q$.
                \item If $(Y, r) \in Shared_p$: remove $(Y, r)$ from $Shared'_p$, add $(Y, r)$ to $Shared'_q$, and update $(Y', p)$ to $(Y', q)$ in $Shared'_r$.
            \end{itemize}
        \end{itemize}
     \end{itemize}
     \item \textbf{Offer:} $A=\verb|offer|(q,X)$,  $Q=\{p,q\}$ with $X$ a local writer and $(Os,o)\in Shared_q$:
    \begin{itemize}
        \item \textbf{Create attestation:} Let $Att = \verb|attestation|(p, Sig_p, X)$ as in Definition~\ref{definition:attestation-term}.
        \item \textbf{Reduce in $p$:} $G'_p = G_p \setminus \{\verb|offer|(q,X)\}$ and $Shared'_p := Shared_p \cup \{(X,q)\}$.
        \item \textbf{Input in $q$:} $G'_q = G_q \{Os? \mapsto [Att|Os'?]\}$ with $(Os',Os'?)$ a fresh pair in $\calV_q$.
        \item \textbf{Update $q$'s shared variables}: 
            $Shared'_q = Shared_q \cup \{(X?, p), (Os',\bot)\} \setminus \{(Os,o)\}$.
    \end{itemize}
    \item \textbf{Attest:} $A=\verb|attest|(q,X)$, $Q=\{p,q\}$, with $X$ a writer such that $(X,q) \in Shared_p$ and $(X?,p) \in Shared_q$:
    \begin{itemize}
        \item \textbf{Create attestation:} Let $Att = \verb|attestation|(p, Sig_p, Response)$ where $Response$ is a fresh writer from $\calV_p$
        \item \textbf{Reduce in $p$:} $G'_p = G_p \setminus \{\verb|attest|(q,X)\}$ and $Shared'_p = (Shared_p \setminus \{(X,q)\}) \cup \{(Response,q)\}$
        \item \textbf{Communicate to $q$:} $G'_q = G_q\{X? \mapsto Att\}$ and $Shared'_q = (Shared_q \setminus \{(X?,p)\}) \cup \{(Response?,p)\}$
    \end{itemize}
    %\item \textbf{Fail:} If none of the transitions above apply to any reader-instance of $A$ then  let $G'_p = (G_p \setminus \{A\} \cup \{\textsc{false})\}$
\end{enumerate}
\end{definition}
%
The \textbf{Offer} transaction creates authenticated first contact by including an attestation, while the \textbf{Attest} transaction enables peers with existing connections to reverify each other's identity and program compatibility, establishing a fresh communication channel for continued interaction. Together, these transactions ensure that all communication in the social graph occurs between authenticated agents running compatible programs.  

%The \textbf{Fail} transaction is of practical importance:  it helps distinguish between a suspended goal that may be reduced in the future and a terminally-failed goal that no future scenario may salvage.  Failure is much easier to diagnose and correct than deadlock or indefinite suspension, and may provide early indication that the program is faulty.  Logically, \textsc{false} is a goal that implies nothing; operationally, it is a goal that cannot be reduced and its presence in the resolvent is an indication that (\ia)  the computation cannot produce a correct result and hence should be aborted and (\ib) the program that generated the computation is faulty and should be diagnosed.


%We refer to \verb|offer| and  \verb|attest| as \emph{systems predicates} and to $\verb|offer|(q,X)$ and $\verb|attest|(q,X)$ as \emph{systems goals}.

\section{GLP Safety, Fairness, and Liveness}\label{section:safety-fairness-liveness} 

\subsection{GLP Safety}\label{section:GLP-safety}

We establish three essential safety properties that ensure GLP's correctness as a distributed logic programming language. These properties form a logical sequence: symmetric sharing ensures consistency of variable ownership across agents, the single reader/writer invariant prevents variable duplication, and acyclicity preservation guarantees well-formed terms.

\mypara{GLP shared variables are always paired} The following lemma shows that the operational semantics maintains the consistency requirement on shared variables in a configuration.

\begin{proposition}[Symmetric Sharing Invariant]\label{proposition:symmetric-sharing-invariant}
$(X,q) \in Shared_p$ if and only if $(X',p) \in Shared_q$ for every variable pair $(X,X')$,  $p,q\in P\subset \Pi$, and configuration $c$ of a run of $GLP(P)$.
\end{proposition}
\begin{proof}
By induction on run length.

\mypara{Base case} In the initial configuration $c_0$, each agent $p$ has $Shared_p = \{(Os_p, o)\}$ where $o$ is the distinguished pseudo-agent. Since $o \notin P$, the property holds vacuously for agent pairs in $P$.

\mypara{Inductive step} Assume the property holds for configuration $c$ and consider a transition $c \rightarrow c'$. We verify that the symmetric sharing property is preserved:

\begin{enumerate}
    \item \textbf{Reduce \& Communicate:} When agent $p$ reduces and communicates with agents $Q = \{p\} \cup \{q \mid \exists X \in \mathcal{V}_\sigma : (X, q) \in Shared_p\}$:
    
    For each $X \in \mathcal{V}_\sigma$ such that $(X, q) \in Shared_p$, the transaction performs:
    \begin{itemize}
        \item Removes $(X, q)$ from $Shared'_p$ and applies $G'_q := G'_q\{X' \mapsto X\sigma?\}$
        \item For every variable $Y \in \mathcal{V}$ occurring in $X\sigma?$:
        \begin{itemize}
            \item If $Y$ is local to $p$: adds $(Y, q)$ to $Shared'_p$ and $(Y', p)$ to $Shared'_q$
            \item If $(Y, r) \in Shared_p$: removes $(Y, r)$ from $Shared'_p$, adds $(Y, r)$ to $Shared'_q$, and updates $(Y', p)$ to $(Y', q)$ in $Shared'_r$
        \end{itemize}
    \end{itemize}
    
    We verify symmetry is preserved in each case:
    \begin{itemize}
        \item \textbf{Local variable case:} Adding $(Y, q)$ to $Shared'_p$ and $(Y', p)$ to $Shared'_q$ creates a new symmetric pair by construction.
        \item \textbf{Shared variable transfer:} If $(Y, r) \in Shared_p$, then by the inductive hypothesis $(Y', p) \in Shared_r$. The transaction removes $(Y, r)$ from $Shared'_p$, adds $(Y, r)$ to $Shared'_q$, and updates $(Y', p)$ to $(Y', q)$ in $Shared'_r$. This transforms the symmetric relationship $(Y, r) \in Shared_p \Leftrightarrow (Y', p) \in Shared_r$ into $(Y, r) \in Shared'_q \Leftrightarrow (Y', q) \in Shared'_r$, preserving symmetry.
    \end{itemize}
    
    \item \textbf{Offer:} When agent $p$ offers friendship to agent $q$:
    \begin{itemize}
        \item Creates fresh variable pair $(X, X?)$ 
        \item Adds $(X, q)$ to $Shared'_p$ and $(X?, p)$ to $Shared'_q$
        \item This establishes the symmetric relationship $(X, q) \in Shared'_p \Leftrightarrow (X?, p) \in Shared'_q$ by construction
    \end{itemize}
\end{enumerate}

In all cases, the symmetric sharing invariant is preserved: $(X, q) \in Shared'_p \Leftrightarrow (X', p) \in Shared'_q$ for any variable pair $(X, X')$.
\qed\end{proof}


\mypara{GLP maintains the single-reader/single-writer invariant} 

\begin{definition}[Joint Resolvent]
Given a configuration $c\in C(P)$, we define the \emph{joint resolvent of $c$}, $G(c) := \bigcup_{p\in P} G_p$, to be the union of all agent resolvents in configuration $c$.
\end{definition}

\begin{proposition}[Single Reader/Writer Invariant]\label{proposition:single-reader-writer-invariant}
$G(c)$ satisfies the single-reader/single-writer constraint for any configuration $c$ of any run of $GLP(P)$, $P\subset \Pi$. 
\end{proposition}
\begin{proof}
By induction on run length.

\mypara{Base case} In the initial configuration $c_0$, $G(c_0) = \bigcup_{p\in P} \{\verb|boot|(\verb|In|_p?, \verb|Out|_p, \verb|Os|_p?)\}$ where agents have disjoint variable sets. Therefore each variable occurs exactly once in $G(c_0)$, satisfying the constraint.

\mypara{Inductive step} Assume $G(c)$ satisfies the constraint and consider transition $c \rightarrow c'$. We show $G(c')$ preserves the constraint:

\begin{enumerate}
    \item \textbf{Reduce \& Communicate:} When agent $p$ reduces using clause $A \verb|:-| B$ with writer mgu $\sigma$ and reader counterpart $\sigma?$:
    \begin{itemize}
        \item \textbf{Clause renaming:} Creates fresh variables distinct from all existing variables by construction, maintaining uniqueness.
        \item \textbf{Substitution application:} The reduction $G'_p = (G_p \setminus \{H\} \cup B)\sigma?$ applies substitution $\sigma?$ which replaces variables with terms. If writer $X$ is instantiated to term $T$ by $\sigma$, then all occurrences of $X$ are replaced by $T$, eliminating $X$ from the configuration. No new variable occurrences are created.
        \item \textbf{Communication:} For each $X \in \mathcal{V}_\sigma$ with $(X, q) \in Shared_p$, the transaction applies $G'_q := G'_q\{X' \mapsto X\sigma?\}$. Since the constraint ensures exactly one occurrence of reader $X'$ exists (in agent $q$), this substitution replaces that single occurrence with value $X\sigma?$, eliminating $X'$ from $G(c')$ without creating duplicates.
        \item \textbf{Variable ownership transfers:} When variables $Y$ occurring in $X\sigma?$ are transferred between agents via updates to $Shared$ sets, the variables themselves are not duplicated—only their ownership records are moved between agents.
    \end{itemize}
    
    \item \textbf{Offer:} When agent $p$ offers friendship to agent $q$:
    \begin{itemize}
        \item \textbf{Fresh variable creation:} Creates fresh variable pair $(Os', Os'?)$ distinct from all existing variables by construction.
        \item \textbf{Substitution preservation:} The substitution $G'_q = G_q\{Os? \mapsto [\verb|offer|(p,X)|Os'?]\}$ replaces the single occurrence of reader $Os?$ with a structured term containing existing variables $p$ and $X$, plus the fresh reader $Os'?$. Since $Os'?$ is fresh and $(p,X)$ maintain their single occurrences, no duplications occur.
        \item \textbf{Goal movement:} Removing $\verb|offer|(q,X)$ from $G_p$ eliminates one occurrence; the structured term containing $X$ added to $G'_q$ preserves $X$'s single occurrence property.
    \end{itemize}
\end{enumerate}

In both transactions, variables are either eliminated through substitution, transferred between agents without duplication, or created fresh with unique identities. Therefore $G(c')$ satisfies the single-reader/single-writer constraint.
\qed\end{proof}


\mypara{GLP does not produce circular terms} The single reader/writer property established above is key to preventing circular terms, as shown by the following characterization.

\begin{lemma}[Circular Terms Characterization]\label{lemma:circular-terms}
In GLP with the single-writer property, a term $T$ is circular if and only if there exists a writer $X$ such that $X$ is bound to a term containing the paired reader $X?$.
\end{lemma}
\begin{proof}
The single-writer property ensures each variable has exactly one writer occurrence. A circular dependency requires a variable to transitively depend on itself. Since writers are single-assignment and readers are paired with unique writers, the only cycle formation mechanism is a direct binding $X := T$ where $X? \in T$.
\qed\end{proof}

\begin{proposition}[Acyclicity Preservation]\label{proposition:acyclicity-preservation}
Given $P\subset \Pi$, for any configuration $c$ of any run of $GLP(P)$,  $G(c)$ contains no circular terms.
\end{proposition}
\begin{proof}
By induction on run length.

\mypara{Base case} In the initial configuration $c_0$, $G(c_0) = \bigcup_{p\in P} \{\verb|boot|(\verb|In|_p?, \verb|Out|_p, \verb|Os|_p?)\}$ contains only fresh local variables with disjoint variable sets, which are acyclic.

\mypara{Inductive step} Assume $G(c)$ contains no circular terms and consider transition $c \rightarrow c'$. By Lemma~\ref{lemma:circular-terms}, we need only show that no writer $X$ is ever bound to a term containing its paired reader $X?$:

\begin{enumerate}
    \item \textbf{Reduce \& Communicate:} When agent $p$ applies clause $A \verb|:-| B$ with writer mgu $\sigma$ and reader counterpart $\sigma?$:
    \begin{itemize}
        \item The writer mgu $\sigma$ satisfies the occurs check: for every $X \in \mathcal{V}_\sigma$, $X? \notin X\sigma$
        \item This directly prevents binding any writer to a term containing its paired reader
        \item The reduction and communication preserve acyclicity: terms $X\sigma?$ added to $G(c')$ are acyclic by the occurs check constraint
    \end{itemize}
    
    \item \textbf{Offer:} When agent $p$ offers friendship to agent $q$:
    \begin{itemize}
        \item Creates fresh variable pair $(Os', Os'?)$ with no existing dependencies
        \item The structured term $[\verb|offer|(p,X)|Os'?]$ added to $G(c')$ contains only existing acyclic variables and the fresh $Os'?$
        \item No writers are bound to terms containing their paired readers
    \end{itemize}
\end{enumerate}

In both transactions, the occurs check constraint and fresh variable creation prevent circular term formation. Therefore $G(c')$ contains no circular terms.
\qed\end{proof}



\remove{
An \emph{utterance} in GLP has the form $(X:=T)_p$. It records the speech act~\cite{searle1969speech} by which agent $p\in \Pi$ binds writer $X\in V$ with term $T$, and specifies the result of this act: The string resulting from agent $p$ cryptographically-signing the assignment $X:=T$ with its private key. Every transaction produces a set of utterances: In case of \textbf{Reduce \& Communicate} by agent $p$, it is the bindings $X:=T$ of the variables $X$ in $\mathcal{V}_\sigma$ that are shared with other agents, signed by $p$ as $(X:=T)_p$. An \textbf{Offer} transaction by $p$ to $q$ adds a pair of variables to the $Shared$ sets of $p$ and $q$, but does not create an utterance.
}



\subsection{GLP Fairness and Liveness}\label{section:fairness-multiagent}

The single-agent fairness definition (Definition~\ref{definition:fair-glp}) ensures that enabled goals are eventually reduced. In the multiagent setting, we must additionally specify which agents execute these reductions, preventing any agent from being permanently starved.

\begin{definition}[Fair Multiagent GLP Execution]\label{definition:fair-multiagent-glp}
A run of multiagent GLP is \temph{fair} if whenever agent $p$ can reduce a goal $A$ in some configuration of an infinite run, then eventually agent $p$ reduces some reader-instance of $A$.
\end{definition}

This definition ensures both that computations progress (inherited from single-agent fairness) and that no agent is permanently prevented from executing its enabled goals. The monotonicity property established in Section~\ref{section:fairness} is crucial here: once an agent can reduce a goal, it remains reducible despite other agents' actions—only becoming more instantiated as readers receive values through communication.

For example, consider the consumer goal \verb=consumer([X|Xs?],Sum)= from Section~\ref{section:programming-examples}. As the producer agent extends the stream, the consumer's goal becomes progressively more instantiated to \verb=consumer([1|Xs'?],Sum)=, then \verb=consumer([1,2|Xs''?],Sum)=, etc. These are all reader-instances of the original goal. Agent-level fairness ensures that the consumer agent eventually gets scheduled to reduce one of these instances, preventing starvation even though the producer agent continues to execute concurrently.


\section{GLP Security}\label{section:glp-security}

This section establishes the security properties of GLP at two levels. First, as a programming language, we prove that multiagent GLP, when correctly implemented with standard cryptographic mechanisms, achieves the fundamental security properties required for distributed systems: authentication, integrity, confidentiality, and non-repudiation. These properties ensure that communication between agents is secure, verifiable, and private.

Second, we prove that GLP streams possess blockchain security properties: immutability, non-repudiation, unforkability, authentication, ordering preservation, and tamper evidence. 

The security guarantees at both levels are implied by GLP's invariants—particularly the single-reader/single-writer constraint and acyclicity preservation—and the assumptions on implementation security.  Together, these properties provide the security foundation necessary for implementing grassroots platforms.



\subsection{GLP is a Secure Programming Language}

\mypara{Invariants implied by the GLP specification}
%
The GLP multiagent specification guarantees the following invariants, independent of any implementation choices:

\begin{enumerate}
\item \textbf{Exclusive Variable Ownership.}
Each variable has at most one writer occurrence and one reader occurrence across all agents in any configuration.
\emph{Justification:} Established by Proposition~\ref{proposition:single-reader-writer-invariant} through induction on run length, enforced syntactically by requiring at most one occurrence per variable per clause.

\item \textbf{Consistent Bidirectional Sharing.}
If agent $p$ holds writer $X$ shared with agent $q$, then $q$ holds the paired reader $X?$ shared with $p$, and vice versa.
\emph{Justification:} Proven in Proposition~\ref{proposition:symmetric-sharing-invariant}, maintained by all transactions that modify $Shared$ sets, ensuring $(X,q) \in Shared_p \iff (X',p) \in Shared_q$.

\item \textbf{Absence of Circular Dependencies.}
No configuration contains circular terms where a variable transitively depends on itself.
\emph{Justification:} Guaranteed by Proposition~\ref{proposition:acyclicity-preservation} through the occurs check in reader counterparts, preventing any writer $X$ from being bound to a term containing its paired reader $X?$.

\item \textbf{Deterministic Point-to-Point Communication.}
When agent $p$ binds writer $X$ where $(X,q) \in Shared_p$, exactly agent $q$ receives the binding $X' := T$ through the Reduce \& Communicate transaction.
\emph{Justification:} Follows directly from the operational semantics (Definition~\ref{definition:multiagent-transactions}) combined with exclusive ownership and symmetric sharing, ensuring no other agent can intercept or duplicate the binding.

\item \textbf{Attestation-Gated Variable Sharing.}
New shared variables between previously unconnected agents are established exclusively through Offer or Attest transactions, both requiring attestation term exchange.
\emph{Justification:} By inspection of Definition~\ref{definition:multiagent-transactions}, these are the only transactions that add new entries to agents' $Shared$ sets when no prior shared variables exist.
\end{enumerate}


\mypara{Implementation model}
We consider a concrete implementation where each agent $p \in \Pi$ executes on a networked personal computing device. Each agent is endowed with a self-chosen keypair, unique whp, with a public key identifying the agent and known to other agents and the private key known only to self.

We assume the implementation can create and verify attestations that cryptographically prove agent identity and program integrity. When agents establish communication through Offer or Attest transactions, they exchange attestations containing signatures of their program module hashes.\footnote{On current smartphones, this is realized through Trusted Execution Environments (TEEs) with hardware providers (e.g., ARM) as trust anchors, combined with OS-level attestation services (Google Play Integrity, Apple App Attest) with platform providers as trust anchors.} We assume that agents that successfully provide valid attestations cannot deviate from the GLP protocol—they may only crash-fail, but cannot subvert the attestation mechanism once successfully employed.  While OS compromise could in principle enable post-attestation code substitution, we assume this either does not occur or is detected through periodic re-attestation. 

When agent $p$ binds a writer $X$ to term $T$ where $(X,q) \in Shared_p$, the implementation transmits the binding $X := T$ as a network message from $p$'s device to $q$'s device. These messages travel through untrusted network infrastructure where adversaries may observe, delay, duplicate, or drop messages.

\mypara{Implementation: basic assumptions}
GLP security depends on the implementation satisfying the following basic cryptographic and system properties:
\begin{enumerate}
\item \textbf{Cryptographic Channels.} Each binding $X := T$ transmitted from agent $p$ to agent $q$ is signed with $p$'s private key and encrypted with $q$'s public key. The signature authenticates the sender and prevents tampering, while encryption ensures confidentiality.

\item \textbf{Attestation Correctness.} The system predicate \verb|create_attestation| produces valid attestations \verb|attestation|$(p,Sig_p,X)$ only when executed by agent $p$, where $Sig_p$ is $p$'s signature of the program module hash. The system predicate \verb|verify_attestation| succeeds only for valid attestations.

\item \textbf{Adversary Model.} Network adversaries can observe, delay, replay, or drop messages, but cannot forge cryptographic signatures, break encryption, or guess private keys with non-negligible probability. Adversaries cannot compromise the integrity of attested agents or their cryptographic operations.

\item \textbf{Message Delivery.} While individual messages may be lost, the implementation provides eventual delivery through retransmission mechanisms. Message ordering is preserved through sequence numbers or logical timestamps, and duplicates are handled through idempotency.
\end{enumerate}


Given the specification invariants and basic implementation assumptions, we establish four fundamental security properties for GLP communication:

\mypara{1. Authentication} Agents achieve mutual authentication when they verify each other's identity and program integrity before establishing shared variables. This ensures that communication occurs only between authenticated participants running verified programs.

\begin{definition}[Authentication]\label{prop:authentication}
If $(X,q) \in Shared_p$ and $(X',p) \in Shared_q$ in any reachable configuration, then both agents have successfully verified attestations from each other.
\end{definition}

\begin{proposition}[Authentication Property]
In any GLP run, agents sharing logic variables have mutually authenticated.
\end{proposition}
\begin{proof}
By Invariant 5, shared variables are established only through Offer or Attest transactions (Def.~\ref{definition:multiagent-transactions}), both requiring attestation exchange. By Assumption 2, attestation verification succeeds only for valid signatures. Thus $(X,q) \in Shared_p \land (X',p) \in Shared_q$ implies mutual authentication.
\qed\end{proof}



\mypara{2. Integrity} The integrity property ensures that messages between agents arrive unmodified or not at all. This prevents tampering with variable bindings during transmission through untrusted networks.

\begin{definition}[Integrity]\label{prop:integrity}
If agent $p$ binds writer $X$ to term $T$ where $(X,q) \in Shared_p$, then agent $q$ receives binding $X' := T$ unmodified or receives nothing.
\end{definition}

\begin{proposition}[Integrity Property]
All variable bindings maintain integrity during communication.
\end{proposition}
\begin{proof}
By Invariant 4, when $p$ binds $X$ to $T$ where $(X,q) \in Shared_p$, only $q$ holds $X?$. By Assumptions 1 and 3, the binding is signed by $p$ and signatures cannot be forged. Thus $q$ receives $X' := T$ unmodified or nothing. Invariant 1 prevents substitution via other agents.
\qed\end{proof}



\mypara{3. Confidentiality} Confidentiality ensures that communication between agents remains private, preventing unauthorized disclosure of variable bindings to third parties.

\begin{proposition}[Confidentiality Property]\label{prop:confidentiality}
Variable bindings between agents remain confidential from non-participants.
\end{proposition}
\begin{proof}
By Invariants 1 and 2, if $(X,X')$ is shared between $p$ and $q$, no third agent holds these variables. By Assumptions 1 and 3, binding $X := T$ is encrypted with $q$'s public key and encryption cannot be broken. Thus only $q$ can decrypt the binding.
\qed\end{proof}


\mypara{4. Non-repudiation} Non-repudiation ensures that agents cannot deny having sent messages they signed, providing accountability for all communications.


\begin{definition}[Non-repudiation]\label{prop:non-repudiation}
If agent $p$ sends binding $X := T$ to agent $q$, then $p$ cannot subsequently deny having sent this binding.
\end{definition}

\begin{proposition}[Non-repudiation Property]
All variable bindings are non-repudiable by their senders.
\end{proposition}
\begin{proof}
By Assumption 1, binding $X := T$ from $p$ to $q$ is signed with $p$'s private key. By Assumption 3 and the implementation model, only $p$ possesses this key and signatures cannot be forged. Thus $q$ can retain the signed message as proof of origin.
\qed\end{proof}

The multiagent invariants and the basic implementation assumptions together imply secure communication for all grassroots platform applications built on GLP.

\subsection{GLP Stream Security and Blockchains} 

The security requirements for blockchains have emerged from extensive research following Nakamoto's seminal work~\cite{nakamoto2008peer}, with different properties formalized across multiple papers in cryptography, distributed systems, and consensus mechanism research~\cite{garay2015bitcoin,bonneau2015sok,fang2020digital,zheng2018blockchain,pass2017analysis,cachin2016architecture,bayer1993improving}. 

For streams created and manipulated within a single agent, blockchain security properties hold trivially through the correctness of the agent's local execution. The challenge arises when streams are shared between agents through paired reader/writer variables, where these properties must be maintained despite distribution and potential adversarial behaviour.

We establish that if the GLP implementation satisfies the security requirements listed above, then GLP streams shared between agents satisfy the following essential blockchain security properties:

\begin{enumerate}
\item \textbf{Immutability.} Once a block is added to the chain, it cannot be modified or removed. 
\emph{GLP guarantee:} The single-assignment property of writer variables ensures that once bound, a stream element becomes immutable. When communicated between agents, the integrity property (Proposition~\ref{prop:integrity}) ensures that any attempt to modify a binding in transit will be detected and rejected through signature verification.

\item \textbf{Non-repudiation.} The creator of each block cannot deny authorship.
\emph{GLP guarantee:} Proposition~\ref{prop:non-repudiation} establishes that all variable bindings communicated between agents are cryptographically signed and thus non-repudiable. Each stream element shared via reader/writer pairs carries irrefutable proof of its creator's identity.

\item \textbf{Unforkability.} The chain cannot split into conflicting versions.
\emph{GLP guarantee:} The SRSW invariant (Proposition~\ref{proposition:single-reader-writer-invariant}) ensures that each stream tail writer has exactly one occurrence. This makes it impossible to bind the tail to two different continuations, preventing forks at the language level even when the stream is extended by different agents.

\item \textbf{Authentication.} Each block's creator must be verifiable.
\emph{GLP guarantee:} Proposition~\ref{prop:authentication} ensures that stream elements communicated between agents can only be created by authenticated agents who have undergone mutual attestation verification.

\item \textbf{Ordering preservation.} The sequence of blocks must maintain strict ordering.
\emph{GLP guarantee:} The forward-pointer structure through logic variables, combined with acyclicity (Proposition~\ref{proposition:acyclicity-preservation}), ensures a unique, immutable ordering from each stream element to its successors, maintained across agent boundaries through shared variables.

\item \textbf{Tamper evidence.} Any modification attempt must be detectable.
\emph{GLP guarantee:} For bindings communicated between agents, cryptographic signatures (Assumption 1) combined with the integrity property ensure that tampering with any stream element invalidates its signature, making alterations immediately detectable.
\end{enumerate}


The multiagent invariants and implementation assumptions together imply that GLP streams shared between agents satisfy the blockchain security properties.

While the basic GLP stream has one producer and one consumer, Section~\ref{section:programming-examples} presents extensions to multiple consumers via stream distribution and multiple cooperative producers. It also presents interlaced streams, which can be used to implement state-of-the-art DAG/blocklace-based consensus protocols in GLP.
 



\section{Multiagent GLP is Logical and Grassroots}\label{section:logical-and-grassroots} 

\mypara{maGLP computations are deductions}

\begin{definition}[Pure Logic Variant]\label{definition:pure-logic}
Given a term $T$, the \temph{pure logic variant} $L(T)$ of $T$ is defined by replacing every reader $X?$ with its paired writer $X$. 
For an indexed resolvent $G \subseteq \mathcal{A}_?(M) \times P$, define $L(G) = \{(L(A), p) : (A, p) \in G\}$.
\end{definition}

\begin{proposition}[GLP and maGLP Computation is Deduction]
\begin{enumerate}
\item For any run $\rho: G_0 \rightarrow \cdots \rightarrow G_n$ of GLP with accumulated substitution $\sigma? = \sigma?_1 \circ \cdots \circ \sigma?_n$, the pure logic variant $L((G_0 \texttt{:-} G_n)\sigma?)$ is a logical consequence of $L(M)$.
\item For any run $\rho: G_0 \rightarrow \cdots \rightarrow G_n$ of maGLP with accumulated substitution $\sigma?$, let $\hat{G}_i = \bigcup_{p \in P} (G_i)_p$. Then $L((\hat{G}_0 \texttt{:-} \hat{G}_n)\sigma?)$ is a logical consequence of $L(M)$.
\end{enumerate}
\end{proposition}
\begin{proof}
Both follow from the correspondence between GLP reductions and LP reductions on pure logic variants, combined with Proposition [LP Computation is Deduction]. The multiagent case (2) reduces to (1) by taking the union of local resolvents.
\qed\end{proof}





================

\subsection{GLP Computations are Deductions} 

The safety properties establish the foundation for proving that the outcome of a run of a GLP program is a logical consequence of the underlying logic program, namely that GLP computation is deduction. We first define how to extract substitutions from transitions to capture the computational outcome.


\begin{definition}[Pure Logic Variant]\label{definition:pure-logic}
Given a term $T$, then the \temph{pure logic variant} $L(T)$ of $T$ is defined by replacing every reader $X?$ with its paired writer $X$.
\end{definition}
Note that if $M$ is a GLP program module then $L(M)$ is a logic program.


\begin{definition}[Outcome]\label{definition:outcome}
For a run $\rho: c_0 \rightarrow c_1 \rightarrow \cdots \rightarrow c_n$ of GLP over $P$ starting from initial configuration $c_0$, let $\sigma(\rho) = \sigma(t_1) \circ \sigma(t_2) \circ \cdots \circ \sigma(t_n)$ where $t_i: c_{i-1} \rightarrow c_i$. The \temph{outcome} of the run is $(G(c_0) \verb|:-| G(c_n))\sigma(\rho)$.
\end{definition}

The following result establishes that GLP computation is indeed deduction by showing that every outcome is a logical consequence of the program viewed as axioms.

\begin{proposition}[GLP Computation is Deduction]\label{proposition:GLP-computation-deduction}
For any run $\rho: c_0 \rightarrow c_1 \rightarrow \cdots \rightarrow c_n$ of GLP over agents $P$ with program module $M$, the pure logic variant of the outcome $L((G(c_0) \verb|:-| G(c_n))\sigma(\rho))$ is a logical consequence of the pure logic program $L(M)$.
\end{proposition}
\begin{proof}
We prove by induction on the length of the run that each transition preserves logical consequence.

\mypara{Base case} For $n=0$, we have $G(c_0) = G(c_0)$ with empty accumulated substitution $\epsilon$. The outcome $L((G(c_0) \verb|:-| G(c_0)))$ is a tautology, hence a logical consequence of any program.

\mypara{Inductive step} Assume the proposition holds for runs of length $k$. Consider a run of length $k+1$:
$$\rho: c_0 \rightarrow c_1 \rightarrow \cdots \rightarrow c_k \rightarrow c_{k+1}$$

By the inductive hypothesis, $L((G(c_0) \verb|:-| G(c_k))\sigma_k)$ is a logical consequence of $L(M)$, where $\sigma_k = \sigma(t_1) \circ \cdots \circ \sigma(t_k)$.

For the transition $t_{k+1}: c_k \rightarrow c_{k+1}$, we consider two cases:

\begin{enumerate}
    \item \textbf{Reduce \& Communicate:} Agent $p$ applies clause $A \verb|:-| B$ with writer mgu $\sigma$ and reader counterpart $\sigma?$:
    \begin{itemize}
        \item There exists atom $A \in G_p$ and clause $(H \verb|:-| B) \in M$ renamed apart
        \item $\sigma$ is the writer mgu of $A$ and $H$ with reader counterpart $\sigma?$
        \item $G'_p = (G_p \setminus \{A\} \cup B)\sigma?$
    \end{itemize}
    
    Since $(H \verb|:-| B)$ is a clause in $M$ and $\sigma?$ unifies $A$ with $H$:
    \begin{itemize}
        \item The instance $L((H \verb|:-| B)\sigma?)$ is a logical consequence of $L(M)$ (by instantiation of a program clause)
        \item Since $L(A\sigma?) = L(H\sigma?)$ (by the mgu property), we can replace $L(A)$ with $L(B)$ under substitution $L(\sigma?)$
        \item Communication to other agents preserves logical meaning since $L(X\sigma?) = L(X\sigma)$ for all shared variables
        \item Therefore, $L((G(c_k) \verb|:-| G(c_{k+1})))$ is a logical consequence of $L(M)$ under substitution $\sigma?$
    \end{itemize}
    
    \item \textbf{Offer:} This transaction removes $\verb|offer|(q,X)$ from $G_p$ and adds it to $q$'s offers stream:
    \begin{itemize}
        \item $\sigma(t_{k+1}) = \epsilon$ (identity substitution)
        \item The offer predicate is not part of the logic program $L(M)$
        \item Therefore the logical consequence relationship is preserved with unchanged substitution
    \end{itemize}
\end{enumerate}

By the transitivity of logical consequence, if $L((G(c_0) \verb|:-| G(c_k))\sigma_k)$ is a logical consequence of $L(M)$ and the transition preserves or extends this relationship, then $L((G(c_0) \verb|:-| G(c_{k+1}))\sigma_{k+1})$ is a logical consequence of $L(M)$, where $\sigma_{k+1} = \sigma_k \circ \sigma(t_{k+1})$.

Since this holds for all transitions, we conclude that the outcome\linebreak $L((G(c_0) \verb|:-| G(c_n))\sigma(\rho))$ is a logical consequence of $L(M)$.
\qed\end{proof}

\begin{remark}
Proposition~\ref{proposition:GLP-computation-deduction} extends Proposition~\ref{proposition:lp-deduction} to the 
multiagent setting, showing that despite the distribution of computation across multiple agents 
and the addition of communication through shared variables, GLP preserves the fundamental 
property that computation is deduction.
\end{remark}

\subsection{Grassroots protocols}
The notion of a \emph{grassroots protocol} is formally defined not for a single multiagent transition system but for a family of such~\cite{shapiro2023grassrootsBA}.  It assumes a state function, that for each set of agents $P\subset \Pi$ provides a set of local states $S(P)$, define a \emph{protocol} $\calF$ to be a family of multiagent transition systems, one $\calF(P)$ for each set of agents $P\subset\Pi$, and defines when a protocol is grassroots.  
Here we rephrase informally the formal definition of a grassroots protocol from reference~\cite{shapiro2025atomic}.

\begin{definition}[Oblivious, Interactive, Grassroots]\label{definition:grassroots}
A  protocol $\calF$ is:
\begin{enumerate}
    \item \temph{oblivious} if for every $\emptyset \subset P \subset P' \subseteq \Pi$, 
    a run of the protocol over $P$ can proceed just the same in the presence of agents in $P'$. 
    \item  \temph{interactive} if for every $\emptyset \subset P \subset P' \subseteq \Pi$ and every  run of the protocol over $P$, the protocol can proceed from any configuration $c$ in $r$ to interact with members in $P'\setminus P$, namely produce a run that is not possible only over $P$.
    \item \temph{grassroots} if it is oblivious and interactive.
\end{enumerate}
\end{definition}

A key result of~\cite{shapiro2025atomic} is that if a protocol is defined via atomic transactions, then it is necessarily oblivious;  the following simple condition on transactions implies that the protocol they define is interactive, together implying the protocol to be grassroots.
It uses the operation $R(P){\uparrow}P'$, which is the lift of transactions defined over $P$ to configurations over the larger set $P'$, where non-participating agents in $P' \setminus P$ remain in their current states.

\begin{definition}[Interactive Transactions]\label{definition:interactive}
A set of transactions $R$ over a local-states function $S$ is \temph{interactive} if for every $\emptyset \subset P \subset P' \subset \Pi$ and every configuration $c\in C(P')$ such that $c/P\in C(P)$, 
there is a computation $(c\xrightarrow{*} c')\subseteq R(P){\uparrow}P'$ for which $c'/P\notin C(P)$.
\end{definition}

In other words, with an interactive set of transactions, any group of agents that have been so far self-contained will always have a computation with non-members that will take the group outside of its ``comfort zone'', resulting in members of the group having a local state with ``alien traces'' that could have been produced only by interacting with non-members.  

\begin{theorem}[from~\cite{shapiro2025atomic}]\label{theorem:interactive-grassroots}
A protocol over an interactive set of transactions is grassroots.
\end{theorem}

\subsection{GLP is grassroots} 

Having established that GLP computations preserve the deductive nature of logic programming, we now prove  that GLP satisfies the conditions for being a grassroots protocol. First, we show that transactions are interactive.

For the following Lemma, recall the notion of interactive transition of Definition~\ref{definition:interactive}. 
\begin{lemma}\label{lemma:interactive-transactions}
The GLP transactions are interactive.
\end{lemma}
\begin{proof}
Consider any $\emptyset \subset P \subset P' \subset \Pi$ and configuration $c \in C(P')$ such that $c/P \in C(P)$. This means agents in $P$ have shared variables only with other agents in $P$ and receive offers only from agents in $P$.

The \textbf{Offer} transaction provides the required interactivity: when agent $r \in P' \setminus P$ offers friendship to agent $p \in P$, the transaction creates:
\begin{itemize}
    \item $G'_p = G_p\{Os_p? \mapsto [\verb|offer|(r,X)|Os'_p?]\}$ where $r \notin P$
    \item $Shared'_p = Shared_p \cup \{(X?, r)\}$
\end{itemize}

This results in configuration $c'$ where $c'/P \notin C(P)$ because agent $p$'s local state now contains references to agent $r \notin P$, which could not have been produced by agents in $P$ running in isolation.
\qed\end{proof}

\begin{corollary}\label{corollary:grassroots-property}
GLP is grassroots.
\end{corollary}
\begin{proof}
By the obliviousness property of transactions-based multiagent transition systems, any transactions-based protocol is oblivious. By Lemma~\ref{lemma:interactive-transactions}, the GLP transactions are interactive. Therefore, by Definition~\ref{definition:grassroots}, the GLP protocol is grassroots.
\qed\end{proof}

\section{Programming in GLP}\label{section:programming-examples}

\subsection{Guard and System Predicates}

For GLP to be a practical programming language, it must have access to the state and services of the underlying machine it is running on, as is standard in any real logic programming language. This is achieved through reserved predicate names: \emph{guard predicates} can be used in the guard of a clause as additional conditions for clause selection; \emph{system predicates} can be used in the body of a clause to access underlying system/hardware capabilities. Here we define general conditions on them and list key guard and system predicates.

\mypara{Guard predicates} Guard predicates locally test the value of readers, and hence can have `extra' occurrences of readers without violating the single-reader invariant.
We assume a \emph{guard evaluation function} $\Gamma$ on guards $D$ that may succeed, suspend, or fail, satisfying three invariants:

\begin{enumerate}
    \item \textbf{Monotonicity:}  $\Gamma(D)$ succeeds or fails iff $\Gamma(D\theta)$ also succeeds or fails, respectively, for any substitution $\theta$.
    \item \textbf{Indecision:} $\Gamma(D)$ suspends iff there are reader substitutions $\theta, \theta'$ such that  $\Gamma(D\theta)$ succeeds and $\Gamma(D\theta')$ fails. 
    \item \textbf{Conjunction:}  If $D$ is a set of goals then $\Gamma(D)$ succeeds if $\Gamma(D')$ succeeds for every $D'\in D$, fails if at least one such $\Gamma(D')$  fails, and suspends otherwise.
\end{enumerate}


 Definition~\ref{definition:goal-clause-reduction} is extended to handle guards by adding
 ``and $\Gamma(D\sigma)$ succeeds'', as follows:
 
\begin{definition}[GLP Reduction with guards]\label{definition:goal-clause-reduction}
 Given GLP goal $A$ and clause $C$,  with $H \verb|:- D| B$ being the result of renaming $C$ apart from $A$,
 the \temph{GLP reduction} of $A$ with $C$ \temph{succeeds with result} $(B,\sigma?)$ if $A$ and $H$ have writer mgu $\sigma$ and $\Gamma(D\sigma)$ succeeds; \temph{suspends} if $A$ has a reader-instance $A'$ for which the GLP reduction of $A'$ with $C$ succeeds; else \temph{fails}.
\end{definition}


Here is a list of useful guards and their invariant-satisfying meaning:
\begin{enumerate}
    \item \verb|X=Y| succeeds if \verb|X| and \verb|Y| are identical.  If \verb|X| and/or \verb|Y| are arithmetic expressions, they are replaced by their values before comparison. 
    \item \verb|X=Y| succeeds if \verb|X| and \verb|Y| are identical. Can be used to increase readability by moving goal-heard unification into the guard.  
For example, using \verb|=|, the first \verb|merge| clause can be written equivalently:
\begin{verbatim}
merge(Xs,Ys,Zs?) :- Xs?=[X|Xs1], Zs=[X?|Zs1?] | merge(Ys?,Xs1?,Zs1). 
\end{verbatim}
    \item \verb|X=\=Y| succeeds if \verb|X=Y| fails.
    \item \verb|known(X)| succeeds if \verb|X| is not a variable (but may be non-ground---a term that contains variables). 
    \item \verb|ground(X)| succeeds when \verb|X| is ground.  A key advantage of this guard predicate is that if \verb|ground(X)| occurs in the guard, then the body may contain multiple copies of \verb|X?| without violating the single-writer requirement.  Hence, the SRSW invariant is appropriately relaxed for clauses with this guard. 
    \item \verb|writer(X)| succeeds if \verb|X| is an uninstantiated writer
    \item \verb|reader(X)| succeeds if \verb|X| is an uninstantiated reader (not monotonic!)
    \item \verb|otherwise| succeeds if all previous clauses in the procedure failed. 
\end{enumerate}
Note that by definition, \verb|known(X)| and \verb|reader(X)| fail if \verb|X| is a writer,
and \verb|ground(X)| fails if \verb|X| is or includes a writer.

To support abstract data types, we also provide for user-defined guards. A user defined guard is defined by a unit clause \verb|p(T1,...,Tn)| and a call \verb|p(S1,...,Sn)| in the guard is equivalent to including the equalities \verb|T1=S1,..., Sn=Tn| in the guard.

\mypara{Defined guard predicates for abstract data types}
Below we employ extensively bidirectional channels, represented with the term \verb|ch(In?,Out)|, and define guard predicates for channel receiving and sending, called with \verb|send(X?,Ch?,Ch1)| and \verb|receive(X,Ch?,Ch1)| to send and receive a message \verb|X| on a channel \verb|Ch|, respectively:
\Program{Channel operations}\label{program:channel-operations}
\begin{verbatim}
send(X,ch(In,[X?|Out?)),ch(In?,Out)).

receive(X?,ch([X|In],Out?),ch(In?,Out)).

new_channel(ch(Xs?,Ys),ch(Ys?,Xs)).
\end{verbatim}
\verb|new_channel| creates a channel pair, where the input of one is paired to the output of the other. To demonstrate their use, here is a simple relay program with ordinary input and output streams that sends on the channel messages it receives on its input stream, and sends on its output stream messages it receives on the channel.  It is called with \verb|relay(In,Out,Ch)| with \verb|Ch| bound to a bidirectional channel.

\Program{Streams to Channel Relay}\label{program:stream-to-challen}
\begin{verbatim}
relay(In,Out?,Ch) :- 
    In?=[X|In1], send(X?,Ch?,Ch1) | relay(In1?,Out,Ch1?).
relay(In,Out?,Ch) :- 
    receive(X,Ch?,Ch1), Out=[X?|Out1?] | relay(In?,Out1,Ch1?).
\end{verbatim}

Termination clauses can be added if needed. The unfolded program, with guard unifications applied, depends on the concrete representation of bidirectional channels and may be a bit less readable to humans:

\begin{verbatim}
relay([X|In],Out?,ch(In,[X?|Out?)) :-  relay(In?,Out,ch(In?,Out)).

relay(In,[X?|Out?],ch([X|In],Out?)) :- relay(In?,Out,ch(In?,Out)).
\end{verbatim}

\mypara{System predicates} 
System predicates provide access to the capabilities and state of the GLP runtime, operating system, or hardware.  To simplify their implementation, a call to a system predicate cannot suspend:  It can only succeed or fail.  Hence preconditions for the success of a system predicate should be checked prior to their application. Moreover, system predicate goals in a body of a clause are not spawned as independent processes for later execution, but are executed immediately upon clause reduction.

A simple case in point is \verb|evaluate(X,T)|, which evaluates the arithmetic expression $T$ (presumably efficiently using the underlying hardware capabilities) and binds $X$ to the result.  As the call would fail (rather than suspend) on unbound variables in \verb|T|, a check that \verb|T| is ground should be made prior to the call.
Hence, the actual predicate to be used would be the one defined by:
\begin{verbatim}
X:=T :- ground(T) | evaluate(X,T).
\end{verbatim}
The call \verb|evaluate| could still fail if \verb|T| is not an arithmetic expression, but the onus of verifying this should be on the caller.

System predicates are guaranteed to be correct.  In particular, some system predicates may guarantee not to write on writers in their input terms, and therefore can be called with a second copy of a reader, violating the syntactic single-reader requirement without this resulting multiple writing to a writer.

Here are the system predicates needed to realize GLP as specified:
\begin{enumerate}
    \item \verb|create_attestation(X,Att)| creates an attestation term \verb|Att| of the form \verb|attestation(p,Sig_p,X)| where \verb|p| is the agent's public key, \verb|Sig_p| is a signature of the agent's current program module hash, and \verb|X| must be a writer shared with the intended recipient (fails otherwise).
    \item \verb|verify_attestation(Att,P,ModuleId)| verifies an attestation \verb|Att|, extracting the peer's public key \verb|P| and module identifier \verb|ModuleId|. Fails if the attestation is invalid or if not received via a shared variable from the attested agent.
    \item \verb|offer(Q,X)| initiates a cold-call offer to agent \verb|Q| with writer \verb|X|, creating an authenticated first contact. While implemented as a transaction at the language specification level, it appears as a system predicate to the programmer.
    \item \verb|attest(Q,X)| sends an attestation to agent \verb|Q| via shared writer \verb|X|, enabling peers with existing connections to reverify each other's identity and program compatibility. Like \verb|offer|, this is implemented as a transaction but used as a system predicate.
\end{enumerate}
Here is a list of some useful system predicates:
\begin{enumerate}
    \item \verb|time(X)| binds \verb|X| to the current time
    \item  \verb|evaluate(X,T)| evaluates the arithmetic expression in \verb|T| and binds the result to \verb|X|.
    \item \verb|variable_name(X,Name)| if \verb|X| is a variable then it binds \verb|Name| to a constant that uniquely identifies \verb|X| and its paired variable, with the suffix \verb|?| added if \verb|X| is a reader.
    \item \verb|list_to_tuple(Xs?,T)|, \verb|tuple_to_list(T?,Xs)| convert back and forth between a tuple and a list of its arguments. 
\end{enumerate}

% and \verb|tuple(T,N)| succeeds if \verb|T| is a tuple with arity \verb|N|. Additional predicates \verb|create_tuple(N,T)| creates a new tuple of arity \verb|N|, and \verb|arg(T,K,A)| unifies \verb|A| with the \verb|K|th argument of tuple \verb|T|.

\subsection{Basic Techniques and Utilities}

This section presents basic concurrent logic programming techniques that are used throughout the social graph and application layers. 


\mypara{State threading through tail-recursion}
Note that the standard implementation of tail-recursion is via iteration with the updated state of the recursive call.

\Program{State Threading Through Tail-Recursion}\label{program:counter}
\begin{small}
\begin{verbatim}
% Counter maintaining state through recursive calls
counter(Count, [inc|Ops]) :- 
    Count1 := Count? + 1,
    counter(Count1?, Ops?).
counter(Count, [get(C)|Ops]) :-
    C = Count?,
    counter(Count?, Ops?).
counter(Count, []).
\end{verbatim}
\end{small}


The counter demonstrates how state is threaded through recursive calls in GLP. Each operation transforms the state, passing the updated value to the next recursive call. This technique is fundamental to maintaining the Friends list in the boot protocol.

\mypara{Channels}

\Program{Interaction via Channels}\label{program:interact}
\begin{small}
\begin{verbatim}
% Interactive session with query-response protocol
interact(Ch, State) :-
    send(prompt(State?, Action), Ch?, Ch1),
    process_action(Action?, State?, State1),
    interact(Ch1?, State1?).

process_action(update(Value), _, Value).
process_action(query(Result), State, State) :-
    Result = State?.
process_action(quit, _, done).
\end{verbatim}
\end{small}

The interaction protocol demonstrates sending incomplete messages (queries with unbound response variables) through channels and waiting for responses---the mechanism used for obtaining user approval in the boot protocol.

These techniques combine in the boot protocol: state threading maintains the Friends list, accumulation adds approved friendships, and channel-based interaction obtains user consent for each cold-call offer.



\section{The Social Graph}~\label{section:social-graph}

The grassroots social graph forms the foundation for all grassroots platforms: Nodes represent people,  edges—authenticated friendships, and graph connected components emerge, grow, and interconnect. This happens through two mechanisms: cold calls for initial contact and connecting disconnected components and friend-mediated introductions for component growth. 

The multiagent semantics in Section~\ref{subsection:multiagent-glp-mts} defined these mechanisms formally as atomic transactions: the \textbf{Offer} transaction for authenticated cold calls and the \textbf{Attest} transaction for mutual verification. This section shows how GLP programs access and use these language-level transactions through system predicates \verb|offer(Q,X)| and \verb|attest(Q,X)|, along with the programming techniques needed to implement the social graph's growth and management. Every subsequent grassroots application---from social networks to cryptocurrencies to democratic federations---operates over this trust infrastructure, with all communication flowing through these authenticated channels.

The social graph program employs a unified stream architecture where all inputs—cold-call offers from the network, messages from friends, and commands from applications—are tagged with their source and merged into a single stream for processing. The application layer communicates through a decomposed channel: commands flow into the social graph via the merged stream (tagged as "user"), while queries flow out through a dedicated output stream (ToApps). This design enables uniform message processing while maintaining clear separation between the social graph infrastructure and the applications built upon it.


\subsection{Cold Calls}\label{subsection:cold-calls}

Agents initially have no shared variables and thus no way to communicate within GLP. To bootstrap the social graph, GLP provides a cold-call mechanism where any agent can attempt to establish first contact with any other agent of which they know their public key. Each agent maintains an offers stream for receiving friendship requests, implemented through a writer variable shared with the distinguished pseudo-agent introduced in Definition~\ref{definition:agent-state}. 


\mypara{The social graph program} The \verb|offer(Q,X)| system predicate implements the Offer transaction from Definition~\ref{definition:multiagent-transactions}: when agent $p$ executes \verb|offer(q,X)|, it sends an attestation containing $p$'s public key, a signature of $p$'s program module, and the fresh writer \verb|X| to $q$'s offers stream. Agent $q$ receives this offer through its boot program, can verify $p$'s identity and program compatibility, and decides whether to accept the friendship by responding through \verb|X|.


\Program{Social Graph Protocol}%\label{program:social-graph}
\begin{small}
\begin{verbatim}
% Initial: social_graph(Apps, NetIn)
social_graph(Apps, NetIn) :- 
    Apps = ch(FromApps, ToApps),
    tag_stream(net, NetIn?, NetTagged),
    tag_stream(user, FromApps?, UserTagged),
    merge(NetTagged?, UserTagged?, In),
    social_graph(In?, ToApps?, []).


% Friendship offer
social_graph([msg(From, attestation(Name, Sig, Resp))|In], 
        [query(befriend(From?, Name?), Dec)|ToApps?], Fs) :-
    ground(From), ground(Name) |
    verify_attestation(Name?, Sig?, Valid),
    establish(Valid?, Dec?, Name?, Resp?, Fs?, Fs1, In?, In1),
    social_graph(In1?, ToApps, Fs1?).


    
% Establish friendship
establish(true, yes, Name, (accept, FCh?), Fs, [(Name?, NameOut)|Fs?], In, In1) :-
    new_channel(ch(NameIn, NameOut), FCh),
    tag_stream(Name?, NameIn?, Tagged),
    merge(In?, Tagged?, In1).
establish(_, no, _, rejected, Fs, Fs?, In, In?).
establish(false, _, _, rejected, Fs, Fs?, In, In?).
\end{verbatim}
\end{small}


\mypara{Programming techniques}
The boot protocol demonstrates several key GLP techniques. \textbf{Stream merging}: Friend inputs are tagged with sender names and merged into a single stream, enabling uniform message processing. While the naively-created merge tree is linear and hence inefficient,  standard concurrent logic programming techniques can rectify this~\cite{shapiro1984fair,shapiro1986multiway}. \textbf{Channel decomposition}: The \texttt{new\_channel} creates paired channels, but only the output stream goes into the Friends list while the input gets tagged and merged. \textbf{Extensible design}: The \texttt{establish} procedure handles friendship establishment uniformly, ready for extension with new connection types.


\subsection{Friend-Mediated Introductions}

Friend-mediated introductions extend the boot protocol by enabling people to introduce their friends to each other. At the personal level, P tells both Q and R about the intended introduction. At the agent level, P provides R with a method to reach Q directly without using the cold-call mechanism. From Q's agent perspective, the resulting attestation is processed identically to a cold call, maintaining uniform friendship establishment.


\mypara{Friend-mediated introduction—architecture}
%
The introduction protocol enables an agent P to facilitate connections between friends Q and R without blocking or requiring three-way coordination. When P introduces R to Q, it gives R a one-time channel to send an attestation to Q, while simultaneously telling Q (via an \texttt{introducing} message) to expect and properly attribute messages from that channel. This preserves stream ownership—P still owns the stream to Q—while enabling forwarded attribution.



\Program{Social Graph Protocol with Unified Output}\label{program:social-graph-unified}
\begin{small}
\begin{verbatim}
% Initial: agent(Id, ChUser, ChNet)
agent(Id, ChUser, ChNet) :- 
    ChUser = ch(UserIn, UserOut),
    ChNet = ch(NetIn, NetOut) |
    tag_stream(net, NetIn?, NetTagged),
    tag_stream(user, UserIn?, UserTagged),
    merge(NetTagged?, UserTagged?, In),
    social_graph(Id?, In?, [(user, UserOut), (net, NetOut)]).
    
% Process user connect command  
social_graph(Id, [msg(user, connect(To))|In], Fs) :-
    ground(Id), ground(To) |
    lookup_send(net, msg(Id, To, offer(Resp)), Fs?, Fs1),
    wait_response(Resp?, To, Fs1?, Fs2, In?, In1),
    social_graph(Id, In1?, Fs2?).

% Process network offer
social_graph(Id, [msg(net, msg(From, To, offer(Resp)))|In], Fs) :-
    ground(Id), To = Id, ground(From) |
    lookup_send(user, msg(agent, user, befriend(From, Dec)), Fs?, Fs1),
    social_graph_wait_decision(Id, In?, Fs1?, Dec?, From, Resp).
    
% Wait for user decision (continuation)
social_graph_wait_decision(Id, [msg(user, msg(user, agent, Dec))|In], Fs, Dec, From, Resp) :-
    ground(Id), ground(From), ground(Dec) |
    establish(Dec, From, Resp, Fs?, Fs1, In?, In1),
    social_graph(Id, In1?, Fs1?).

% Process friend message  
social_graph(Id, [msg(Friend, Content)|In], Fs) :-
    ground(Id), ground(Friend), Friend \= user, Friend \= net |
    % Application-specific friend message handling
    process_friend_message(Friend, Content, Response),
    lookup_send(Friend, Response?, Fs?, Fs1),
    social_graph(Id, In?, Fs1?).
    
% Establish friendship
establish(yes, From, Resp, Fs, [(From, FOut)|Fs], In, In1) :-
    new_channel(ch(FIn, FOut), FCh),
    Resp = accept(FCh),
    tag_stream(From, FIn?, Tagged),
    merge(In, Tagged?, In1).
establish(no, _, reject, Fs, Fs, In, In).

% Wait for response  
wait_response(accept(ch(FIn, FOut)), To, Fs, [(To, FOut)|Fs], In, In1) :-
    tag_stream(To, FIn?, Tagged),
    merge(In, Tagged?, In1).
wait_response(reject, _, Fs, Fs, In, In).

% Helper: lookup and send in one operation
lookup_send(Name, Msg, [(Name, Out)|Fs], [(Name, Out1)|Fs]) :-
    Out = [Msg|Out1].
lookup_send(Name, Msg, [F|Fs], [F|Fs1]) :-
    lookup_send(Name, Msg, Fs?, Fs1).
\end{verbatim}
\end{small}

\mypara{Programming techniques}
The introduction protocol employs several sophisticated techniques. \textbf{Enhanced tagging}: The \texttt{tag\_stream} predicate handles the special \texttt{introducing(R, RIn)} message by creating a merger that tags both R's forwarded messages and P's continuing messages. \textbf{One-shot channels}: The introduction channel closes after single use, preventing abuse. \textbf{Lookup-and-modify}: The \texttt{lookup\_send} helper finds a friend's stream and sends a message in one pass through the Friends list, avoiding multiple traversals. (Note that it fails if the looked-up name is not there; error-handling can be added.) \textbf{Non-blocking design}: R can decline or delay without affecting P or Q's operations.


\mypara{Re-attestation capability}
The social graph protocol processes attestations uniformly regardless of source. While the initial attestation establishes friendship, participants can send additional attestations at any time to reverify identity and code integrity. This allows agents to verify the integrity of their friends periodically, when interactions with a friend raise concerns, or before conducting a significant transaction with that friend. An existing friend sending \verb|attestation(Name, Sig, Resp)| through their established channel triggers the same verification process, allowing the recipient to confirm their friend still runs compatible, uncompromised code.


\section{GLP Security: The Grassroots Social Graph}

The grassroots social graph platform achieves authenticated and secure communication when GLP is correctly and securely implemented. The protocol's Offer and Attest transactions establish authenticated friendships through attestation exchange, creating the trusted channels that form the social graph edges. We prove that these mechanisms ensure three fundamental security properties: authentication (friends verify each other's identity before establishing shared variables), integrity (messages between friends cannot be forged or modified), and confidentiality (only intended recipients can read messages sent through shared variables).


\mypara{Implementation assumptions}
We assume that the GLP implementation provides the following cryptographic guarantees:
\begin{enumerate}
    \item \textbf{Cryptographic integrity:} Each agent holds a self-chosen keypair, unique whp, with a public key known to other agents and a private key known only to self.
    
    \item \textbf{Cryptographic channels:} A binding $X \gets T$ to a shared logic variable $X$, in which $p$ holds the writer and $q$ the reader, is implemented as a message from $p$ to $q$, signed by $p$'s private key and encrypted with $q$'s public key, sent over an unreliable network that provides no guarantees of delivery, ordering, or confidentiality.
    
    \item \textbf{Attestation correctness:} The system predicate \verb|create_attestation| succeeds in creating the valid attestation \verb|attestation|$(p,Sig_p,X)$ only if executed by the agent cryptographically-identified by $p$ running a correct GLP agent (e.g. correct GLP smartphone app) where $Sig_p$ is $p$'s signature of the hash of the GLP program module that calls \verb|create_attestation|. The system predicate \verb|verify_attestation|$(Att,p,ModuleId)$ succeeds only if $Att$ is a valid attestation by $p$ executing module $ModuleId$.
    
    \item \textbf{Network adversary model:} Network adversaries can observe, delay, or replay messages, but cannot forge cryptographic signatures, break encryption, or guess cryptographic keys with non-negligible probability.
    
    \item \textbf{Failure model:} Agents may crash-fail (losing state without revealing private keys) or be Byzantine (deviating arbitrarily from protocol but unable to forge signatures or break encryption). We assume that agents that successfully provide valid attestations cannot deviate from the GLP protocol—they may only crash-fail, and cannot subvert the attestation mechanism once successfully employed.
\end{enumerate}
The attestation integrity assumption requires that attested agents remain correct. While OS compromise could in principle enable post-attestation code substitution, we assume this either does not occur or is detected through periodic re-attestation. This assumption is reasonable in TEE-based implementations where the trusted execution environment protects against OS-level attacks.

\mypara{Security properties}
Given the implementation assumptions, we now establish the security properties of the social graph platform.


The authentication property ensures that communication in the social graph occurs only between agents who have mutually verified each other's identities and program compatibility.

\begin{definition}[Authentication]
Two agents have authenticated communication in the social graph platform if they share logic variables only after successfully exchanging and verifying attestations through either an Offer transaction or friend-mediated introduction.
\end{definition}

\begin{proposition}[Authentication Property]
If agents $p$ and $q$ share a logic variable pair in any configuration reachable from the initial configuration of the social graph platform, then both $p$ and $q$ have successfully verified each other's attestations containing their public keys and program module signatures.
\end{proposition}

\begin{proof}
By the semantics of the social graph platform defined in Section~\ref{section:social-graph}, logic variables can be shared between agents only through two mechanisms. First, the Offer transaction requires agent $p$ to send an attestation containing $p$'s public key and program signature to agent $q$'s offers stream. For the transaction to complete and establish shared variables, $q$ must verify this attestation through \verb|verify_attestation| and explicitly accept the friendship, at which point $q$ provides its own attestation in response. Second, friend-mediated introduction requires a mutual friend $r$ to facilitate the connection, after which $p$ and $q$ exchange attestations before establishing direct communication channels. By Assumption 3 (attestation correctness), valid attestations can only be produced by agents running correct GLP implementations with the specified program modules. Since these are the only mechanisms for establishing shared variables between agents in the social graph platform, any shared variable pair implies successful mutual attestation verification.
\qed
\end{proof}


\begin{definition}[Authentication]
If two agents share a logic variable (where one holds a writer the other its paired reader) in any configuration reachable from the initial configuration of a GLP run, then both agents have successfully verified each other's attestations.
\end{definition}


\begin{proposition}[Authentication Property]
In any GLP run, if agents $p$ and $q$ share a logic variable in configuration $c$, then there exists a prior configuration in which both $p$ and $q$ successfully verified each other's attestations.
\end{proposition}
\begin{proof}
Logic variables can only be shared between agents through the atomic transactions defined in Section~\ref{subsection:multiagent-glp-mts}. By Definition~\ref{definition:multiagent-transactions}, the only transactions that establish shared variables between agents are Offer and Attest.

The Offer transaction specifies that agent $p$ sends an attestation to agent $q$'s offers stream, where the attestation contains $p$'s public key and program signature. By Assumption 3 (attestation correctness), a valid attestation can only be produced by an agent running correct GLP implementation. For the transaction to complete with shared variables established, $q$ must successfully verify this attestation. Similarly, $q$ must provide its own attestation in response, which $p$ must verify. The transaction's semantics ensure shared variables are created only after both agents have exchanged and verified attestations.

The Attest transaction requires agents to already share variables (from a prior Offer transaction) and performs mutual re-attestation with the same verification requirements.

Since these are the only mechanisms for establishing shared variables between agents, and both require successful mutual attestation exchange and verification, any shared variable in configuration $c$ implies prior mutual attestation verification.
\qed\end{proof}

\begin{definition}[Integrity]
A binding $X := T$ communicated from agent $p$ to agent $q$ in a GLP run maintains integrity if the value received by $q$ equals the value sent by $p$.
\end{definition}

\begin{proposition}[Integrity Property]
Given the cryptographic channel assumption, if agent $p$ binds writer $X$ to term $T$ where $(X,q) \in Shared_p$, then agent $q$ receives the binding $X' := T$ without modification.
\end{proposition}
\begin{proof}
By Definition~\ref{definition:multiagent-transactions}, when agent $p$ executes a Reduce \& Communicate transaction that binds $X$ to $T$:
\begin{itemize}
    \item The transaction applies $G'_q := G'_q\{X' \mapsto X\sigma?\}$ where $X\sigma? = T$
    \item By Assumption 2 (cryptographic channels), this binding is transmitted as a message signed by $p$'s private key
    \item The signature prevents modification: any alteration would invalidate the signature, causing the message to be rejected
    \item Network adversaries (Assumption 4) cannot forge valid signatures
\end{itemize}

Therefore, agent $q$ either receives the exact binding $X' := T$ as sent by $p$, or receives nothing (if the message is lost or corrupted). The single-writer invariant (Proposition~\ref{proposition:single-reader-writer-invariant}) ensures that no other agent can bind $X$, preventing substitution attacks.
\qed\end{proof}

\begin{definition}[Confidentiality]
Communication between agents $p$ and $q$ in a GLP run maintains confidentiality if variable bindings shared between them cannot be read by any agent $r \notin \{p,q\}$.
\end{definition}

\begin{proposition}[Confidentiality Property]
Given the cryptographic channel assumption, if agents $p$ and $q$ share a logic variable pair $(X,X')$, then no agent $r \notin \{p,q\}$ can observe the bindings communicated via this variable pair.
\end{proposition}
\begin{proof}
The confidentiality property follows from the combination of language-level and implementation-level guarantees:

\begin{enumerate}
    \item \textbf{Language level}: By the symmetric sharing invariant (Proposition~\ref{proposition:symmetric-sharing-invariant}), if $(X,q) \in Shared_p$, then only agents $p$ and $q$ hold the variable pair $(X,X')$. The single-writer invariant ensures no third agent can obtain these variables through program execution.
    
    \item \textbf{Implementation level}: By Assumption 2, when $p$ binds $X$ to term $T$, the message $X := T$ is encrypted with $q$'s public key. Only $q$ possesses the corresponding private key to decrypt this message.
    
    \item \textbf{Network level}: By Assumption 4, network adversaries can observe encrypted messages but cannot decrypt them without the private key, which by Assumption 1 is known only to its owner.
\end{enumerate}

Therefore, the binding $X := T$ remains confidential between $p$ and $q$, observable only by the agents sharing the variable pair.
\qed\end{proof}

\begin{remark}
These security properties demonstrate that GLP achieves authenticated, integrity-protected, and confidential communication between friends in the social graph. Unlike traditional distributed systems that might require separate security layers, GLP integrates these properties into its fundamental communication mechanism through the combination of single-reader/single-writer semantics and cryptographic implementation.
\end{remark}



\section{Social Networking}\label{section:social-networking}

The grassroots social graph established through the boot protocol (Section~\ref{subsection:cold-calls}) and friend-mediated introductions (Section~\ref{subsection:friendly-introduction}) provides the foundation for implementing social networking applications in GLP. This section demonstrates how to build three core social networking functions on top of this infrastructure: direct messaging between friends, feeds with followers for one-to-many broadcasting, and group chats for multi-party communication. 

Each application leverages the authenticated channels established through befriending, ensuring that all communication occurs between verified participants running compatible programs. Direct messaging utilizes the bidirectional streams created during friendship establishment. Feeds enable broadcasting of ground terms (posts, images, video) to followers through efficient distribution techniques that respect the single-reader/single-writer invariant. Group chats employ interlaced streams to achieve causal message ordering without requiring consensus protocols. Together, these techniques demonstrate how GLP can realize the functionality of contemporary social networks while maintaining the grassroots properties of sovereignty, privacy, and freedom from central control.



\subsection{Direct Messaging}

Direct messaging in GLP builds upon the authenticated friend channels established during befriending, but creates dedicated bidirectional streams for conversations between friends. The key design principle is that direct message channels are created and managed by application layer, not by the boot protocol itself. When a friendship offer is accepted, the acceptor's applications layer creates a fresh bidirectional channel specifically for direct messaging and includes it in their acceptance response. This channel is then transmitted to the offerer through the newly established friend channel, providing both parties with a dedicated communication stream for their conversation. The boot protocol merely facilitates this exchange and does not retain the DM channels—they are handed off to the applications layer, which maintains conversation state, history, and presentation logic. This separation of concerns keeps the boot protocol focused on managing the social graph while delegating application-level messaging functionality.

To realize direct messaging, all we do is modify the \verb|establish| clause that handles successful befriending:

\Program{Incorporating Direct Messaging}
\begin{verbatim}
% Establish friendship
establish(true, yes(DMCh), Name, (accept, FCh?), Fs, 
        [(Name?, NameOut)|Fs?], In, In1?) :-
    new_channel(ch(NameIn, [DMCh?|NameOut]), FCh),
    tag_stream(Name?, NameIn?, Tagged),
    merge(In?, Tagged?, In1).
\end{verbatim}

This modified clause receives \verb|yes(DMCh)| from the applications layer instead of a simple \verb|yes|, where \verb|DMCh| is the DM channel created by the acceptor's application. The clause creates the friend channel \verb|FCh| with \verb|new_channel|, but crucially initializes the output stream to begin with \verb|[DMCh?|Out]|—ensuring the DM channel is the first message sent to the new friend. Simultaneously, it sends \verb|(accept, FCh?)| on the response channel to confirm acceptance. The offerer, upon receiving the friend channel, will immediately receive \verb|DMCh| as the first message and can route it to their application. This design maintains clear asymmetry: the acceptor creates the DM channel, eliminating any ambiguity about channel ownership while ensuring both parties share a dedicated channel for their conversation.


\subsection{Feeds & Followers}



\subsection{Basic Communication with Paired Logic Variables}

\mypara{One-way Message}
The simplest communication in GLP is sending a single value through a variable pair. A run of the following program with the goal \verb|is(X), is(X?)| consists of two goal reductions.  The first instantiates the writer \verb|X| to the constant \verb|a| and the second gets the value through reader \verb|X?| and confirms it to be \verb|a|:

\begin{small}
\begin{verbatim}
is(a).
\end{verbatim}
\end{small}

To have the receiver act on the message rather than just accept it, a procedure consisting of different clauses expecting different values can be used.  When called with goal \verb|sender(X), receiver(X?)|, the program below enables the receiver to take different actions based on the received value:

\begin{small}
\begin{verbatim}
sender(a).

receiver(a) :- received_a.
receiver(b) :- received_b.

received_a :- ...
received_b :- ...
\end{verbatim}
\end{small}

This program does not prevent a call \verb|sender(a)| with an already-bound value or \verb|receiver(Y)| with a writer (which would succeed since the receiver will instantiate \verb|X| to \verb|a|using its first applicable clause and the sender will confirm this value). The following mode-protected version ensures \verb|sender| only accepts readers (unbound variables) and \verb|receiver| only accepts writers (bound values):
\begin{small}
\begin{verbatim}
sender(X?) :- sender1(X).
sender1(a).

receiver(X) :- receiver1(X?).
receiver1(a) :- received_a.
receiver1(b) :- received_b.
\end{verbatim}
\end{small}
This enforces mode-safe communication at runtime through the reader/writer pair.
Standard compile-time program analysis, notably partial evaluation~\cite{jones1996introduction}, may replace these runtime checks with compile-time analysis that can determine when the checks are satisfied and hence redundant.

\mypara{One-way Stream}
Streams enable continuous communication through a sequence of messages. When called with goal \verb|producer(Xs,0), consumer(Xs?,0)|, the following program has the producer generate an infinite stream of integers and the consumer compute their running sum:

\begin{small}
\begin{verbatim}
producer([N?|Xs?],N) :- N1 := N? + 1, producer(Xs,N1?).

consumer([X|Xs],Sum) :- Sum1 := Sum? + X?, consumer(Xs?,Sum1?).
\end{verbatim}
\end{small}

The producer generates the infinite stream \verb|[0,1,2,3,...]| continuously. The consumer accumulates the running sum as it receives each value. In a fair run (Definition~\ref{definition:fair-glp}), each consumer goal \verb=consumer([X|Xs?],Sum)= must eventually be reduced. As the producer extends the stream, fairness ensures that the consumer makes progress, guaranteeing that every number produced is eventually consumed.


\mypara{Stream Tagging}
When multiple streams arr merged, the identity of the source stream is not retained by the messages.
The following procedure tags each message in a stream with a name (e.g. its sender's name), enabling multiple input streams to be merged while recording sender identity.

\Program{Stream Tagging}\label{program:tag-stream}
\begin{small}
\begin{verbatim}
% Tag messages with sender name for merged streams
tag_stream(Name, [M|In], [msg(Name?, M?)|In1]) :-
    tag_stream(Name?, In?, In1).
tag_stream(_, [], []).
\end{verbatim}
\end{small}


\mypara{Bidirectional Messaging}
Real applications need stateful services---historically called \emph{monitors}~\cite{hansen1973operating,hoare1974monitors}---that maintain local state and an input stream of queries. A query that requires a response is provided with a writer, on which the monitor writes the response to the query.  The sender of the query presumably retains the paired reader in order to read the response.

An an example, the following monitor, initiated with goal \verb|monitor(Ops?)|, maintains a counter that is initially zero and responds to \verb|add|, \verb|subtract|, and \verb|value| queries on its \verb|Ops?| input stream. It uses the guard predicate \verb|ground(X)|, which succeeds if \verb|X| is ground (contains no unbound variables), fails if \verb|X| contains a writer, and suspends if \verb|X| contains an unbound reader. This predicate is essential for safe variable replication in program clauses, as ground terms can be shared without violating the single-reader/single-writer invariant.

\Program{Monitor}\label{program:monitor}
\begin{small}
\begin{verbatim}

monitor(Ops) :- monitor(Ops?,0).

monitor([add(N)|Ops],Sum) :- Sum1 := Sum? + N?, monitor(Ops?,Sum1?).
monitor([subtract(N)|Ops],Sum) :- Sum1 := Sum? - N?, monitor(Ops?,Sum1?).
monitor([value(Sum?)|Ops],Sum) :- ground(Sum?) | monitor(Ops?,Sum?).
monitor([],_).
\end{verbatim}
\end{small}

The guard \verb|ground(Sum?)| allows safe replication of \verb|Sum?| to both head and  body.




\mypara{Fair Stream Merging}
A stateful monitor can serve multiple clients by merging their request streams. The merge procedure (Program \ref{program:fair-merge}), merges two input streams into a single output stream, interleaving elements fairly when elements in both streams are available.

\Program{GLP Fair Stream Merger}\label{program:fair-merge}
\begin{small}
\begin{verbatim}
merge([X|Xs],Ys,[X?|Zs?]) :- merge(Ys?,Xs?,Zs). % output element of first stream 
merge(Xs,[Y|Ys],[Y?|Zs?]) :- merge(Xs?,Ys?,Zs). % output element of second stream 
merge([],[],[]). % close output stream and terminate 
\end{verbatim}
\end{small}

As clauses are selected in order, \verb|merge| rotates the priorities between the two streams, giving priority to the stream not selected.
Each client sends operations on their stream and receives responses through the \verb|V?| variables in \verb|value(V)| requests. This technique extends naturally to any number of clients through cascaded binary merges or a multiway merge.

\mypara{Dynamic Stream Merge}
The number of streams a monitor serves can increase dynamically by the merger in front of it serving \verb|merge(Ws)| messages, as follows:

\Program{Dynamic Stream Merger}\label{program:dynamic-merge}
\begin{small}
\begin{verbatim}
merger(Ws,Xs,Out?) :- merge(Ws?,Xs?,Out).

merge([merge(Ws)|Xs],Ys,Zs?) :- 
   merger(Ws?,Xs?,Xs1), merge(Xs1?,Ys?,Zs).
merge(Xs,[merge(Ws)|Ys],Zs?) :- 
   merger(Ws?,Ys?,Ys1), merge(Xs?,Ys1?,Zs).
merge([X|Xs],Ys,[X?|Zs?]) :- 
    X =\= merge(_) | merge(Ys?,Xs?,Zs).
merge(Xs,[Y|Ys],[Y?|Zs?]) :- 
    Y =\= merge(_) |merge(Xs?,Ys?,Zs).
merge([],[],[]).
\end{verbatim}
\end{small}
The program uses the guard \verb|X =\= Y| which succeeds if its two arguments are not unifiable.  Due to the single writer invariant, this can happen only if they have two corresponding writers or two corresponding terms with different functor or arities.

Now any client can send \verb|merge(NewStream)| to dynamically add another stream to the merge network. The spawned \verb|merger| process handles the integration, creating a self-organizing merge tree. This programming technique elegantly combines data messages with control messages in the same stream, enabling fully dynamic client management.




\subsection{Distributing, Replicating, and Observing}

The basic communication mechanism of GLP is point-to-point, via paired variables. Yet, many applications require the efficient sharing of the same piece of data with many others. Here we discuss various methods to achieve that in GLP.

\mypara{Distributing Ground Terms}
A stream of ground terms can be distributed to arbitrarily-many consumers using the following program skeleton:

\Program{Stream Distributor}\label{program:stream-distributor}
\begin{small}
\begin{verbatim}
distribute([X|Xs],[X|Ys1],...,[X|Ysn]) :- ground(X) | distribute(Xs?,Ys1?,...,Ysn?)
distribute([],[],...,[]).
\end{verbatim}
\end{small}

Of course all standard data types typically being distributed---text, photos, audio, video, and their combinations---are ground.

\mypara{Replicating Writer-Free Terms}
We showed above how a stream of ground terms can be distributed. However, it may be sometimes useful to replicate incrementally any incrementally-produced term, not just a stream. The following \verb|replicate| procedure skeleton can do that, provided its input does not contain writable variables. We show this for nested lists. Tuples can be copied similarly by back-and-forth conversion of a tuple into its list of arguments.

\Program{Replicator}\label{program:replicator}
\begin{small}
\begin{verbatim}
replicate(X, X?,..., X?) :- 
    ground(X) | true.                          % Ground terms can be shared
replicate(Xs, [Y1?|Ys1?],..., [Yn?|Ysn?]) :-   % List recursion on both parts
    Xs? = [X|Xs1] |
    replicate(X?, Y1,..., Yn),
    replicate(Xs1?, Ys1,..., Ysn).
\end{verbatim}
\end{small}
Note that \verb|replicate| suspends if its first argument is a reader and fails if it is a writer.

\mypara{Observing Interactions on a Variable Pair}
It may sometimes be useful to observe the interaction between two agents. For example, to audit the interaction of a stateful monitor with its users. As the interactions include messages with variables, neither ground-based distribution nor writer-free replication may work. The next program is a `man-in-the-middle', faithfully forwarding back-and-forth the interactions on a paired variable, while incrementally producing a writer-free replicant that may be further replicated as needed by \verb|replicate|.

\Program{Observer}\label{program:observer}
\begin{small}
\begin{verbatim}
% If the original goal is p(...X....), q(....X?...),  with an observer it would be:
% Goal: p(...X....), observe(X?,Y,Z), q(....Y?...)
observe(X?, Y, Z) :-
    observe(Y?, X, Z).                    % Switching the direction of communication
observe(X, X?, X?) :- 
    ground(X) | true.                     % Ground terms can be shared
observe(Xs, [Y1?|Ys1?], [Y2?|Ys2?]) :-    % Lists - recurse on both parts
    Xs? = [X|Xs1] |
    observe(X?, Y1, Y2),
    observe(Xs1?, Ys1, Ys2).
\end{verbatim}
\end{small}

\subsection{A Stream is a Blockchain; Interlaced Streams a Blocklace}

\mypara{A Stream is a Blockchain}
A blockchain is a growing list of blocks, each cryptographically signed and containing a hash pointer to its predecessor~\cite{nakamoto2008peer}. This structure provides three essential properties: \textbf{integrity} (tampering with any block invalidates all subsequent hash pointers), \textbf{non-repudiation} (each block's signature ties it irrevocably to its creator), and \textbf{acyclicity} (the backward-pointing hash structure prevents circular dependencies).

In GLP, a stream is also a growing list, but with pointers in the opposite direction: streams use forward pointers to future elements through logic variables. When agent $p$ creates stream \verb|[X|Xs]|, the tail \verb|Xs| is a writer that will be bound to the rest of the stream. Still, GLP streams exhibit all blockchain properties:
\begin{enumerate}
    \item \textbf{Non-repudiation}: when an agent creates a stream and shares it through authenticated channels (established via Offer or introduction), recipients know with cryptographic certainty who created each element—the creator cannot deny authorship.
    \item \textbf{Integrity}: once a stream element is bound through a writer variable, it becomes immutable due to the single-assignment property; any tampering would violate this fundamental constraint.
    \item \textbf{Acyclicity}: the single-writer invariant prevents circular dependencies, and the stream's forward-pointing structure ensures strict ordering.
\end{enumerate}
Furthermore, GLP streams are \textbf{equivocation-proof}, as creating a fork would require binding the same tail writer to two different values, which GLP's semantics forbid.

GLP streams derive these properties from the language's logical foundations combined with authenticated communication channels formed with certified agents. Of course for GLP applications to enjoy these property, the implementation  has in turn to be correct, which would employ standard tools such as cryptographic hashing and attestation via trusted execution environment~\cite{shapiro2025glp-implementation}.


Under this correctness assumption, every GLP stream shared between agents is effectively a lightweight, personal blockchain—immutable once written, unforkable by construction, and extensible through cooperative handover rather than competitive consensus, as shown next.

Unlike blockchains where multiple miners compete to extend the chain, GLP streams can be constructed by multiple agents only cooperatively, not competitively. The single-writer invariant means that only one agent can hold the writer for the stream's tail at any given time. However, an agent $p$ can transfer ownership by sharing the tail with another agent $q$. Due to the single-writer invariant, such sharing is exclusive, handing over the ability to extend the stream to $q$ and revoking it from $p$.

Consider agents $p$ and $q$ cooperatively constructing a stream consumed by a third party. The initial goal \verb|consumer(Xs?), p(control(Xs, Next)), q(Next?)| establishes the protocol: \verb|consumer| receives the stream through reader \verb|Xs?|, agent $p$ initially controls the stream tail through the \verb|control(Xs,Next)| term, and agent $q$ awaits its turn via \verb|Next?|.

The \verb|control(Xs,Next)| term encapsulates both the current tail writer \verb|Xs| and the continuation \verb|Next| for transferring control. When agent $p$ receives control, it extends the stream by binding \verb|Xs| to new elements, then transfers control by instantiating \verb|Next| with a new \verb|control| term containing the updated tail. The \verb|Done| variable provides clean synchronization—production completes before handover occurs.

This technique demonstrates exclusive sharing: only one agent holds the tail writer at any time, and control transfers explicitly through the \verb|Next| variable. Each agent can produce multiple elements before handing over, enabling flexible cooperative protocols. The stream grows as \verb|[a,b,c,d,e,...]| with agents taking turns extending it, while the consumer observes the unified result.

\Program{Cooperative Stream Production}\label{program:cooperative-streams}
\begin{small}
\begin{verbatim}
% Initial goal: consumer(Xs?), p(control(Xs, Next)), q(Next?)
% Agent p's code
p(control(Xs,Next)) :-
    p_produce_some_elements(Xs,Xs1,Done),
    handover(Done?,Xs1,Next).
    
handover(done,Xs,control(Xs,Next)).

p_produce_some_elements([a,b,c|Xs],Xs,done).  % Example: p adds a,b,c then signals done
% Agent q's code (symmetric)
q(control(Xs,Next)) :-
    q_produce_some_elements(Xs,Xs1,Done),
    handover(Done?,Xs1,Next).
q_produce_some_elements([d,e|Xs],Xs,done).  % Example: q adds d,e then signals done
\end{verbatim}
\end{small}

This handover mechanism enables cooperative protocols where agents take turns extending a shared stream, or where responsibility for stream extension migrates based on application logic. The key insight is that while competitive extension (as in proof-of-work blockchains) is impossible due to the single-writer constraint, cooperative extension through explicit handover provides a natural mechanism for multi-agent stream construction.


\mypara{Interlaced Streams are a Blocklace}
A blocklace is a partially-ordered generalization of the blockchain where each block contains signed hash pointers to multiple preceding blocks, forming a directed acyclic graph (DAG)~\cite{almeida2024blocklace,keidar2023cordial}. Unlike blockchains that grow competitively, blocklaces are constructed cooperatively by agents adding blocks that reference the most recent blocks they have observed from other agents. This structure maintains blockchain's essential properties—integrity through cryptographic hashing, non-repudiation through digital signatures, and acyclicity through the hash pointer structure—while enabling concurrent block creation. The blocklace has been shown to be a universal Byzantine fault-tolerant CRDT~\cite{almeida2024blocklace}, and serves as the foundation for consensus protocols like Cordial Miners~\cite{keidar2023cordial} and dissemination protocols that achieve eventual visibility despite Byzantine agents.

In GLP, agents that maintain streams that observe each other naturally form a structure, termed \emph{interlaced streams}, that realizes a blocklace much the same way a single GLP stream realizes a blockchain. In the example code below, each agent maintains a stream of blocks, each with a payload and a list of pointers to the most-recent tails (blocklace tips) of the other agents that were changed since its previous block. The \verb|reader(X)| guard predicate provides the key mechanism for identifying fresh tips: it succeeds only for unbound reader variables, allowing agents to detect and reference exactly those stream elements they haven't seen before.


Note that the initial goal implicitly assumes that the replicated input streams are observers.

\Program{Interlaced Streams}\label{program:interlaced-streams}
\begin{small}
\begin{verbatim}
% Three agents maintaining interlaced streams (blocklace)
% Initial goal:
%   p(streams(P_stream, [Q_stream?, R_stream?])),
%   q(streams(Q_stream, [P_stream?, R_stream?])),
%   r(streams(R_stream, [P_stream?, Q_stream?]))

streams(MyStream, Others) :-
    produce_payloads(Payloads),
    interlace(Payloads?, MyStream, [], Others?).

interlace([Payload|Payloads], [block(Payload?,Tips?)|Stream?], PrevTips, Others) :-
    collect_new_tips(Others?, Tips, Others1),  % Collect only fresh tips
    interlace(Payloads?, Stream, Tips?, Others1?).
interlace([], [], _, _).

% Using reader(X) to identify fresh tips not yet incorporated
collect_new_tips([[Block|Bs]|Others], [Block?|Tips?], [Bs?|Others1?]) :-
    reader(Bs) |  % Bs unbound means Block is the current tip
    collect_new_tips(Others?, Tips, Others1).
collect_new_tips([[B|Bs]|Others], Tips?, [[Bs]?|Others1?]) :-
    % Skip B as it's already been referenced
    collect_new_tips([[Bs]?|Others?], Tips, Others1).
collect_new_tips([], [], []).
\end{verbatim}
\end{small}


\subsection{Social Graph and Network Applications}

The communication techniques developed above enable implementation of social network applications where agents form a trust graph through shared variables. Here we show how the social graph can bootstrap through cold calls, and continue growing through introductions among friends of friends.  We also illustrate how GLP can realize three typical social networking applications: (\ia) Direct messaging; (\ib) Feeds-and-followers; and (\ic) Groups.  

\mypara{Bootstrap and Cold Call}
Agents start with no connections and must bootstrap their social graph. Each agent's boot program manages an offers stream for receiving friendship requests:

\Program{Bootstrap an Agent}\label{program:boot}
\begin{small}
\begin{verbatim}
boot(In?,Out,Os?) :- handle_offers(Os?,In?,Out).

handle_offers([attestation(P,Sig,Comm?)|Os],In,Out?) :-
   verify_signature(Sig?,P?),
   respond(Comm,Response),
   handle_offers(Os?,In?,Out).

respond(Comm,Response) :- 
   Response = yes(In,Out?), 
   dm(P?,In?,Out).
respond(Comm,Response) :- 
   Response = no.
\end{verbatim}
\end{small}

When agent \verb|p| wants to connect with agent \verb|q|, it sends \verb|offer(p,Comm)| to \verb|q|'s offers stream. If \verb|q| accepts, they establish bidirectional communication through the variables in term bound to \verb|Comm|. This creates an edge in their social graph.

\mypara{Friend-Mediated Introductions}
Once agents have friends, they can introduce their friends to each other, enabling network growth without cold calls. For agent \verb|r| to introduce friends \verb|p| and \verb|q|, it
creates two fresh variable pairs \verb|(Xpq,Xpq?)| and \verb|(Xqp,Xqp?)| for bidirectional communication. Agent \verb|p| receives writer \verb|Xpq| (to send to \verb|q|) and reader \verb|Xqp?| (to receive from \verb|q|), while \verb|q| gets the two paired variables. This technique allows the social graph to grow through trusted connections.

In a highly-simplified example, in the initial state agent \verb|r| shares variables with  both \verb|p| and \verb|q|, as in the initial goal \verb|r(p,q,Xrp,Xrq) , p(Xrp?), q(Xrq?)|.   All \verb|r| does is introduce  \verb|p| and \verb|q| and terminate.  To do so it creates fresh variable pairs \verb|(Xpq,Xpq?)| and \verb|(Xqp,Xqp?)|. Agent \verb|p| receives writer \verb|Xpq| (to send to \verb|q|) and reader \verb|Xqp?| (to receive from \verb|q|), while \verb|q| gets the complementary pair. Once they do, they establish a bidirectional direct-messaging conversation among them. This show how the social graph can grow through trusted connections, and also illustrates our first social-networking app.

\Program{Friend-Mediated Introduction}\label{program:friendly-introduction}
\begin{small}
\begin{verbatim}
% Agent r introduces p and q
introduce(P,Q,intro(Q?, io(Xqp?, Xpq)),intro(P?, io(Xpq?, Xqp))).

% Agent p receives introduction to q
p(intro(Q,io(In,Out))) :-
    ground(Q) |
    produce_attestation(Q?, Out?, Response_q),     % Produces attestation with Response_q for q-to-p
    receive_attestation(In?, Q?, Response_p),      % Waits for q's attestation, gets Response_p for p-to-q
    dm(Q?, Response_q?, Response_p).               % Use Response_q for receiving, Response_p for sending

% Agent q receives introduction to p  
q(intro(P,io(In,Out))) :- [same or similar code to that of p]
   
produce_attestation(Peer, attestation(Self, Sig, Response), Response?) :-
    % Create attestation with Response writer for receiving from Peer
    sign_module(Sig).

receive_attestation(attestation(Peer?, Sig?, Response), Peer, Response?) :-
    verify_signature(Sig, Peer).
\end{verbatim}
\end{small}
The \verb|ground(Q)| guard is essential to maintain the single-reader invariant, as the  variable \verb|Q?| appears multiple times in the body (in \verb|produce_attestation|, \verb|receive_attestation|, and \verb|dm|). When \verb|Q| is ground (already bound to a constant like a public key), \verb|Q?| simply references this ground value, and multiple references to ground terms are permitted. Thus a guard \verb|ground(X)| enables  multiple occurrences of \verb|X?|, relaxing the  syntactic constraint on single-reader in the body but, due to their value being ground, without the risk of duplicating embedded writers. Hence this relaxation of the single-reader/single-writer syntactic constraint does not result in violating the single-writer invariant.



\mypara{Feeds and Followers}
Social networks enable broadcasting where one agent's feed is followed by many. In traditional systems, this creates challenges around authentication (who really wrote this post?) and privacy (who can see my posts?). GLP's variable-sharing model naturally addresses both concerns.


Beyond the technical mechanism, GLP's communication model provides inherent security properties. When a follower receives a feed, they do so through variables that were explicitly shared during connection establishment—either through an authenticated Offer transaction or a friend-mediated introduction. This means the follower knows with certainty that the feed comes from the specific producer they chose to follow, not an impersonator. Conversely, the producer knows exactly who follows them, as they hold the paired reader variables for each follower.

This represents a fundamental shift from traditional social networks. Rather than requiring cryptographic signatures on each post and maintaining follower lists in databases, GLP's model provides authentication and access control through the very structure of variable sharing. Authentication happens once when the connection is established, not repeatedly for each post.


\begin{small}
\begin{verbatim}
% Agent produces a feed
produce_feed([Post?|Feed?]) :- 
    create_post(Post), produce_feed(Feed).

% Distribute feed to followers using observe
distribute(Feed?,F1,F2,F3) :- observe(Feed?,F1,F2,F3).

% Follower consumes feed
follow(Friend,[Post|Feed]) :- 
    display(Friend?,Post?), follow(Friend?,Feed?).

% Each member launches their own distributor locally
member_join(GroupStreams) :-
    observe(GroupStreams?, LocalObs1, LocalObs2, ...),  % Create local observers
    distribute_to_followers(MyStream, LocalObs1),       % Local distribution
    merger(Requests?, MyStream?, MergedStream),         % Local merger
    process_messages(MergedStream?).                    % Process merged stream
    
\end{verbatim}
\end{small}

\udi{Note: code to e reviewed. if the manager launches the distributor, then members cannot authenticate others.  Only if each member launches their owns distributor they can.  Should revise }

Each group member should launch their own local distributor to maintain direct peer-to-peer authentication. If the manager launched all distributors centrally, all communication would route through the manager, preventing members from directly verifying each other's attestations. The distributed approach ensures that each member can authenticate their peers directly:


\mypara{Group Chat via Interlaced Streams}

In GLP, a group chat can be  realized directly through the interlaced streams program above, without centralized control or distributed consensus. Each agent in the group takes messages from their owner, wraps them in blocks with references to the latest messages they've seen from others, and shares the resulting stream with all group members. The interlaced streams implementation above, with payloads interpreted as chat messages, provides a complete group chat where the blocklace structure naturally maintains causal message ordering without requiring consensus.

Here is a simplified example of a fixed group chat in which agent $p$ initiates a group chat with agents $q$ and $r$ by creating a shared structure for all streams:

\begin{small}
\begin{verbatim}
% Agent p initiates group chat with q and r
% Assumes p already has writers Wq and Wr shared with q and r respectively

p_initiate_group(Wq, Wr, Input_p?) :-
    Is = [Ps, Qs, Rs],  % Structure containing all three streams
    Wq = join_chat(Qs, Is?),  % Send q its stream and observer to structure
    Wr = join_chat(Rs, Is?),  % Send r its stream and observer to structure
    interlace(Input_p?, Ps, Is?).  % p starts with its own stream

% Agent q receives invitation and joins
q_join(join_chat(MyStream, Is?), Input_q?) :-
    interlace(Input_q?, MyStream, Is?).

% Agent r receives invitation and joins (identical)
r_join(join_chat(MyStream, Is?), Input_r?) :-
    interlace(Input_r?, MyStream, Is?).
\end{verbatim}
\end{small}

Each agent receives their designated stream writer and a reader to the shared structure \verb|Is| containing all streams. The \verb|interlace| procedure can then observe all streams through this single shared structure, creating the blocklace.
The program can be extended with a `control stream' to allow the initiator/manager to add and remove members dynamically.


\subsection{Variable Abandonment and Failure Handling}


GLP provides a simple mechanism for handling variable lifecycle through the \verb|abandoned| guard predicate. This mechanism becomes particularly important in the multiagent setting (discussed in Section~\ref{section:multiagent}) where network failures can cause variables to become unreachable.
Logically, a variable is considered \emph{abandoned} when its paired variable no longer occurs in the resolvent. As clauses are syntactically restricted to have variable pairs, except for anonymous variables, only a reduction with a clause that contains an anonymous variable may result in abandonment.

Practically, each agent would maintain a directory of variables shared with other agents, holding a local copy that corresponds to an exported reader or writer. When an agent $p$ determines another agent $q$ to be `dead', any variables that $p$ exported to $q$ (and thus maintains local copies of in its directory) would be locally abandoned by $p$, following which programs that depend on communication with $q$ can handle the consequences using the abandoned guard predicate.

Consider the enhanced merge procedure that uses abandonment for graceful termination:

\begin{small}
\begin{verbatim}
merge(_,_,Zs?) :- abandoned(Zs) | true. % if output abandoned, abandon inputs
merge([X|Xs],Ys,[X?|Zs?]) :- merge(Xs?,Ys?,Zs). % output element of first stream 
merge(Xs,[Y|Ys],[Y?|Zs?]) :- merge(Xs?,Ys?,Zs). % output element of second stream 
merge([],[],[]). % close output stream and terminate 
merge(Xs,Ys,Xs?) :- abandoned(Ys?) | true. % if second input abandoned, pass through first
merge(Xs,Ys,Ys?) :- abandoned(Xs?) | true. % if first input abandoned, pass through second
\end{verbatim}
\end{small}

This creates a clean abstraction where low-level infrastructure failures are transformed into high-level logical events that programs can handle explicitly and gracefully.



\item \textbf{Remove abandoned variables:} For every variable $Y \in \calV$ and agent $q$ such that $(Y, q) \in Shared_p$:
\begin{itemize}
    \item If $Y \in A$ (the reduced goal) and $Y \notin \mathcal{V}_{\sigma?}$ (not instantiated) and $Y \notin B\sigma?$ (not in the new goals), then:
    \begin{itemize}
        \item Remove $(Y, q)$ from $Shared'_p$
        \item Remove $(Y', p)$ from $Shared'_q$ where $(Y, Y')$ or $(Y', Y)$ is the variable pair
    \end{itemize}
\end{itemize}


\subsection{Friend-Mediated Introductions}\label{subsection:friendly-introduction}

The distribution of communication channels in GLP naturally follows real-world social patterns. The most secure and socially natural way for two agents to establish communication is through introduction by a mutual friend, leveraging existing trust relationships rather than requiring cold-call contact.

Consider agents $p$ and $q$ who wish to communicate but have no direct connection. If both are friends with agent $r$, then $r$ can facilitate their introduction by creating fresh communication channels and distributing them appropriately.
In this example, assume that agent $q$ has already communication channels with $p$ and $q$, that their respective names by which $r$ knows them are the strings  \verb|p| and \verb|q|, and the task is for $q$ to create two \verb|introduction| messages sent to $p$ and $q$, introducing one to the other and enabling them to communicate directly, not via $r$.  This is achieved  by the following program, called with \verb|introduce(p,q,Int_q,Int_p)|, following which $r$ sends \verb|Int_q| to $p$ and   \verb|Int_p| to $q$.

\Program{Friend-mediated introduction in \glp}\label{program:introduction}
\begin{small}
\begin{verbatim}
% Agent r facilitates introduction between p and q
introduce(P,Q,introduction(Q, io(Xqp?, Xpq))),introduction(P, io(Xpq?, Xqp))).

% p initiates: sends Wpq to r
send_introduction_request(R, Wpq).

% q responds: sends Wqp as first message 
Wpq := [Wqp|RestPQ].

% p processes: treats Wqp as stream from q
% Now: p->q via RestPQ, q->p via Wqp

\end{verbatim}
\end{small}

With this program, agent $r$ creates two fresh variable pairs: \verb|Xpq| and \verb|Xqp| for bidirectional communication. Agent $p$ receives writer \verb|Xpq| and reader \verb|Xqp?|, while agent $q$ receives writer \verb|Xqp| and reader \verb|Xpq?|. This establishes bidirectional communication where $p$ sends via \verb|Xpq| and receives via \verb|Xqp?|, while $q$ sends via \verb|Xqp| and receives via \verb|Xpq?|.

The recipient (say $q$) can then receive the introduction and begin communicating if it chooses to, using the call \verb|check_and_communicate(Q?,IO?)| in Program \ref{program:ground-term}.

This friend-mediated approach offers several advantages over direct contact: it leverages existing trust relationships, provides implicit reputation through the mutual friend, and avoids the need for complex identity verification protocols. Most importantly, it mirrors natural human social behaviour, allowing GLP to realize grassroots platforms that feel familiar and socially intuitive.

\subsection{Social Networking with GLP}

Here we show how various social-networking functions can be directly realized in GLP.

\mypara{Direct messaging}  Once two agents are friends, they have a bidirectional communication channel (Program \ref{program:introduction}) that can be used (also) for direct messaging. A standard app can acuminulate and present messages similarly to existing apps.

\mypara{Feed with followers}  The example Program~\ref{program:feed-with-followers} shows how a feed of ground posts can be shared with followers.  The program for a follower can be extended to share the feed with a friend upon request.  In the example sharing is unconditional; it could be extended to request the owner's consent.


\Program{Sharing a Feed}\label{program:feed-with-followers}
\begin{small}
\begin{verbatim}

follow(I,[X|Xs],Reqs) :- stare_at(X?), follow(I?,Xs?,Reqs?).

follow(I,Xs,[share(J,Xs?)|Reqs]) :-  follow(I?,Xs?,Reqs?).

\end{verbatim}
\end{small}


\subsection{Program Attestation and Digital Social Contracts}

GLP provides mechanisms for agents to verify that their communication partners are running compatible programs, enabling the implementation of digital social contracts without requiring consensus protocols. This capability builds upon smartphone-level Trusted Execution Environments (TEE) to provide program-level security guarantees~\cite{cardelli2020digital,shapiro2025atomic}.

\mypara{The Challenge of Program Verification}
In consensus-free digital social contracts, there is no protocol-level guarantee that all parties follow the same rules~\cite{shapiro2025GF}. An agent running a social contract program needs assurance that its communication partners are running compatible, rule-abiding programs rather than malicious variants that might violate the contract terms. This differs from consensus-based smart contracts where Byzantine fault tolerance provides protocol-level enforcement~\cite{de2021smart,buterin2014next}.

\mypara{Program Identity and Direct Variable Attachment}
GLP provides built-in predicates for program attestation:

\Program{Program attestation predicates}\label{program:attestation}
\begin{small}
\begin{verbatim}
program_id(Id) :- 
    % Returns unforgeable cryptographic identifier of current program

attest_direct_attachment(SharedVars, Attestation) :-
    program_id(Id),
    % Verifies SharedVars are directly in import/export table
    % with no man-in-the-middle programs mediating access
    verify_no_mitm(SharedVars, Id, Attestation).
\end{verbatim}
\end{small}

The key insight is that GLP's single reader/writer invariant enables the runtime to cryptographically verify that shared variables are directly controlled by the attesting program, with no intermediate programs acting as proxies.

\mypara{Challenge-Response Protocol}
Agents can verify their communication partners using a challenge-response protocol:

\Program{Program verification protocol}\label{program:verification}
\begin{small}
\begin{verbatim}
verify_peer_program(Agent, SharedVars, ExpectedProgram, Result) :-
    random_challenge(Challenge),
    send_message(Agent, verify_request(Challenge, SharedVars)),
    receive_message(Agent, verify_response(Attestation)),
    validate_attestation(Challenge, SharedVars, ExpectedProgram, Attestation, Result).

handle_verify_request(Challenge, SharedVars, Response) :-
    attest_direct_attachment(SharedVars, Attestation),
    program_id(Id),
    sign_response(Challenge, Id, Attestation, Response).
\end{verbatim}
\end{small}

\mypara{Security Model}
The security of program attestation relies on a layered approach:
\begin{enumerate}
    \item \textbf{Smartphone-level TEE}: Verifies that agents are running an authentic GLP runtime application, preventing malicious modifications to the GLP interpreter itself~\cite{googlePlayIntegrity,appleAppAttest,attestAsiaCCS23}.
    \item \textbf{GLP-level attestation}: The authenticated GLP runtime cryptographically signs program identities and variable attachments, creating unforgeable attestations that specific programs control specific variables~\cite{rivest1978method,diffie1976new}.
    \item \textbf{Single reader/writer enforcement}: The core semantic property ensures that no program can act as a hidden intermediary for shared variables, preventing man-in-the-middle attacks within the GLP application.
\end{enumerate}

\mypara{Digital Social Contracts}
This mechanism enables consensus-free digital social contracts where participants can verify that all parties are running compatible rule-enforcement programs~\cite{shapiro2025GF,poupko2021building}:

\Program{Social contract verification}\label{program:social-contract}
\begin{small}
\begin{verbatim}
social_contract_member(Agent, ContractRules, CommVars) :-
    verify_peer_program(Agent, CommVars, ContractRules, verified),
    establish_communication(Agent, CommVars).

social_contract_member(Agent, ContractRules, CommVars) :-
    verify_peer_program(Agent, CommVars, ContractRules, failed),
    refuse_communication(Agent).
\end{verbatim}
\end{small}

Unlike consensus-based approaches where protocol enforcement is guaranteed by Byzantine fault tolerance~\cite{castro1999practical,yin2019hotstuff}, consensus-free social contracts rely on mutual verification and the ability to exclude non-compliant participants. This creates a "vote with your feet" model where participants can choose to join networks that enforce their preferred social contract rules~\cite{shahaf2020genuine,meir2024safe}.

\mypara{Implementation Dependencies}
The security guarantees depend on the underlying smartphone TEE implementation providing authentic program execution environments~\cite{safetynotMobiSys21}. Current smartphone platforms offer varying levels of TEE support through technologies such as ARM TrustZone~\cite{pinto2019demystifying}, Google Play Integrity API~\cite{googlePlayIntegrity}, and Apple App Attest~\cite{appleAppAttest}. The practical deployment of digital social contracts thus depends on the availability and standardization of these hardware security features across the smartphone ecosystem.


\section{Related Work}\label{section:related-work}

\subsection{Concurrent Logic Programming}
% Concurrent Prolog, GHC, Parlog, KLIC
% Focus on why they need distributed unification
% How SRSW avoids this

\subsection{Multiagent Programming Languages}
% Actor languages (Erlang, Akka, Orleans)
% Agent-oriented languages (Jason/AgentSpeak, 3APL, GOAL)
% Why they lack formal multiagent semantics or logic programming

\subsection{Formal Models of Distributed Systems}
% Process calculi (π-calculus, applied π-calculus)
% Specification languages (TLA+, I/O Automata)
% Why they're not executable programming languages

\subsection{Distributed Logic Programming}
% Various systems (distributed Prolog variants, Mozart/Oz)
% Tuple spaces and blackboard systems
% Why they require central coordination

\subsection{Grassroots Protocols}
% Your prior work on grassroots protocols
% How GLP implements this formally

\section{Conclusion}\label{section:conclusions} 

\bibliography{bib}

\appendix


\section{GLP Syntax}\label{appendix:syntax}

The syntax of GLP follows the standard in logic and concurrent logic programming, extended with reader/writer variable pairs to enable secure multiagent communication.

\begin{definition}[GLP Syntax]\label{definition:syntax}
The syntax of \glp is defined thus:
\begin{itemize}
    \item A \temph{variable name} (\temph{variable}, for short) is an alphanumeric string beginning with uppercase letter, e.g. \verb|X, X1, Xs|. If suffixed with \verb|?| it is referred to as a \temph{reader}, else \temph{writer}.
  We use $V/V?$ to denote the disjoint sets of all readers/writers, respectively, with $\calV := V \cup V?$, define bijections $?: \calV \xrightarrow{} \calV?$ by
 $?(X) := X?$ for every $X \in V$, and refer to $(X?, X)$ as a \temph{reader/writer pair} or just \temph{pair}.
    
    \item A \temph{constant} is a string beginning with a lowercase letter, e.g. a, a1, and foo, as well as any quoted string, e.g. \verb|","| and \verb|"X"|.
    
    \item A \temph{number} is a numeric string, which may include a decimal point, e.g. 0, 1, 103.65.
    
    \item A \temph{grassroots logic term}, or \temph{term} for short is a variable in $\calV$, a constant, a number, as well as a \temph{composite term}, or \temph{n-ary term} of the form $f(T_1,T_2,\ldots,T_n)$, $n \ge 1$, where $f$ is a constant and each $T_i$ is a term, $i \in [n]$, referred to as a \temph{subterm} of $T$.
    \item A term $T$ \temph{occurs} in term $T'$, denoted $T \in T'$, if $T=T'$ or if $T'$ is an $n$-ary term
    $f(T_1,T_2,\ldots,T_n)$ for some constant $f$ and $T$ occurs in $T_i$ for some $i \in [n]$. A term is \temph{ground} if it contains no variables, namely $X \notin T$ for any $X \in \calV$. 

    \item \temph{Lists:} By convention the constant \verb|[]| (read ``nil'') represents an empty list, the binary term \verb=[X|Xs]= represents a (linked) list with the first element \verb|X| and (a link to the) rest \verb|Xs|, the term \verb|[X]| is a shorthand for \verb=[X|[]]= and the term \verb=[X1,X2,... Xn]= is a shorthand for the nested term \verb=[X1|[X2|[X3|... [Xn|[]]... ]]]=. 
    
    \item An \temph{atom} is a constant or a composite term.
    
    \item A \temph{goal} is a term of the form $a_1, a_2,\ldots a_n$, $n\ge 0$, where each $a_i$ is an atom, $i \in [n]$. Such a goal is \temph{empty} if $n=0$, in which case it may also be written as \verb|true|, \temph{atomic} if $n=1$, and \temph{conjunctive} if $n \ge 2$. A conjunctive goal can be written equivalently as $(a_1,(a_2,(\ldots a_n)\ldots))$, where $(a,b)$ is a shorthand for \verb|","|$(a,b)$, and can also be viewed as a set as the order of atoms in a conjunctive goal is immaterial. Let $\calG$ be the set of all goals.

     \item A \temph{clause} is a term of the form $A$ \verb|:-| $B$ (read `$A$ if $B$'), where $A$ is an atom, referred to as the clause's \temph{head}, and $B$ is a (possibly empty) goal, referred to as the clause's \temph{body}. If $B$ is empty then the clause is called \temph{unit} and can be written simply as $A$. A clause may include reader/writer pairs, e.g. \verb|X?| and \verb|X|, each of them occurring exactly once, and any number of don't-care variables \verb|_|. The underscore symbol \verb|_| is a \emph{don't-care variable} that stands for a writer occurring only once, which can be bound to any value that subsequently cannot be read.
    
    \item A \temph{grassroots logic program}, or \emph{program} for short, is a finite sequences of ``.''-separated clauses.
  As a convention, clauses for the same predicate (name and arity) are grouped together and are referred to as the \temph{procedure} for that predicate.
\end{itemize}
\end{definition}


Logically, a clause $A$\verb|:-| $B$ is a universally-quantified implication in which $B$ implies $A$.  A program is a conjunction of its clauses.

\remove{ you have placed the following in the synatx section, but its not part of the program syntax.  It is a metalevel construct.  furthermore, we have yet to introduce agents.  So keep it for later:
\mypara{Utterances} An \emph{utterance} in GLP has the form $(X:=T)_p$, indicating the assigned \emph{writer} $X$ -- a single-assignment logic variable, the assigned value $T$ -- a logic term that in turn may contain writers and/or \emph{readers} (logic variables from which a value can only be read), and the agent making the utterance $p$ --- identified by its public key and cryptographically-signing the assignment $X:=T$ with its private key, and thus producing the string specified by $(X:=T)_p$.}


\end{document}




\section{OLD Introduction}

\subsection{Grassroots Platforms}

Grassroots platforms aim to offer an egalitarian alternative to global platforms---centralized/autocratic (Facebook etc.) and decentralized/plutocratic (Bitcoin etc.) alike. Whereas global platforms can have only a single instance---one Facebook, one Bitcoin---grassroots platforms can have multiple instances that emerge and operate independently of each other and of any global resource except the network, and can interoperate and coalesce into ever-larger instances once interconnected, potentially (but not necessarily) forming a single instance.

Global platforms can only have a single instance as two instances would clash over the global resources they utilize---domain name, port number, or boot nodes, which are hardwired into their code. Whether it is possible to modify their code (`hard-fork') to create non-conflicting instances, such forked instances would ignore, rather than interoperate with, the primary instance.

Grassroots platforms, in contrast, can have multiple instances that emerge and operate independently of each other and of any global resource except the network, yet can interoperate and coalesce once interconnected, forming ever-larger platform instances, potentially (but not necessarily) coalescing into a single instance.

Key grassroots platforms include grassroots social networks, grassroots cryptocurrencies, and grassroots federations.

\subsection{Digital Social Contracts}

Digital social contracts were proposed as voluntary agreements among free individuals, specified, undertaken, and fulfilled in the digital realm~\cite{cardelli2020digital}. The concept builds upon Proudhon's 1851 notion of the social contract---a voluntary agreement that does not require individuals to surrender sovereignty to another~\cite{proudhon2004general}. Since then, considerable understanding has developed regarding their implementation and relationship to existing blockchain-based approaches~\cite{shapiro2025atomic,shapiro2025GF}.

\mypara{Consensus-based digital social contracts versus smart contracts} Consensus-based digital social contracts are the sovereign counterpart of smart contracts~\cite{buterin2014next,de2021smart}. While smart contracts operate among anonymous accounts and rely on consensus protocols executed by third-party miners~\cite{buterin2014next,de2021smart}, digital social contracts operate among known individuals and can employ consensus protocols executed by the participants themselves~\cite{lewis2024grassrootsconsensus}.  Hence, consensus-based social contracts enable the egalitarian and autonomous democratic operation of digital communities, without dependence on third-party miners~\cite{shahaf2020genuine}. See Table~\ref{table:contracts}~\cite{keidar2025grassroots}.

\begin{table}[!ht]
  \caption{Comparing Consensus-Based Smart Contracts and Social Contracts} 
  \label{table:contracts}
  \begin{center} 
 \begin{tabular}{ | m{6.5em} | m{15em}| m{15em} | } 
    \hline
     & \textbf{Smart Contract}~\cite{de2021smart} 
 &  \textbf{Digital Social Contract}~\cite{cardelli2020digital} 
\\
     \hline
    \hline
     \textbf{Among:} &  Accounts  &  People \\
    
    \hline
    \textbf{Executed by:} & Third-party servers & The people's smartphones \\
 \hline
  \textbf{In return for:} & Gas & Love \\
 \hline

 
 \textbf{Applications:} & Decentralized Finance (DeFi)~\cite{schueffel2021defi,jensen2021introduction},\newline Decentralized Autonomous Organizations (DAOs)~\cite{ethereum:dao,ding2023survey},\newline  Non-Fungible Tokens (NFTs)~\cite{wang2021non} & 
 Grassroots democratic digital communities~\cite{poupko2021building,shahaf2020genuine} and their federation~\cite{shapiro2025atomic,shapiro2025GF},\newline community banks and digital cooperatives~\cite{shapiro2024gc}  \\
 \hline
 
 \textbf{Amended via:} & Self-modifying code & Constitutional decisions~\cite{shapiro2024constitutional}  \\
 \hline  
  \end{tabular}
  \end{center}
\end{table}

\mypara{Consensus-free digital social contracts} Unlike smart contracts, the fundamental concept of digital social contracts does not depend on consensus~\cite{cardelli2020digital} (though consensus remains necessary for key applications, first and foremost the democratic governance of digital communities~\cite{shapiro2025GF}). There are many useful social contracts that do not need enforcement by consensus---it suffices that all parties abide by the agreed rules and can verify each other's compliance.

This mutual-verification capability can be realised with Trusted Execution Environments (TEEs) available on modern smartphones~\cite{googlePlayIntegrity,appleAppAttest,pinto2019demystifying,safetynotMobiSys21}. Since agents are cryptographically identified, TEE attestation enables participants to verify that their communication partners are running compatible rule-abiding applications~\cite{attestAsiaCCS23}. When someone's application is compromised---volitionally, due to a malicious attack, or by accident---and violates the contract rules, other participants can simply refuse to communicate with them---effectively implementing a `vote with your feet' model~\cite{tiebout1956pure}.

\mypara{Social contracts for grassroots social networks} This approach enables any programmable policy for ownership, copyright, privacy, remuneration, disputes, or penalties to be embedded in a digital social contract for a grassroots social network~\cite{shapiro2023gsn}. Grassroots social networks exemplify this by addressing fundamental problems that plague current platforms: spam resistance through communication only among trusted friends~\cite{douceur2002sybil}, accountability for libel through cryptographically verifiable authorship~\cite{mason2012legal}, deep fake detection by requiring trusted provenance chains~\cite{li2020celeb}, and trust-based filtering that limits exposure to malicious content~\cite{golbeck2005computing}. The question becomes what social contract people want in the network they join, resolved through choice rather than consensus.

\mypara{Social contracts as the foundation for grassroots platforms} Any grassroots platform of interest should be based on a social contract---whether consensus-based for applications requiring coordination~\cite{keidar2021need}, or consensus-free for applications where mutual verification suffices~\cite{shapiro2023gsn}. Grassroots social networks exemplify consensus-free social contracts~\cite{shapiro2023gsn}, but the concept extends to any distributed application where participants only want assurance of mutual rule compliance, and there is no need for consensus on the ordering of their actions~\cite{lamport1978time}.


\mypara{Futures and promises}
Much progress has been made during the last decade in functional and actors-based distributed programming for the cloud---a global platform with centralised control---including Function-as-a-Service (FaaS)~\cite{castro2019rise,eashwaran2022serverless,epstein2011towards}, Active Objects~\cite{boer2017survey,spenger2024survey}, and more~\cite{boer2024active,ferreira2020programming}. A common thread that ties actors, concurrent functional programming and concurrent logic programming is the notions of \emph{futures} and \emph{promises}~\cite{haller2012futures,dauth2019futures,azadbakht2020formal,schwinghammer2002concurrent}. In actors it is manifest in waiting for callbacks from object calls, in functional programming in waiting for arguments to return from function evaluation, and in concurrent logic programming in waiting for shared logic variables to be instantiated.


\mypara{Logic programming foundations}
GLP is a concurrent logic programming language, in that its syntax and operational semantics are derived from (pure, nondeterministic) logic programs~\cite{lloyd1987foundations}. As an example, we recall the quintessential logic (and Prolog) program for appending one list \verb|Xs| (the standard nomenclature for lists uses the variable name \verb|Xs| for a plurality ``\verb|X|''s) to another \verb|Ys|, producing a third \verb|Zs|. A standard logic programming notation, the term \verb=[X|Xs]= encodes a list with the first element \verb|X| and rest \verb|Xs|, and \verb|[]| (read `nil') stands for the empty list.

\Program{Logic program for appending two lists into a third}\label{program:append}
\begin{small}
\begin{verbatim}
append([X|Xs],Ys,[X|Zs]) :- append(Xs,Ys,Zs).
append([],Ys,Ys). 
\end{verbatim}
\end{small}
We note that this nondeterministic logic program can be used to append two given lists into a third, to check that given three lists, appending two gives a third, or to split a given third list nondeterministically into its prefix and a suffix.


\mypara{Paired reader/writer variables for communication and synchronization}
Grassroots logic programs enhance logic programs with syntactic extensions and operational-semantics restrictions that cater for concurrency, communication, and synchronization. Similarly to a logic program, a grassroots logic program is a finite set of universally-quantified implications of the form $A \leftarrow B$, referred to as \emph{clauses}, with the left hand side, referred to as the clause's \emph{head}, being a predicate symbol with logic terms as arguments. The right-hand-side of the clause being a (possibly-empty) conjunction of atoms, referred to as its \emph{body}.

In order to facilitate communication and synchronisation, and as in Concurrent Prolog~\cite{shapiro1983subset}, GLP employs \emph{read-only variables}, or \emph{readers} for short, written as \verb|X?| and \emph{write-once variables}, \emph{writers} for short written without such a suffix. Functionally, a reader is similar to a \emph{future} and a writer to a \emph{promise} in other concurrent programming languages~\cite{haller2012futures,dauth2019futures}, and similarly to futures and promises, a corresponding reader and writer are referred to as a \emph{pair}. When an agent instantiates a writer \verb|X| to term \verb|T|, this variable binding is communicated to the agent holding the paired reader \verb|X?| .

Here is the quintessential concurrent logic program for merging two streams (potentially open-ended lists) into a third, employing reader/writer pairs.

\Program{GLP Stream Merger}\label{program:merge}
\begin{small}
\begin{verbatim}
merge([X|Xs],Ys,[X?|Zs?]) :- merge(Xs?,Ys?,Zs). % output element of first stream 
merge(Xs,[Y|Ys],[Y?|Zs?]) :- merge(Xs?,Ys?,Zs). % output element of second stream 
merge([],[],[]). % close output stream and terminate 
\end{verbatim}
\end{small}
We note that the program can be optimised to terminate as soon as one of the streams ends, replacing the third clause by:
\begin{small}
\begin{verbatim}
merge(Xs,[],Xs?). % identify output stream with first input stream and terminate 
merge([],Ys,Ys?). % identify output stream with second input stream and terminate 
\end{verbatim}
\end{small}

\mypara{The Single-Reader/Single-Writer (SRSW) Invariant}
%
Correct GLP executions uphold the \emph{single-writer requirement}: Any writer has at most one occurrence. This requirement on writers implies also a restriction on readers: If there are several occurrences of a reader \verb|X?|, and the writer \verb|X| is instantiated to a term that contains a new writer \verb|Y|, all occurrences of \verb|X?| will also include a copy of \verb|Y|, violating the single-writer requirement. Therefore the single-writer requirement gives rise to the \emph{Single-Reader/Single-Writer (SRSW) invariant}, which configurations of GLP must satisfy.

By restricting each writer variable to exactly one occurrence and pairing it with a single reader, GLP eschews the need for general unification—a complex operation requiring sophisticated distributed algorithms in multiagent settings~\cite{kleinman1990distributed}. This restriction enables efficient distributed implementation where variable bindings can be communicated directly between paired agents without locking protocols or consensus mechanisms. While this prevents certain programming patterns that depend on competitive instantiation of shared variables (such as those used for mutual exclusion in Concurrent Prolog), it preserves all essential concurrent programming techniques needed for grassroots applications while dramatically simplifying the runtime system.

A simple syntactic restriction on GLP clauses ensures this invariant holds during execution: \emph{At most one occurrence per writer or reader per clause}, a restriction that can be easily verified at compile-time. As we prove in Proposition~\ref{proposition:single-reader-writer-invariant}, this syntactic restriction ensures the invariant is maintained throughout distributed execution.


GLP being single-writer eschews the need for its runtime execution mechanism to realise general unification among arbitrary terms, as needed by Prolog, Concurrent Prolog, and some other logic programming languages~\cite{kleinman1990distributed}. In particular, the single-writer syntactic restriction excludes the standard logic program definition of the equality predicate, for which the call $T=T'$ with two arbitrary terms $T$ and $T'$ entails their general unification:

\begin{small}
\begin{verbatim}
X=X.
\end{verbatim}
\end{small}
The reason it cannot be a GLP program is that it has two occurrences of the writer \verb|X|. The most one can do in GLP is employ the following definition of $=$:
\begin{small}
\begin{verbatim}
X?=X.
\end{verbatim}
\end{small}
With this definition, the goal $T=T'$ will in effect test that $T$ is an uninstantiated writer and if so assign it to $T'$; else fail.
This theoretically-motivated code example should be used sparingly in practice, for two reasons: (\ia) It is inefficient to spawn a process just to do an assignment; it would be handled more efficiently by the caller, and (\ib) good programming practice is to handle failure within the program, as shown in examples below, and not just let a goal such as $T=T'$ fail.


The single-writer property of GLP eschews the need for distributed atomic unification, as required by Concurrent Prolog~\cite{kleinman1990distributed}. In particular, the single-writer syntactic restriction excludes the standard logic program definition of the equality predicate, for which the call $T=T'$ with two arbitrary terms $T$ and $T'$ entails their general unification:

\begin{small}
\begin{verbatim}
X=X.
\end{verbatim}
\end{small}
The reason it cannot be a GLP program is that it has two occurrences of the writer \verb|X|. The most one can do in GLP is employ the following definition of $=$:
\begin{small}
\begin{verbatim}
X?=X.
\end{verbatim}
\end{small}
With this definition, the goal $T=T'$ will in effect test that $T$ is an uninstantiated writer and if so assign it to $T'$; else fail.
This theoretically-motivated code example should be used sparingly in practice, for two reasons: (\ia) It is inefficient to spawn a process just to do an assignment; it would be handled more efficiently by the caller, and (\ib) good programming practice is to handle failure within the program, as shown in examples below, and not just let a goal such as $T=T'$ fail.

The single-writer property makes GLP's distributed implementation much simpler while preserving the essential programming methods needed for concurrent and distributed applications, as demonstrated by the example GLP programs below.\footnote{While Concurrent Prolog~\cite{shapiro1983subset} employed read-only and write-once variables, it did not require this invariant. Hence, on the one hand, it enabled more powerful programming techniques that depend on multiple processes aiming to instantiate the same write-once variable competitively (e.g. to realise mutual exclusion). On the other hand, its distributed implementation was necessarily much more complex, as each transition involved an atomic transaction potentially requiring the locking of multiple variables~\cite{kleinman1990distributed}.}




GLP being single-writer eschews the need for its runtime execution mechanism to realise general unification among arbitrary terms, as needed by Prolog, Concurrent Prolog, and some other logic programming languages~\cite{kleinman1990distributed}. In particular, the single-writer syntactic restriction excludes the standard logic program definition of the equality predicate, for which the call $T=T'$ with two arbitrary terms $T$ and $T'$ entails their general unification:

\begin{small}
\begin{verbatim}
X=X.
\end{verbatim}
\end{small}
The reason it cannot be a GLP program is that it has two occurrences of the writer \verb|X|. The most one can do in GLP is employ the following definition of $=$:
\begin{small}
\begin{verbatim}
X?=X.
\end{verbatim}
\end{small}
With this definition, the goal $T=T'$ will in effect test that $T$ is an uninstantiated writer and if so assign it to $T'$; else fail.



This design choice aligns with recent work on session types~\cite{honda2008multiparty} and linear logic programming~\cite{hodas1994logic}, where resources (in our case, variables) have exactly one consumer. However, unlike session types which enforce protocols statically, GLP's SRSW invariant is maintained dynamically through the operational semantics, and unlike linear logic which focuses on resource consumption, GLP uses the invariant to establish secure communication channels between distributed agents.
