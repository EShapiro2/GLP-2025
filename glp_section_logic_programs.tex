%==============================================================================
\section{Logic Programs}
\label{sec:lp}
%==============================================================================

We recall standard Logic Programs (LP): syntax, most-general unifier (mgu), and operational semantics via nondeterministic goal/clause reduction.

%------------------------------------------------------------------------------
\subsection{Syntax}
\label{sec:lp-syntax}
%------------------------------------------------------------------------------

We employ the standard LP notions of variables, constants, terms, clauses, procedures, and programs.

\begin{definition}[Logic Programs Syntax]
\label{def:lp-syntax}
We employ standard LP notions. Let $\calV$ denote the set of \temph{variables} (identifiers beginning with uppercase). A \temph{term} is a variable, a constant (numbers, strings, or the empty list \verb|[]|), or a compound term $f(T_1,\ldots,T_n)$ with functor $f$ and subterms $T_i$. Let $\calT$ denote the set of all terms. We use standard list notation: \verb=[X|Xs]= for a list cell, \verb|[X1,...,Xn]| for finite lists. A term is \temph{ground} if it contains no variables.

A \temph{unit goal} is a compound term, also commonly referred to as an \temph{atom}. A \temph{goal} is a multiset of unit goals; the empty goal is written \verb|true|. A \temph{clause} $A$~\verb|:-|~$B$ has head $A$ (a unit goal) and body $B$ (a goal); a \temph{unit clause} has empty body. A \temph{logic program} is a finite set of clauses; clauses for the same predicate form a \temph{procedure}. Let $\calG(P)$ denote the set of goals over program $P$.
\end{definition}

\begin{example}[Append]
The quintessential logic program for list concatenation is the following procedure, which has two clauses:
\begin{verbatim}
append([X|Xs], Ys, [X|Zs]) :- append(Xs, Ys, Zs).
append([], Ys, Ys).
\end{verbatim}
Logically, a clause $A$ \verb|:-| $B$ is a universally-quantified implication in which $B$ implies $A$, and a program is a conjunction of its clauses.
By convention, we use plural variable names like \verb|Xs| to denote a list of \verb|X|'s.
\end{example}

%------------------------------------------------------------------------------
\subsection{Operational Semantics}
\label{sec:lp-operational}
%------------------------------------------------------------------------------

A \emph{substitution} $\sigma$ is an idempotent function $\sigma: \calV \to \calT$, namely a mapping from variables to terms applied to a fixed point. By convention, $\sigma(x)=x\sigma$. Let $\Sigma$ denote the set of all substitutions. We assume the standard notions of instance, ground, renaming, renaming apart, unifier, and most-general unifier (mgu). We assume a fixed renaming-apart function, so that the result of renaming $T'$ apart from $T$ is well defined.

\begin{remark}[Substitution as Assignment Set]
We view a substitution $\sigma$ equivalently as a set of assignments $\{X_1:=T_1, \ldots, X_n:=T_n\}$ where $X_i\sigma = T_i$ and $T_i=T_i\sigma$. Thus the singleton substitution mapping $X$ to $T$ is $\{X:=T\}$, its application $T\sigma$ may be written $T\{X:=T\}$, the empty substitution is $\emptyset$, and composition of commutative substitutions corresponds to set union.
\end{remark}

\begin{definition}[LP Goal/Clause Reduction]
\label{def:lp-reduction}
Given an LP unit goal $A$ and clause $C$, with $H$ \verb|:-| $B$ being the result of renaming $C$ apart from $A$, the \temph{LP reduction} of $A$ with $C$ \temph{succeeds with} $(B,\sigma)$ if $A$ and $H$ have an mgu $\sigma$.
\end{definition}

We define the operational semantics of LP via transition systems (Definition~\ref{definition:ts}). In the context of LP, states are called \emph{configurations} or \emph{resolvents}---the latter as a tribute to resolution theorem proving~\cite{robinson1965machine}, the intellectual ancestor of logic programming.

\begin{definition}[Logic Programs Transition System]
\label{def:lp-ts}
A transition system $LP(P) = (C, c_0, T)$ is a \temph{Logic Programs transition system} for a logic program $P$ and initial goal $G_0 \in \mathcal{G}(P)$, if $C=\mathcal{G}(P)\times \Sigma$, $c_0=(G_0,\emptyset)$, and $T$ is the set of all transitions $(G,\sigma) \rightarrow (G',\sigma') \in (\mathcal{G}(P)\times \Sigma)^2$ such that for some unit goal $A \in G$ and clause $C \in P$ the LP reduction of $A$ with $C$ succeeds with $(B,\hat\sigma)$, $G' = (G \setminus \{A\} \cup B)\hat\sigma$, and $\sigma'=\sigma\circ\hat\sigma$.
\end{definition}

Logic Programs have two forms of nondeterminism: the choice of $A\in G$, called \emph{and-nondeterminism}, and the choice of $C\in P$, called \emph{or-nondeterminism}.

The following notion of a proper run ensures that variable names are not re-used; in implementation terms this is an assumption on the integrity of the memory-management/garbage-collection system.

\begin{definition}[Proper and Successful Run, Outcome]
\label{def:proper-run}
A run $\rho: (G_0,\sigma_0) \rightarrow \cdots \rightarrow (G_n, \sigma_n)$ of $LP(P)$ is \temph{proper} if for any $1\le i< n$, a variable that occurs in $G_{i+1}$ but not in $G_i$ also does not occur in any $G_j$, $j<i$. If proper, the \temph{outcome} of $\rho$ is $(G_0$ \verb|:-| $G_n)\sigma_n$. Such a run is \temph{successful} if $G_n=\emptyset$.
\end{definition}

The following proposition justifies calling a proper LP run a \emph{derivation}, and a complete proper run ending in the empty goal a \emph{successful derivation}.

\begin{proposition}[LP Computation is Deduction]
\label{prop:lp-deduction}
The outcome $(G_0$ \verb|:-| $G_n)\sigma$ of a proper run $\rho: (G_0,\sigma_0) \rightarrow \cdots \rightarrow (G_n, \sigma_n)$ of $LP(P)$ is a logical consequence of $P$.
\end{proposition}

\begin{proof}
By induction on the length $n$ of the run.

\emph{Base case} ($n=0$): The outcome is $(G_0 \mathrel{\mbox{\texttt{:-}}} G_0)\emptyset = (G_0 \mathrel{\mbox{\texttt{:-}}} G_0)$, which is the tautology $G_0 \Leftarrow G_0$.

\emph{Inductive step}: Suppose the proposition holds for runs of length $n-1$. Consider a run of length $n$ with final transition $(G_{n-1}, \sigma_{n-1}) \rightarrow (G_n, \sigma_n)$. By definition, there exist unit goal $A \in G_{n-1}$ and clause $C = (H \mathrel{\mbox{\texttt{:-}}} B) \in P$ (renamed apart) such that $A$ and $H$ have mgu $\hat\sigma$, $G_n = (G_{n-1} \setminus \{A\} \cup B)\hat\sigma$, and $\sigma_n = \sigma_{n-1} \circ \hat\sigma$.

The clause $C$, being universally quantified, entails the instance $(H \mathrel{\mbox{\texttt{:-}}} B)\hat\sigma$, i.e., $H\hat\sigma \Leftarrow B\hat\sigma$. Since $A\hat\sigma = H\hat\sigma$ (by unification), we have $A\hat\sigma \Leftarrow B\hat\sigma$.

By the inductive hypothesis, the prefix run has outcome $(G_0 \mathrel{\mbox{\texttt{:-}}} G_{n-1})\sigma_{n-1}$, a logical consequence of $P$. Applying $\hat\sigma$ and substituting $A\hat\sigma$ with $B\hat\sigma$ (justified by the clause instance), we obtain $(G_0 \mathrel{\mbox{\texttt{:-}}} G_n)\sigma_n$, also a logical consequence of $P$.
\end{proof}
