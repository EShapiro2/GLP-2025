
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
\nolinenumbers
%\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate,anonymous]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\usepackage{graphicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{pifont}
\usepackage{xspace}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{lineno}
\usepackage{thmtools}
\usepackage{thm-restate}
\usepackage{relsize}
\usepackage{hhline}% http://ctan.org/pkg/hhline
\usepackage{etoolbox}
\usepackage{thmtools}
\usepackage{thm-restate}
%\usepackage[hidelinks]{hyperref}
\usepackage{cleveref}
\usepackage[most]{tcolorbox}
\usepackage{multicol}
\usepackage{changepage}
% \usepackage{geometry}
\usepackage{algpseudocode}
% \usepackage[parfill]{parskip}
\usepackage{hhline}
\usepackage{etoolbox}
\usepackage{relsize}
\usepackage{bm}
\usepackage{scalefnt}
% \usepackage{lineno}
% \linenumbers
% \usepackage[nodisplayskipstretch]{setspace}
% \setstretch{1.5}

\usepackage{wrapfig}

% llncs hardcodes the spacing for theorem-like environments
%\patchcmd{\@spthm}
%  {\topsep 7\p@ \@plus 2\p@ \@minus 4\p@}
%  {\topsep\spthmsep}
%  {}{}
%\makeatother
%\newlength\spthmsep
%\setlength{\spthmsep}{0pt plus 0pt minus 0pt} % the standard value

%\newenvironment{definitions}
% {\par\vspace{\spthmsep}\begingroup
%  \setlength{\spthmsep}{0pt}}
% {\endgroup\vspace{\spthmsep}}




% \setlength{\abovecaptionskip}{1ex}
% \setlength{\belowcaptionskip}{1ex}
% \setlength{\floatsep}{1ex}
% \setlength{\textfloatsep}{1ex}

\newenvironment{changemargin}[2]{%
\begin{list}{}{%
\setlength{\topsep}{0pt}%
\setlength{\leftmargin}{#1}%
\setlength{\rightmargin}{#2}%
\setlength{\listparindent}{\parindent}%
\setlength{\itemindent}{\parindent}%
\setlength{\parsep}{\parskip}%
}%
\item[]}{\end{list}}

% \newenvironment{changemargin}[1]{
%   \begin{list}{}{
%     \setlength{\voffset}{#1}
%   }
%   \item[]}{\end{list}}

%\newtheorem{remark}[theorem]{Remark}

%\declaretheorem[name=\textbf{Observation}]{observation}


\setlist[description]{leftmargin=*,labelindent=*}

\newcommand{\alglinenoNew}[1]{\newcounter{ALG@line@#1}}
\newcommand{\alglinenoPop}[1]{\setcounter{ALG@line}{\value{ALG@line@#1}}}
\newcommand{\alglinenoPush}[1]{\setcounter{ALG@line@#1}{\value{ALG@line}}}



\newcommand{\mypara}[1]{\smallskip\noindent\textbf{#1.}}


\newcommand{\ia}{\textit{i}}
\newcommand{\ib}{\textit{ii}}
\newcommand{\ic}{\textit{iii}}
\newcommand{\id}{\textit{iv}}
\newcommand{\iie}{\textit{v}}
\newcommand{\iif}{\textit{vi}}



\newcommand{\com}[1]{}

%Algorithmicx
\algdef{SE}[Receiving]{Receiving}{EndReceiving}[1]{\textbf{upon
		receiving}\ #1\ \algorithmicdo}{\algorithmicend\ \textbf{}}%
\algtext*{EndReceiving}

\algdef{SE}[Upon]{Upon}{EndUpon}[1]{\textbf{upon}\ #1\ \algorithmicdo}{\algorithmicend\ \textbf{}}%
\algtext*{EndUpon}

\newcommand\StateX{\Statex\hspace{\algorithmicindent}}
\newcommand\StateXX{\StateX\hspace{\algorithmicindent}}
\algrenewcommand\textproc{}% Used to be \textsc


\newcommand{\oded}[1]{\textcolor{red}{[Oded: #1]}}
% \newcommand{\oded}[1]{}
\newcommand{\udi}[1]{\textcolor{blue}{[Udi says: #1]}}
% \newcommand{\udi}[1]{}
\newcommand{\idit}[1]{\textcolor{orange}{Idit says: #1}}

\newcommand{\andy}[1]{\textcolor{purple}{Andy says: #1}}

\newcommand{\temph}[1]{\textbf{#1}}
%\newcommand{\temph}[1]{\emph{#1}}


\makeatletter \let\sv@thm\@thm \def\@thm{\let\indent\relax\sv@thm} \makeatother

\newcommand{\calR}{\mathbb{R}}
\newcommand{\calCS}{\mathcal{CS}}
\newcommand{\calH}{\mathcal{H}}
\newcommand{\calN}{\mathbb{N}}
\newcommand{\calA}{\mathcal{A}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\calS}{\mathcal{S}}
\newcommand{\calL}{\mathcal{L}}
\newcommand{\calP}{\mathcal{P}}
\newcommand{\calM}{\mathcal{M}}
\newcommand{\calT}{\mathcal{T}}
\newcommand{\calE}{\mathcal{E}}
\newcommand{\calB}{\mathcal{B}}
\newcommand{\calC}{\mathcal{C}}
\newcommand{\calX}{\mathcal{X}}
\newcommand{\calD}{\mathcal{D}}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calG}{\mathcal{G}}


\newcommand{\NN}{\mathbb{N}}
\newcommand{\PP}{P}

\newcommand{\change}[1]{\textcolor{blue}{#1}}

\crefname{table}{table}{tables}
\crefname{table}{Table}{Tables}
\crefname{algocf}{alg.}{algs.}
\crefname{algocf}{Alg.}{Algs.}
\crefname{figure}{Fig.}{Figs.}
\crefname{figure}{fig.}{figs.}
\crefname{claim}{claim}{claims}
\crefname{claim}{Claim}{Claims}
\crefformat{chapter}{\S#2#1#3}
\crefmultiformat{chapter}{\S\S#2#1#3}{and~#2#1#3}{, #2#1#3}{, and~#2#1#3}

\crefformat{section}{\S#2#1#3}
\crefmultiformat{section}{\S\S#2#1#3}{and~#2#1#3}{, #2#1#3}{, and~#2#1#3}

% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
%\usepackage{color}
%\renewcommand\UrlFont{\color{blue}\rmfamily}
%

% Shrink space around enumerate and itemize
% From: http://tex.stackexchange.com/questions/10684/vertical-space-in-lists
\usepackage{enumitem}
% Set it globally:
\setlist{nosep} % or \setlist{noitemsep} to leave space around whole list
\setlist{itemsep=1pt, topsep=3pt}

% Less space around titles.
% From: http://tex.stackexchange.com/questions/4999/change-whitespace-above-and-below-a-section-heading
% \usepackage[medium,compact]{titlesec}
%\usepackage{titlesec}
%\titlespacing*{\section}{0pt}{*1}{*1}

% % Shrink space around figures.
% % This beats manually adding negative \vspace commands everywhere.
% \setlength{\textfloatsep}{0pt}
% \setlength{\textfloatsep}{20pt plus 2pt minus 4pt}
% \setlength{\textfloatsep}{10pt plus 2pt minus 4pt}
% \setlength{\textfloatsep}{10pt plus 1pt minus 2pt}
% \setlength{\dbltextfloatsep}{3pt}
% \setlength{\intextsep}{5pt}
% \setlength{\abovecaptionskip}{5pt}
% \setlength{\belowcaptionskip}{3pt}
% \setlength{\parskip}{4pt}
% % around equations
% \setlength{\abovedisplayskip}{3pt}
% \setlength{\belowdisplayskip}{3pt}
% \setlength\abovedisplayshortskip{3pt}
% \setlength\belowdisplayshortskip{3pt}


% space saving code
%\makeatletter
%\renewcommand\section{\@startsection{section}{1}{\z@}%
%                      {-8\p@ \@plus -4\p@ \@minus -4\p@}%
%                      {6\p@ \@plus 4\p@ \@minus 4\p@}%
%                      {\normalfont\large\bfseries\boldmath
 %                       \rightskip=\z@ \@plus 8em\pretolerance=10000 }}
%\renewcommand\subsection{\@startsection{subsection}{2}{\z@}%
%                      {-8\p@ \@plus -4\p@ \@minus -4\p@}%
 %                     {6\p@ \@plus 4\p@ \@minus 4\p@}%
 %                     {\normalfont\normalsize\bfseries\boldmath
  %                      \rightskip=\z@ \@plus 8em\pretolerance=10000 }}
%\renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
 %                     {-4\p@ \@plus -4\p@ \@minus -4\p@}%
     %                 {-1.5em \@plus -0.22em \@minus -0.1em}%
     %                 {\normalfont\normalsize\bfseries\boldmath}}
%\makeatother
%\setlength{\belowcaptionskip}{-12pt}
% \algrenewcommand\alglinenumber[1]{\smaller #1:}



\newcommand{\CGD}{Cordial Grassroots Dissemination\xspace}
\newcommand{\GDD}{Grassroots Datagram Dissemination\xspace}

\newcommand{ \AD}{All-to-All Dissemination\xspace}
\newcommand{ \BAD}{Blocklace All-to-All Dissemination\xspace}
\newcommand{ \BADD}{Blocklace All-to-All Datagram Dissemination\xspace}
\newcommand{ \CGDD}{Grassroots Cordial Datagram Dissemination\xspace}
\newcommand{\GD}{Grassroots Dissemination\xspace}

\newcommand{\calCGD}{\calC\calG\calD}

\newcommand{\precGD}{\prec_{\calG\calD}}
\newcommand{\precGCD}{\prec_{\calCGD}}

\newcommand{\preceqGD}{\preceq_{\calG\calD}}
\newcommand{\preceqGCD}{\preceq_{\calCGD}}



\newcommand{\Id}{\textit{Id}}






\bibliographystyle{plainurl}% the mandatory bibstyle

\title{\smaller Grassroots Distributed Systems for Digital Sovereignty: Concept, Examples, Implementation and Applications} %TODO Please add

\titlerunning{Grassroots Distributed Systems} %TODO optional, please use if title is longer than one line

\author{Ehud Shapiro}{Department of Computer Science and Applied Math, Weizmann Institute of Science,  Israel}{ehud.shapiro@weizmann.ac.il}{}{}



%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.


\authorrunning{Ehud Shapiro} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Ehud Shapiro} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10010520.10010521.10010537.10010540</concept_id>
       <concept_desc>Computer systems organization~Peer-to-peer architectures</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003033.10003039.10003040</concept_id>
       <concept_desc>Networks~Network protocol design</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003033.10003039.10003041.10003043</concept_id>
       <concept_desc>Networks~Formal specifications</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10010940.10010971.10011120</concept_id>
       <concept_desc>Software and its engineering~Distributed systems organizing principles</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Peer-to-peer architectures}
\ccsdesc[500]{Networks~Network protocol design}
\ccsdesc[500]{Networks~Formal specifications}
\ccsdesc[500]{Software and its engineering~Distributed systems organizing principles}
 %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{Grassroots Distributed Systems, Digital Sovereignty, Dissemination Protocol,  Multiagent Transition Systems, Blocklace} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\EventEditors{John Q. Open and Joan R. Access}
%\EventNoEds{2}
%\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
%\EventShortTitle{}
%\EventAcronym{}
%\EventYear{}
%\EventDate{December 24--27, 2016}
%\EventLocation{Little Whinging, United Kingdom}
%\EventLogo{}
%\SeriesVolume{}
%\ArticleNo{00}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Informally, a distributed system is \emph{grassroots} if it is permissionless and can have autonomous, independently-deployed instances---geographically and over time---that may interoperate voluntarily once interconnected. 
More formally, in a grassroots system the set of all correct behaviors of a set of agents $P$ is strictly included in the set of the correct behaviors of $P$ when embedded within a larger set of agents $P' \supset P$.  

Client-server/cloud computing systems are not grassroots, and so are \andy{should be ``neither are''} systems designed to have a single global instance (Bitcoin/Ethereum with hardwired seed miners/bootnodes), and systems that rely on a single global data structure (IPFS, DHTs).
An example grassroots system would be a serverless smartphone-based  social network supporting multiple independently-budding communities that can merge when a member of one community becomes also a member of another.

%
Grassroots applications are potentially important as they may be essential for \emph{digital sovereignty}, which we interpret as the ability of people to conduct their social, economic, civic, and political lives in the digital realm solely using the networked computing devices they own and operate (e.g., smartphones), free of third-party control, surveillance, manipulation, coercion, or value-extraction (e.g., by global digital platforms such as Facebook or Bitcoin).

%
Here, we formalize the notion of grassroots distributed systems and grassroots implementations; specify an abstract grassroots dissemination protocol; describe and prove an implementation of grassroots dissemination for the model of asynchrony; extend the implementation to mobile (address-changing) devices that communicate via an unreliable network (e.g. smartphones using UDP); and illustrate how grassroots dissemination can realize applications that support digital sovereignty -- grassroots social networking and sovereign cryptocurrencies.
%
The mathematical construction employs distributed multiagent transition systems to define the notions of  grassroots protocols and grassroots implementations,  to specify grassroots dissemination protocols and their implementation, and to prove their correctness.  The implementation uses the blocklace -- a partially-ordered DAG-like generalization of the blockchain.
\end{abstract}




\section{Introduction}

\mypara{Motivation} Today, client-server/cloud computing is the dominant architecture in the digital realm,  supporting the global digital platforms we inhabit on a daily basis.  These platforms have adopted surveillance-capitalism~\cite{zuboff2019age} as their business model, which drives them to monitor, induce, and manipulate their inhabitants for profit.  Authoritarian regimes may have an added ingredient: A ``back-door'' to the global platform for the regime to monitor, censor, control, and even punish the digital behavior of its citizens.  

Blockchain technology and cryptocurrencies~\cite{bitcoin,buterin2014next} offer a radically-different architecture that is peer-to-peer and `permissionless',  open to participation by everyone. Still, a `peer' in this architecture is typically a high-performance server or, better yet, a high-performance server-cluster.   Despite the promise of openness and distribution of power, leading cryptocurrencies are also global platforms dominated---even controlled---by a handful of ultra-high-performance server-clusters~\cite{gencer2018decentralization}.  The operators of these server clusters are remunerated for their efforts via inflationary coin minting or transaction fees/gas paid by the platform users.
An alternative server-based architecture that strives for better distribution of power is federation, employed for example by BitTorrent~\cite{cohen2003incentives}, IPFS~\cite{benet2014ipfs}, and Mastodon~\cite{raman2019challenges}.

Today's smartphones have orders-of-magnitude more computing power, memory, and network speed compared to the Unix workstations that were the workhorses of the Internet revolution.  Yet, they function mostly as adorned gateways to global digital platforms, with even peer-to-peer streaming being initiated and controlled by the cloud.  We believe that the lack of a business model that can incentivize `genuine' peer-to-peer applications and the lack of suitable architectural foundations for such applications are the culprit. 

Here, we are concerned with providing such architectural foundations, referred to as a grassroots architecture, a notion introduced and formally defined below.
Informally, a distributed system is \emph{grassroots} if it can have autonomous, independently-deployed instances---geographically and over time---that can interoperate once interconnected.  
The quintessential manifestation of a grassroots distributed system would be a peer-to-peer, serverless, smartphone-based social network that can form independently at multiple communities and at different times, and interoperate if and when the communities are interconnected, for example via a person that becomes a member of two hitherto-disjoint communities. The grassroots dissemination protocol developed here can, in principle, support such an application.
%
Grassroots applications are potentially important as they may provide a foundation for \emph{digital sovereignty}~\cite{pohle2020digital,goldacker2017digitale,RN47}, which we interpret as the ability of people to conduct their social, economic, civic, and political lives in the digital realm solely using the networked computing devices they own and operate (e.g., smartphones), free of third-party control, surveillance, manipulation, coercion, or value-extraction (e.g., by global digital platforms such as Facebook or Bitcoin).

In general, a system designed to have a single global instance is not grassroots.
Client-server/cloud systems in which two instances cannot co-exist due to competition/conflict on shared resources (e.g., same web address), or cannot interoperate when interconnected, 
are not grassroots.
So are peer-to-peer systems that require all-to-all dissemination, including mainstream cryptocurrencies and standard consensus protocols~\cite{castro1999practical,yin2019hotstuff,keidar2021need}, 
since a community placed in a larger context cannot ignore members of the larger context.
Also are systems that use a global shared data-structure such as pub/sub systems~\cite{chockler2007constructing,chockler2007spidercast}, IPFS~\cite{benet2014ipfs}, and distributed hash tables~\cite{stoica2001chord},  since a community placed in a larger context cannot ignore updates to the shared resource by others. 
While we do not prove this formally, federated systems such as BitTorrent~\cite{cohen2003incentives} with private trackers  and Mastodon~\cite{raman2019challenges}, in which federation is optional and there are no shared global resources, may be grassroots.


\mypara{Contributions} While the notion of `grassroots' has intuitive appeal and is well-established in the social and political arena~\cite{castells1983city}, it has not received, to the best of our knowledge, any formal treatment.
One contribution of this work is its formal definition and characterization in the context of multiagent distributed systems.

Another contribution is a specification and a proven implementation for the model of asynchrony of perhaps the first grassroots dissemination protocol. The result is powerful enough to realize serverless social networking and sovereign cryptocurrencies~\cite{shapiro2022sovereign}.  The protocol is specified by the rather-abstract \GD protocol and implemented by the blocklace-based  \CGD protocol, both specified as asynchronous distributed multiagent transitions systems~\cite{shapiro2021multiagent}, with pseudocode realizing the latter for the model of asynchrony and for mobile devices using unreliable communication (UDP).

\mypara{Related work} The blocklace is a partially-ordered generalization of the blockchain that functions as a fault-resilient, conflict-free replicated data type~\cite{shapiro2011conflict} and has been employed to realize consensus protocols~\cite{keidar2022cordial}.
%
All-to-all dissemination has been explored extensively over the past decades, under the notions of gossip~\cite{shah2009gossip} and epidemic~\cite{pastor2015epidemic} protocols. Here, we use all-to-all dissemination as a stepping stone to grassroots dissemination. 

The grassroots dissemination protocol must give credit to the  pioneering 1990's
Bayou project at Xerox PARC~\cite{demers1994bayou}.  It is also
reminiscent of the pub/sub model~\cite{chockler2007constructing,chockler2007spidercast}, where every agent is viewed as a publisher and every follower as a subscriber. While peer-to-peer protocols for the pub/sub model were developed (see~\cite{setty2012poldercast} for a review), apparently they are not grassroots.  For example, the Poldercast protocol~\cite{setty2012poldercast} is not grassroots since
it assumes a global  set of topics that is disjoint from the set of agents participating in the protocol.  In particular, in Poldercast any infinite correct run of a group of agents $P$ that subscribes to a topic $t$, when repeated within a larger group $P'$ with members that publish to the same topic $t$, would violate liveness. The reason is that  members of $P$ that subscribe to $t$, when embedded within $P'$, should receive in such a run posts to $t$ by published by agents in $P'\setminus P$; but in such a run they do not.  In addition, there are social networks such as PeerSoN~\cite{buchegger2009peerson} that are peer-to-peer, but to the best of our understanding are not grassroots, for example since employing Distributed Hash Tables~\cite{stoica2001chord} as a shared global resource.

\begin{wrapfigure}{r}{5.5cm}
%
\begin{center}
\includegraphics[width=5.5cm]{Figs/gd-stack.png}
\end{center}
\caption{Protocols and Implementations presented in this paper.
\AD  $\calA\calD$ (Def. \ref{definition:AD}), \GD  $\calG\calD$ (Def. \ref{definition:GD}),
 \CGD  $\calCGD$ (Def. \ref{definition:protocol-GCD}), and the implementation  $\sigma$ (Def. \ref{definition:sigma-GCD-GD}, Thm. \ref{theorem:GCD-implements-GD}) of $\calG\calD$  by $\calCGD$. 
Algorithms \ref{alg:blocklace}, \ref{alg:GCD}, and  \ref{alg:GCD-UDP} that implement  $\calCGD$ for Asynchrony and UDP are presented as pseudocode.}
\label{figure:GD-stack}
%
\end{wrapfigure}
\mypara{Outline} The dissemination protocols introduced in this paper and their implementations are summarized in Figure \ref{figure:GD-stack}. The rest of the paper is organized as follows. Section \ref{section:grassroots} briefly introduces asynchronous distributed multiagent transition systems (expanded upon in Appendix \ref{section:preliminaries}) and implementations among them,  providing the mathematical basis for
defining grassroots protocols and grassroots implementations.  It then 
introduces the rather-abstract Grassroots Dissemination protocol $\calG\calD$ and proves it to be grassroots.
Section \ref{section:GD-implementation} describes the implementation of grassroots dissemination using the blocklace -- a DAG-like partially-ordered generalization of the blockchain.  It introduces blocklace basics;  the blocklace-based Grassroots Cordial Dissemination protocol $\calCGD$; presents an implementation $\sigma$ of $\calG\calD$ by
$\calCGD$ and proves it correct; provides pseudocode implementation of $\calCGD$ for the model of asynchrony; and extends the implementation to mobile devices using unreliable communication (UDP).
Section \ref{section:applications} illustrates two potential applications of grassroots dissemination: Twitter-like and WhatsApp-like serverless social networking, and sovereign cryptocurrencies.
Section \ref{section:conclusions} concludes the paper.
Due to length limitations, proofs and some auxiliary material are relegated to the Appendices.


\section{Grassroots Protocols}\label{section:grassroots}

\subsection{Definition}

Informally, when agents operate according to 
a grassroots protocol (\ia) the possible behaviors and interactions of an isolated community of agents are not constrained by placing the community within a larger community and (\ib)  agents in an isolated community, when placed within a larger community, may have behaviors and interactions not possible when in isolation. In particular, agents may interact with each other across community boundaries. This notion supports the grassroots deployment of a distributed system -- autonomous independent instances deployed at different locations and over time that can possibly (but not necessarily) interoperate once interconnected.

\mypara{Asynchronous distributed multiagent transition systems} We formalize this intuitive notion of a grassroots protocol using asynchronous
distributed multiagent transition system~\cite{shapiro2021multiagent}.  See Appendix \ref{section:preliminaries} for a brief introduction; we repeat below essential definitions and results. \andy{I think most readers will need to be walked through this stuff slowly, with examples. }

Assume a set $\Pi$ of agents, each equipped with a single and unique key-pair, \andy{Why does each agent only have one key-pair? Are we to think of a Byzantine agent who has many key-pairs as being many coordinated Byzantine agents -- one for each key?} and identify an agent  $p \in \Pi$ by its public key.  While the set of all agents $\Pi$ could in principle be infinite (think of all the agents that are yet to be born), when we refer to a particular set of agents $P \subseteq \Pi$ we assume $P$ to be finite. 

\begin{definition}[Local States, $\prec$, Initial State]
A \temph{local states function} $S$ maps every set of agents $P \subseteq \Pi$ to a set of \temph{local states} $S(P)$. A local states function $S$ has an associated partial order $\prec_{S}$ over its range that is unbounded over $S(P)$ for every $\emptyset \subset P \subseteq \Pi$ and has a minimal element $s0(S)$, abbreviated $s0$ when $S$ is clear from the context, referred to as the \temph{initial local state} of $S$.
\end{definition}
Intuitively, think of $S(P)$ as the set of all possible sequences of messages among members of $P$, or the set of all possible  blockchains created and signed by members of $P$,  both with $\prec_S$ being the prefix relation and $s0$ being the empty sequence; or the set of all possible sets of posts/tweets and threads of responses to them by members of $P$, with $\prec_S$ being the subset relation, and $s0$ being the empty set. 


\andy{ Let me try a version of the above.} 

\andy{\textbf{Definition}. We consider a fixed value $Z$, which is the infinite set of all possible \temph{local states}. A \temph{local states function} $S$ maps every set of agents $P \subseteq \Pi$ to a set of local states $S(P)\subseteq Z$. A local states function $S$ also has an associated partial order $\prec_{S}$ on $Z$ with no maximal elements, and with a unique least element $s0(S)$, abbreviated $s0$ when $S$ is clear from the context, and referred to as the \temph{initial local state} of $S$. Each set of local states $S(P)$ includes $s_0$ and is unbounded in the inherited ordering. }


\andy{Intuitively, one can think of $Z$ as being the set of all possible sequences recording which messages are sent and recieved by an individual agent, with such sequences ordered in the standard way by the prefix relation. }

\andy{Is there some extra condition required here to ensure $S(P)\neq Z$? Intuitively, $S(P)$ should only include things produced by members of $P$, but that doesn't seem to be required yet.}

\begin{definition}[Configuration, Transition, $p$-Transition, $\prec$]
Given a set of local states $X$ and a finite set of agents $P\subseteq \Pi$, a \temph{configuration} $c$ over $P$ and $X$ is a member of $C:=X^P$, namely $c$ consists of a set of local states indexed by $P$.  When $X =S(P)$ for a local states function $S$ we refer to a configuration over $P$ and $S$.
%
Given a configuration $c \in C$ and an agent $p \in P$, $c_p$ denotes the element of $c$ indexed by $p$, referred to as the \temph{local state of $p$ in $c$},
and $c0:=\{s0\}^P$ denotes the \temph{initial configuration}.
%
A \emph{transition} over $P$  and $X$ is an ordered pair of configurations over $P$ and $X$, written $c \rightarrow c' \in C^2$.  If $c_p \ne c'_p$ for some $p \in P$ and $c'_q = c_q$ for every $q \ne p \in P$, the transition is a \temph{$p$-transition}.
%Let $CC(P)$  denote the set of transitions over $P$.
%
A partial order  $\prec$ on local states induces a partial order on configurations, defined by $c \preceq c'$ if $c_p \preceq c'_p$ for every $p \in P$.  
\end{definition}

\begin{definition}[Distributed Multiagent Transition System; Computation; Run]\label{definition:DMTS}
A \temph{distributed multiagent transition system} over $P\subseteq \Pi$ and a 
set of local states $X$ with initial local state $s0 \in X$,
 $TS =(P,X,T,\lambda)$, has \temph{configurations} $C=S(P)^P$; \temph{initial configuration}  $c0:=\{s0\}^P$;  a set of \temph{correct transitions} $T = \bigcup_{p \in P} T_p \subseteq C^2$, where each $T_p$ is a set of \temph{correct $p$-transitions}; and a \temph{liveness requirement} $\lambda = \bigcup_{p \in P} \lambda_p$,
where $\lambda_p$ is a partition  of $T_p$. \andy{This definition uses $S$, but doesn't explicitly list it as a member of the tuple.}
When $X$ is given by a local states function $S$, $X=S(P)$ with minimal element $s0(S)$, we abbreviate $TS=(P,S(P),T,\lambda)$ as $TS =(P,S,T,\lambda)$.
%
A \temph{computation} of $TS$ is a sequence of arrow-separated \andy{?} configurations over $P$ and $S$,  $r= c \xrightarrow{} c' \xrightarrow{}  \cdots $, with two consecutive configurations in $r$ referred to as a \temph{transition of $r$}.   A \temph{run} of $TS$ is a computation that starts with $c0$. \andy{Always infinite?}
\end{definition}

\andy{Why is $\lambda$ a partition of $T_p$ rather than a collection of subsets of $T_p$? A couple of examples might be useful?} Note that computations and runs may include  incorrect transitions and that the liveness requirement may be the trivial one, namely $\lambda_p = \{T_p\}$ for every $p \in P$.


\begin{definition}[Safe, Live and Correct Run]\label{definition:ts-slc}
Given a transition system  $TS=(P,S,T,\lambda)$, a computation $r$ of $TS$ is \temph{safe}, also $r \subseteq T$, if every transition of $r$ is correct.  We use  $c \xrightarrow{*} c' \subseteq T$ to denote the existence of a safe computation (empty if $c=c'$) from $c$ to $c'$. 
%
A transition $c'\rightarrow c''$ is \temph{enabled on $c$} if $c=c'$.
A run is \temph{live wrt $L \in \lambda$} if either $r$ has a nonempty suffix in which no transition in $L$ is enabled, or every suffix of $r$ includes a transition in $L$. A run $r$ is \temph{live} if it is live wrt every $L \in \lambda$.
A run $r$ is \temph{correct} if it is safe and live.
%
An agent $p \in P$ is \temph{safe in $r$} if $r$ includes only correct $p$-transitions;  is \temph{live in $r$} if for every $L \in \lambda_p$, $r$ is live wrt $L$; and  is \temph{correct} in $r$ if $p$ is safe and live in $r$. 
\end{definition}

Note that the trivial liveness requirement entails the standard one:  A run is live if for every agent $p$ that is enabled infinitely often, the run has infinitely many $p$-transitions.

A transition system is \emph{asynchronous} if progress by other agents cannot prevent an agent from taking an already-enabled transition.

\begin{definition}[Monotonic and Asynchronous Distributed Multiagent Transition System]\label{definition:multiagent-sa}
%\begin{definition}[Multiagent Distributed Transition Systems]\label{definition:multiagent}
A distributed multiagent transition system $TS=(P,S,T,\lambda)$ is 
\temph{monotonic} wrt a partial order $\prec$ if $c\rightarrow c' \in T$ 
implies that $c \prec c'$, and it is \temph{monotonic} if it is monotonic wrt $\prec_S$.  It is \temph{asynchronous} if it is monotonic and for every $p$-transition $c \xrightarrow{} c' \in T_p$, $T_p$ also includes every $p$-transition $d \xrightarrow{} d'$ for which  $c \prec_{S} d$ and
    $(c_p \rightarrow c'_p) = (d_p \rightarrow d'_p)$.
\end{definition}

\mypara{Grassroots protocol}  
Next, we define the notion of a protocol and a grassroots protocol.
\begin{definition}[Protocol]\label{definition:family}
A \temph{protocol} $\calF$ is a family of distributed multiagent transition systems over a local states function $S$ that has one such transition system $TS(P) = (P,S,T(P),\lambda(P)) \in \calF$ over $P$ and $S$ for every
 $\emptyset \subset P \subseteq \Pi$.
%
%The \temph{states} of $\calF$ are $S(\calF) := \bigcup_{P \subseteq \Pi}S(P)$.The protocol $\calF$ is \temph{asynchronous} if every transition system in $\calF$ is asynchronous, and is a \temph{subset} of protocol $\calF'$ if for every $P\subseteq \Pi$, $TS(P)$ is a subset of $TS'(P)$.
\end{definition}
For simplicity and to avoid notational clutter, we often assume a given set of agents $P$, refer to the representative member of $\calF$ over $P$, rather than to the entire family, and refer to the protocol $TS(P) = (P,S,T(P),\lambda(P)) \in \calF$ simply as $TS = (P,S,T,\lambda)$.
%


%We note that all example protocols presented in~\cite{shapiro2021multiagent} are not grassroots, and so are all client-server and cloud-based systems, as well as peer-to-peer systems that require all-to-all dissemination such as mainstream cryptocurrencies, standard consensus protocols, and pub/sub systems. Among peer-to-peer file systems, to the best of our knowledge BitTorrent with private trackers is grassroots, as different autonomous instances of the protocol may use independent private trackers that  may later agree to interoperate, whereas IPFS is not, as it is designed to be a single global network. We elaborate on this below.


\begin{definition}[Projection]\label{definition:projection}
Let $\calF$ be a protocol over $S$, $\emptyset \subset P \subset P' \subseteq \Pi$.  Given a configuration $c'$  over $P'$ and $S$, the \temph{projection of  $c'$ on} $P$, $c'/P$, is the configuration $c$ over $P$ and $S$ satisfying $c_p = c'_p$ for all $p \in P$. The \temph{projection of $TS(P') = (P',S(P'),T',\lambda') \in \calF$ on $P$}, denoted $TS(P')/P$ is the transition system over $P$ and $S(P')$, $TS(P')/P:=(P,S(P'),T'/P,\lambda'/P)$,
where  $c_1/P \rightarrow c_2/P \in T'/P$ if  $c_1 \rightarrow c_2 \in T'$ and with $\lambda'/P := \{L/P : L \in \lambda'\}$.  
\end{definition}
Note that $TS(P')/P$ has local states  $S(P')$, not $S(P)$.  This is necessary as, for example, if the local state is a set of blocks, and in a $TS(P')$ configuration $c$ the local states of members of $P$ have blocks produced by members of $P'\setminus P$, this remains so also in $c/P$.

\begin{definition}[Grassroots]\label{definition:grassroots}
A  protocol $\calF$ is \temph{grassroots} if $\emptyset \subset P \subset P' \subseteq \Pi \text{ implies that } TS(P) \subset TS(P')/P$. \andy{I think $TS(P) \subset TS(P')/P$ needs to be defined? You are actually talking about the set of runs that are live and safe?}
\end{definition}
\andy{These seems quite a ``fundamental'' definition, but it would be nice to see further justification for the idea that grassroots protocols are the ones we want to consider. For example, could we have a theorem that asserts something like ``If a protocol doesn't require knowledge of the player set and achieves some minimal functionality, then it must be ``grassroots''?} Namely, in a grassroots protocol, a group of agents $P$, if embedded within a larger group $P'$, can still behave as if it is on its own (hence the subset relation), but also has new behaviors at its disposal (hence the subset relation is strict), presumably due to interactions between members of $P$ and members of $P'\setminus P$.


Appendix \ref{appendix-section:protocol-AD} proves that the All-to-All Dissemination protocol $\calA\calD$~\cite{shapiro2021multiagent} is not grassroots. The formal proof can be generalized, informally, to any protocol that employs all-to-all dissemination:
\begin{observation}\label{observation:ata-not-grassroots}
An all-to-all dissemination protocol cannot be grassroots.
\end{observation}
\begin{proof}[Proof of Observation \ref{observation:ata-not-grassroots}]
\andy{This seems to assume $S(P)\neq Z$? But why is that the case?} Informally,  liveness of an all-to-all dissemination protocol requires any object (message, post, block) produced by one correct agent to be eventually received by all correct agents participating in the protocol. Hence, any  infinite correct behavior of agents $P$ executing  an all-to-all dissemination protocol on their own, when embedded within a larger group $P'$ that produces additional objects, violates liveness. The reason is that in this infinite behavior members of $P$ never receive objects created by $P'\setminus P$, which they should if run within the larger group $P'$.  Hence
$TS(P) \subseteq TS(P')/P$ does not hold, and neither the stricter $TS(P) \subset TS(P')/P$, and thus the protocol is not grassroots.
\end{proof}




%Clearly, global platforms such as Facebook, Amazon, Uber, are not grassroots. Two disjoint sets of agents cannot operate them independently as there is only one global address for each such platform, and behind it one centralized system serving all its users (or, in case of regional subsidiaries, one global address per region or country).   The case of global cryptocurrencies such as Bitcoin is more interesting as, intuitively, they may appear to be grassroots.  However, Bitcoin also employs global addresses, as when started for the first time, programs query one or more hard-coded DNS names, called DNS seeds~\cite{bitcoin-p2p}. Two disjoint sets of miners may operate Bitcoin initially independently (e.g. by each employing a different seed).  However, eventually communication among the seeds will cause the longest chain among the two to take over and the losing set of miners to abandon their chain and join the winning chain, violating subsidiarity. One can easily imagine two independent Bitcoins that use disjoint seeds that do not communicate with each other.  Indeed two such systems can operate indefinitely without violating subsidiarity; but they will violate interactivity:  The two systems will not have additional behaviors as a result of being put together.\footnote{One can imagine going one step further, endowing each Bitcoin system with a different port number so that combining the two systems will allow each miner to participate in both Bitcoins, creating additional behaviors; but then some agency will have to allocate port numbers to the different Bitcoins, as collisions would violate subsidiarity, and we are back to square one.}  Hence, either way, the Bitcoin architecture is not grassroots, which is commensurate with its goal:  To establish a global dominant cryptocurrency. A key part of our research agenda is the development of grassroots protocols and applications, including grassroots alternatives to global platforms and global cryptocurrencies~\cite{shapiro2022sovereign}.



%Next, we provide a sufficient condition for a protocol to be grassroots:
%\begin{definition}[Closure Under Union]
%Let $S$ be a set of local states over $\calA$ closed under set union, $P \subset \Pi$ and $C$ a set of configurations over $P$ and $S$.  Then the \temph{global state} of $C$ is defined to be $S(C) := \bigcup_{p \in P} c_p \in S$.
%\end{definition}

%Let $\calA$ be a base set and $S$ be a set of sets over $\calA$.  Then $S$  is \temph{closed under set union} if $s, s' \in S$ implies that $s \cup s' \in S$.  Note that Blockchains are not closed under set union.

\mypara{Sufficient condition for a protocol to be grassroots} 
Here we define certain properties of a protocol and prove that satisfying them is sufficient for the protocol to be grassroots.
\begin{definition}[Monotonic and Asynchronous Protocol]\label{definition:monotonic-protocol}
Let $\calF$ be a protocol over $S$.
Then  $\prec_S$ is \temph{preserved under projection} if for every $\emptyset \subset P \subset P' \subseteq \Pi$ and every two configurations $c_1, c_2$ over $P'$ and $S$, 
$c_1 \preceq_S c_2$ implies that $c_1/P \preceq_S c_2/P$.
The protocol $\calF$ is \temph{monotonic} if $\prec_S$ is preserved under projection and every member of $\calF$ is monotonic; it is \temph{asynchronous} if, in addition, every member of $\calF$ is asynchronous.
\end{definition}



A protocol is interactive if a set of agents embedded in a larger group of agents  can perform  computations they cannot perform in isolation.  It is non-interfering if (\ia) \emph{safety:} a transition that can be carried out by a group of agents can still be carried out if there are additional agents that observe it from their initial state, and (\ib) \emph{liveness:} if an agent is live in a run of the group, then adding more agents to the group and extending the run with their transitions, will not result in the agent violating liveness. Formally:


\begin{definition}[Interactive \& Non-Interfering Protocol]\label{definition:non-interfering}
A protocol  $\calF$ over $S$ is \temph{interactive} if
for every $\emptyset \subset P \subset P' \subseteq \Pi$, 
$TS(P')/P \not\subseteq TS(P)$.
It is \temph{non-interfering} if for every $\emptyset \subset P \subset P' \subseteq \Pi$, with transition systems $TS = (P,S,T,\lambda), TS' = (P',S,T',\lambda') \in \calF$:
\begin{enumerate}
    \item \textbf{Safety}: For  every transition $c1 \rightarrow c2 \in T$,
$T'$ includes the transition  $c1' \rightarrow c2'$ for which $c1=c1'/P$, $c2=c2'/P$, and
$c1'_p = c2'_p = c0'_p$ for every $p \in P' \setminus P$, and
    \item \textbf{Liveness}: For every agent $p \in P$ and run $r$ of $TS$, if $p$ is live in $r$ then it is also live in every run $r'$ of $TS'$ for which $r'/P = r$.
\end{enumerate}
\end{definition}




%\begin{definition}[Closure Under Union]
%Let $S$ be a set of local states over $\calA$ closed under set union, $P \subset \Pi$ and $C$ a set of configurations over $P$ and $S$.  Then the \temph{global state} of $C$ is defined to be $S(C) := \bigcup_{p \in P} c_p \in S$.
%\end{definition}

%Let $\calA$ be a base set and $S$ be a set of sets over $\calA$.  Then $S$  is \temph{closed under set union} if $s, s' \in S$ implies that $s \cup s' \in S$.  Note that Blockchains are not closed under set union.

\begin{restatable}[Grassroots Protocol]{theorem}{GrassrootsProtocol}\label{theorem:grassroots}
An asynchronous, interactive, and non-interfering protocol is grassroots.
\end{restatable}

We note that  blockchain consensus protocols with hardcoded miners, e.g. the seed miners of Bitcoin~\cite{bitcoin-p2p} or the bootnodes of Ethereum~\cite{ethereum-bootnodes},  as well as permissioned consensus protocols with a predetermined set of participants such as Byzantine Atomic Broadcast~\cite{shostak1982byzantine,keidar2022cordial}, are all interfering, as additional participants cannot be ignored.    If hardcoded bootnodes/seed  miners are relativized, two instances of the protocol would interfere on the assigned global port numbers, preventing a server from participating in two instances. If both bootnodes and port numbers are relativized, the resulting protocol would not be interactive, as two instances of the protocol with disjoint bootnodes and port numbers, say bitcoin$'$ and bitcoin$''$,  would not be able to interact.
Thus, both the original definitions of Ethereum and Bitcoin, as well as definitions relativizing bootnodes and port numbers, are not grassroots.

However, Theorem \ref{theorem:grassroots} and the examples above do not imply that ordering consensus protocols cannot be grassroots.  The problem is not with the consensus protocol as such, but with the choice of its participants. If participants in an instance of an ordering consensus protocol are  determined by the agents themselves via a grassroots protocol, rather than being provided externally and \emph{a priori} as in standard permissioned consensus protocols, 
or are required to include a predetermined set of initial participants as in Bitcoin and Ethereum, then the participants can reach consensus without violating grassroots.  Devising grassroots consensus protocols is a subject of future work (see ~\cite{poupko2023thesis}, Ch. 4).

Next, we present the \GD protocol and prove it to be grassroots.

\subsection{The \GD Protocol}


The \AD protocol is asynchronous and interactive, and this is also true of \GD. But, unlike \AD, in  the \GD  protocol dissemination occurs only among friends.  Moreover, agents are free to choose their friends.  Hence, additional agents may be ignored by a given group of agents without violating agent liveness, implying that \GD is also non-interfering and thus grassroots, as proven below.

We assume a given \emph{payloads function} $\calX$ that maps each set of agents $P$ to a set of payloads $\calX(P)$.  For example, $\calX$ could map $P$ to all strings signed by members of $P$; or to all messages sent among members of $P$, signed by the sender and encrypted by the public key of the recipient; or to all financial transactions among members of $P$. Remember that here $P$ are not `miners' serving transactions by other agents, but are the full set of agents participating the in protocol.
 
\begin{definition}[Simple Block, $SB$, $\prec_{SB}$]
A \temph{block Id} over $P$ is a pair $\Id = (p,i)$ where $p\in P$ and $i \in \NN$.
A \temph{simple block} over $P$ is a pair $(\Id,x)$ where $\Id$ is a block Id over $P$ and 
$x \in \calX(P)$ or $x=(\textit{follow},q)$, $q\in P$.  A block with $\Id = (p,i)$ is referred to as an \temph{$i$-indexed simple $p$-block with payload $x$}.  Let $B(P)$ denote the set of all simple blocks over $P$.

The local states function $SB$ maps $P$ to the set of all sets of simple blocks over $P$.
The partial order $\prec_{SB}$ over configurations over $P$ and $SB$ is defined  by $c \preceq_{SB} c'$ if
   $c, c'$ are configurations over $P$ and $SB$ and $c_p \subseteq c'_p$ for every $p \in P$.
\end{definition}
Note that  $c\prec_{SB} c'$ if $c_p \subset c'_p$ for some $p \in P$ and $c_q = c'_q$ for every $q \ne p \in P$.

We say that agent $p$ \emph{knows} a block $b$ if $b$ is in $p$'s local state. The liveness condition of all-to-all dissemination ensures that every block created by every correct agent will be known eventually by every other correct agent. This is  unnecessary and impractical for grassroots applications such as grassroots social networking and sovereign cryptocurrencies, especially as they grow and become very large scale.  Therefore the \GD  protocol satisfies a weaker, more local liveness requirement. 

In \GD, agents may follow other agents, and two agents are friends if they follow each other.
Informally, the basic rule of \GD is that an agent $p$ can receive from agent $q$ a $q'$-block $b$ 
if $p$ and $q$ are friends and they both follow $q'$.
Note that the special case $q=q'$ implies that friends eventually know each other's blocks.  Also note  that the friendship relation induces an undirected graph on the agents.  A \emph{friendship path}  is a path in the social graph.  The key liveness claim of \GD is that  $p$ eventually knows any $q$-block if there is a friendship path of correct agents from $p$ to $q$, all of which follow $q$.

\begin{definition}[Follows, Needs, Friend, Social Graph]\label{defininition:follows}
Given $p,q \in P$ and a configuration $c$ over $P$ and $SB$:
$p$ \temph{follows} $q$  in $c$ if  $c_p$ includes a $p$-block with payload
 $(\textit{follow},q)$;
%
$p$ \temph{needs} the $q$-block $b$ in $c$ if $p$ follows 
$q$ in $c$ and $b\in c_q\setminus c_p$ \andy{So, this condition only require $p$ to follow $q$, not that they are friends?};
%
and $p$ and $q$ are \temph{friends} in $c$ if $p$ and $q$ follow each other in $c$.
The \temph{social graph} $(P,E(c))$ induced by $c$ has an edge $(p,q)\in E(c)$ if $p$ and $q$ are friends in $c$.
\end{definition}

The key idea of the Grassroots Dissemination protocol is:
\begin{tcolorbox}[colback=gray!5!white,colframe=black!75!black]
\textbf{Principle of \GD:} \\
An agent that needs a block can obtain it from a friend that has it. \andy{IF some friend eventually gets it..there is nothing guaranteeing that will happen, right?}
\end{tcolorbox}




\begin{definition}[$\calG\calD$: \GD]\label{definition:GD}
The \temph{\GD protocol} $\calG\calD$ over $SB$ has for each $P\subseteq \Pi$ the transition system $GD = (P,SB,T,\lambda)$, transitions $T$ with a $p$-transition $c \rightarrow c' \in T_p$ for every   $p \in P$, $c'_p = c_p \cup \{b \}$, $b= (\Id,x) \notin c_p$, and either:
\begin{enumerate}[partopsep=0pt,topsep=0pt,parsep=0pt]
    \item \textbf{Create}:  $\Id=(p,i)$, $i = \text{ max } \{ j \ge 0 : (p,j,x) \in c_p\}+1$, $x\in \calX(P)$, or \andy{So, this prevents $p$ from creating an incorrectly labelled block (even if Byzantine)?}
    \item \textbf{$q$-Disseminates-$b$}:  $b \in c_q$ for some $q \in P$,  $p$ and $q$ are friends in $c$, and $p$ needs $b$ in $c$. \andy{Def 14 above said that $p$ needs a $q$ block as soon as $p$ follows $q$ and the latter creates the block, but what is written here seems only to allow $p$ to receive the block if $p$ and $q$ are friends?}
\end{enumerate}
The liveness condition $\lambda$ includes for each $p,q \in P$ and $b \in B(P)$ the set of all $p$-transitions labeled $q$-Disseminates-$b$.
\end{definition}
Every agent $p$ can either add a consecutively-indexed $p$-block to its local state or obtain from a friend a $p'$-block $b$ it needs. The liveness condition ensures that every correct agent $p$ receives any block by an agent it follows, if the block is known to any of $p$'s friends.  As there are no other liveness requirements,  agents are free to choose which agents to follow, if at all.



\begin{restatable}[$\calG\calD$ Grassroots Liveness]{proposition}{GrassrootsLiveness}\label{proposition:GD-local-liveness}
Let $r$ be a run of GD, $p,q \in P$.
If there is a configuration $c\in r$ such that $p$ and $q$ are connected via a friendship path, 
$p_1,p_2,\ldots,p_k$, $q=p_1$, $p=p_k$, $k\ge 1$ all of its members are correct in $r$ and  follow $q$ in $c$ then for every  $q$-block $b$ in $c$  there is a subsequent configuration $c' \in r$ for which 
$b \in c'_p$.
\end{restatable}


%The fault-resilience of the composition of fault-resilient implementations has yet to be formalized and investigated.  If the bottom protocol of a protocol stack is resilient to certain faults, it can be concluded that the entire stack is resilient to such fault.  However, if may be the case that some faults are better described, detected and excluded by higher-level protocols.


\begin{restatable}[]{proposition}{GDgrassroots}\label{proposition:GD-grassroots}
$\calG\calD$ is grassroots.    
\end{restatable}


We opted here for a simple notion of following an agent.  It can be  refined so that an agent be followed starting from a specific block and later be unfollowed, which may provide for a more efficient implementation of sovereign cryptocurrencies~\cite{shapiro2022sovereign}.


\subsection{Grassroots Implementation}
Here we define the notion of a grassroots implementation and prove that having a grassroots implementation is a sufficient condition for a protocol to be grassroots.
First we recall the notion of implementation among multiagent transition systems~\cite{shapiro2021multiagent} (See also Appendix \ref{section:preliminaries})

\begin{definition}[Specification; Implementation: Piecemeal, Safe, Live, Correct and Complete]\label{definition:implementation}
Given two distributed multiagent transition systems, $TS=(P,S,T,\lambda)$ over $P$ and $S$ (the \temph{specification}) and $TS'=(P,S',T',\lambda')$ over $P$ and $S'$, \temph{an implementation of $TS$ by $TS'$} is a function $\sigma : C' \rightarrow C$ where $\sigma(c0') = c0$, in which case the pair $(TS', \sigma)$ is referred to as  \temph{an implementation of $TS$}. The implementation is \temph{piecemeal} if  $\sigma$ is defined for local states and then
extended to configurations by  $\sigma(c')_p := \sigma(c'_p)$ for $c'\in C'$ and $p \in P$.
%
Given a computation $r'= c'_1\rightarrow c'_2 \rightarrow \ldots$ of $TS'$, $\sigma(r')$ is the (possibly empty) computation obtained from the computation $\sigma(c'_1)\rightarrow \sigma(c'_2) \rightarrow \ldots$ by removing consecutively repetitive elements so that $\sigma(r')$ has no \temph{stutter transitions} of the form $c \rightarrow c$. The implementation $(TS', \sigma)$ of $TS$ is \temph{safe/live/correct} if $\sigma$ maps every safe/live/correct $TS'$ run $r'$ to a safe/live/correct $TS$ run $\sigma(r')$, respectively, 
and is \temph{complete} if every correct run $r$ of $TS$ has a correct run $r'$ of $TS'$ such that $\sigma(r')=r$.
\end{definition}
Note that while an implementation in general is defined for configurations, a piecemeal implementation is defined for local states, which entails its definition for configurations.   Not all implementations are piecemeal, but, as shown next, piecemeal and grassroots  go hand-in-hand.
%
\begin{definition}[Grassroots Implementation]\label{definition:grassroots-implementation}
Let $\calF, \calF'$ be protocols over $S, S'$, respectively,  and $\sigma$ a correct and complete implementation of $TS'(P)$ by $TS(P)$ for every $P \subseteq \Pi$.  Then $(\calF, \sigma)$ is an implementation of $\calF'$.  If, in addition, $\calF$ is grassroots and $\sigma$ is piecemeal, then $(\calF, \sigma)$ is a \emph{grassroots implementation} of $\calF'$.
\end{definition}


The following theorem shatters the hope of a non-grassroots protocol to have a grassroots implementation, and can be used to prove that a protocol is grassroots by providing it with a grassroots implementation.
\begin{theorem}[Grassroots Implementation]\label{theorem:grassroots-implementation}
A protocol that has a grassroots implementation is grassroots.
\end{theorem}
\begin{figure}[ht]
%
\centering
\includegraphics[width=13cm]{Figs/grassroots-implementation-new.jpeg}
\caption{Some Steps in the Proof of Theorem \ref{theorem:grassroots-implementation}. A. Proof of $TS'(P1)\subseteq TS'(P2)/P1$  B.  Proof of $TS'(P1)\not\supseteq TS'(P2)/P1$ }
\label{figure:grassroots-implementation}
%
\end{figure}

\begin{proof}[Proof of Theorem \ref{theorem:grassroots-implementation}]
Let $(\calF,\sigma)$ be a grassroots implementation of protocol $\calF'$.  We wish to prove that $\calF'$ is grassroots, namely that for $\emptyset \subset P1 \subset P2 \subseteq \Pi$,  $TS'(P1) \subset TS'(P2)/P1$.   First we prove that  $TS'(P1) \subseteq TS'(P2)/P1$. 
Roman numerals refer to Figure \ref{figure:grassroots-implementation}.A.
Consider (\ia) a correct run $r1'$ of $TS'(P1)$.  Since $\sigma$ is complete, there is (\ib) a correct run $r1$ of $TS(P1)$ such that $r1' = \sigma(r1)$.  Since $\calF'$ is grassroots, there is (\ic) a correct run $r2$ of $TS(P2)$ such that $r2/P1 = r1$.  Since $\sigma$ is a correct implementation of $\calF'$ by $\calF$, then (\id) $r2' = \sigma(r2)$ is a correct run of $TS$.
Since $\sigma$ is piecemeal by assumption, for every configuration $c \in r2$ and every $p \in P1$, $\sigma(c)_p =\sigma(c_p)$ and also $\sigma(c/P)_p = \sigma((c/P)_p) = \sigma(c_p)$.  Hence (\iie) $r2'/P1 = \sigma(r2)/P1 = \sigma(r2/P1) = \sigma(r1) = r1'$.  Namely $r1'$ is a run of $TS'(P2)/P1$, concluding that $TS'(P1)\subseteq TS'(P2)/P1$.

Next we prove that $TS'(P1) \not\supseteq TS'(P2)/P1$. 
Roman numerals refer to Figure \ref{figure:grassroots-implementation}.B.
Since $F$ is grassroots, there is (\ia) a run $\bar{r}2$ of $TS(P2)$ such that
$\bar{r}2/P1$ is not a run of  $TS(P1)$.  Since $\sigma$ is correct, then (\ib) $\sigma(\bar{r}2)$ is a run of $TS'(P2)$.  We prove (\ic) that $\sigma(\bar{r}2)/P1$ is not a run of $TS'(P1)$ by way of contradiction.  Assume it is.  
Since $\sigma$ is piecemeal, it follows that $\sigma(\bar{r}2)/P1= \sigma(\bar{r}2/P1)$.  Then by completeness of $\sigma$, it follows that 
$\bar{r}2/P1$ is a run of $TS(P1)$, a contradiction.
This completes the proof, concluding the $\calF'$ is grassroots.
%\qed
\end{proof}





\section{Grassroots Implementation of Grassroots Dissemination}\label{section:GD-implementation}

Here we present an implementation of the \GD protocol $\calG\calD$,
as depicted in Figure \ref{figure:GD-stack}:  The blocklace-based \CGD  Protocol $\calCGD$ (Def. \ref{definition:protocol-GCD}),   and its proof of being grassroots (Prop.\ref{proposition:GCD-grassroots}).  The implementation $\sigma$ (Def.\ref{definition:sigma-GCD-GD}) of $\calG\calD$ by $\calCGD$, and its proof of being grassroots (Thm. \ref{theorem:GCD-implements-GD}). Algorithm \ref{alg:blocklace} with pseudocode for blocklace utilities and Algorithm \ref{alg:GCD} with pseudocode realizing $\calCGD$ for the model of Asynchrony.

The \CGD protocol employs the notions of \emph{follows}, \emph{needs}, \emph{friend}, and \emph{social graph} similarly to $\calG\calD$ (Def. \ref{defininition:follows}).
A key difference is that in \GD an agent that needs a block $b$ may receive it from a friend that has $b$ `by magic',  whereas in \CGD such an agent $p$ must first disclose to a friend $q$ the blocks it knows and the agents it follows, implying that it needs $b$, and based on such disclosure $q$ may cordially send $b$ to $p$. \andy{As I read through for the first time, it feels there is something slightly jarring going on. The \GD protocol already seems obviously grassroots, the thing that seems missing is an explanation of how the state transitions required for liveness can actually be realised by a detailed (real life) program: How do my friends know what to send me? But the way things are presented here, there doesn't yet seem to be any formal difference between the status of \GD and \CGD (in terms of one being sufficiently detailed to actually count as a full specification). Instead, it seems that \GCD is being used to prove that \GD is grassroots.}


\begin{tcolorbox}[colback=gray!5!white,colframe=black!75!black]
\textbf{Principles of \CGD:}
\begin{enumerate}[leftmargin=*]
    \item \textbf{Disclosure}: Tell your friends which blocks you know and which you need
    \item \textbf{Cordiality}: Send to your friends blocks you know and think they need
\end{enumerate}
\end{tcolorbox}
We employ the blocklace~\cite{keidar2021need} to realize these principles. The blocklace is a DAG-like partially-ordered generalization of the totally-ordered blockchain data structure that  functions as a fault-resilient, conflict-free replicated data type~\cite{shapiro2011conflict}.
While the mathematical construction and proofs of the blocklace realization presented next are quite involved, the final result, presented as 40 lines of pseudocode in Algs. \ref{alg:blocklace}, \ref{alg:GCD} and \ref{alg:GCD-UDP} is quite simple.



\subsection{Blocklace Preliminaries}

Each block in a blocklace may contain a finite set of cryptographic hash pointers to previous blocks, in contrast to one pointer (or zero for the initial block) in a blockchain.  We assume a payload function $\calX$ as above, and a collision-free cryptographic hash function \emph{hash}.

\begin{definition}[Block, $p$-Block, $p$-Pointer, Self-Pointer, Initial Block]\label{definition:block}
%, $p$-Chain]\label{definition:block}
A \temph{block} over $P \subseteq \Pi$ is a triple $b=(h^p,H,x)$, referred to as a \temph{$p$-block}, $p \in P$, with $h^p$, referred to as a \temph{$p$-pointer},  being the hash pointer $\textit{hash}((H,x))$ signed by $p$; $x \in\calX(P)$ being the \temph{payload} of $b$; and $H$ a finite set of signed hash pointers such that for each $h^q \in H$ there is a $q$-block $b'=(h^q,H',x')$ over $P$ and $\calX$, in which case we say that $b$ \temph{points to} $b'$, and if $p=q$ then $h^q \in H$ is a \temph{self-pointer}. \andy{Might be nice to break this up into shorter sentences? }
If $H = \emptyset$ then $b$ is \temph{initial}. 
%
% A \temph{chain} (or \temph{personal blockchain}) is a sequence of blocks in which the first is initial and each of the subsequent blocks includes a self-pointer to its predecessor; it is a $p$-chain if it consists of $p$-blocks.
%
The set of blocks over $P$ is denoted $\calB(P)$. A \temph{blocklace} over $P$ is a subset of $\calB(P)$. The set of all blocklaces over $P$ is denoted by $\calS\calB(P)$.
\end{definition}
\mypara{Notes} 
(\ia) $\textit{hash}$ being cryptographic \andy{What is ``being cryptographic''?} makes it impossible to compute a set of blocks that form a cycle.
(\ib) A signed hash pointer informs of the creator of the pointed block and its authenticity without revealing the contents of the block.
(\ic) As the hash function is assumed to be collision free, 
in the following we use the $p$-pointer $h^p$ of a block $(h^p,H,x)$ as the block's name.
(\id) Here, the non-initial blocks created by a correct agent have exactly one self-pointer and form a single chain that ends in an initial block. \andy{Is this part of the definiton? It's not stated in the definition above, and it seems like you are pointing to a consequence of the definition.}
    %\item In principle, different agents, even different blocks, may use different hash functions, provided pointers are extended so that which hash function a pointer uses is provided by the pointer.  This facilitates a more flexible grassroots deployment, as different protocol instances may employ different hash functions, as well as more flexible protocol upgrade, as agents may change the hash function they use midstream provided the change is disclosed.
%When it does not cause confusion we abbreviate $\calB(P)$ as $\calB$.

A blocklace  $B \subseteq \calB(P)$ induces a finite-degree directed graph $(B, E)$, $E \subset B \times B$, with blocks in $B$ as vertices and directed edges $(b,b') \in E$ if $b \in B$ includes a hash pointer to $b' \in B$. We overload $B$ to also mean its induced directed graph $(B,E)$, and following standard DAG terminology refer to a block with zero in-degree in a blocklace as a \temph{root} of the blocklace. \andy{I think it worth noting that this terminology may cause confusion. See \url{https://ericsink.com/vcbe/html/directed_acyclic_graphs.html}. They use the term leaf for this (as in other places). Might be worth adding a footnote. } Note that the directed graph induced by any blocklace is acyclic. 

\begin{definition}[$\succ$, Observe]\label{definition:observe}
The partial order $\succ$ over $\calB(P)$ is defined by $b'\succ b$ if there is a nonempty path from $b'$ to $b$ in $\calB(P)$.  
%
A block  $b'$ \temph{observes} $b$ if $b'\succeq b$. Agent $p$ \temph{observes $b$ in} $B$ if there is a $p$-block $b' \in B$ that observes $b$. 
%, and a group of agents $Q \subseteq \Pi$ \temph{observes $b$ in} $B$ if every agent $p \in Q$ observes $b$.
%
%The \temph{closure} of a block $b$ is $[b] := \{b' : b\succeq b'\}$ and the \temph{closure} of a blocklace $B$ is $[B] := \bigcup_{b\in B} [b]$.  A blocklace $B$ is \emph{closed} if $B = [B]$.
\end{definition}
%This notion of closure is employed extensively by blocklace protocols that require all-to-all dissemination, e.g. the Cordial Miners consensus protocols~\cite{keidar2022cordial}. Grassroots dissemination requires a more refined notion of closure for the local blocklace of an agent, presented below.
%




\subsection{The \CGD Protocol}
%$\calCGD$}

The \CGD protocol $\calCGD$ realizes the two principles as follows.
Disclosure is realized by a new $p$-block serving as a \emph{multichannel ack/nack message}, informing its recipient whether it follows another agent $q$, and if so also of the latest $q$-block known to $p$, for every $q \in P$. 
This is realized by the notions defined next and illustrated in Figure \ref{figure:p-closure}.

\begin{definition}[Closure, Self-Closed, Closed, $p$-Closed, Maximally-Closed]\label{definition:p-closure}
Given a blocklace $B$ and a block $b \in \calB(P)$, the \temph{closure}  $[b]_B$ of $b$ in $B$ is the set of blocks reachable from $b$ in $B$ via a (possibly-empty) path with at most one non-self pointer. We abbreviate  $[b] := [b]_B$ if $B$ is clear from the context. The block $b$ is \temph{self-closed} in $B$ if the maximal path of self-pointers from $b$ in $B$ ends in an initial block, and \temph{closed} in $B$ if every block in $[b]$ is self-closed. The blocklace $B$ is \temph{$p$-closed} if every $p$-block in $B$ is closed in $B$. 
A $p$-block closed in $B$ is \temph{maximally-closed} in $B$ if it observes every self-closed $q$-block in $B$ for every $q\in P$ followed by $p$ in $B$.
\end{definition}
As we shall see, a correct agent $p$ always maintains a $p$-closed blocklace and produces only maximally-closed $p$-blocks, thus abiding by the principle of disclosure.

\begin{wrapfigure}{r}{5cm}
  \begin{center}
   \includegraphics[width=5cm]{Figs/follow.jpeg}
  \end{center}
  \caption{$p$-Closure and $p$-Closed (Def. \ref{definition:p-closure}): The $p$-closure  $[b]_p$ of the $p$-block $b$ includes the self-path from $b$, the $q$ self-path starting from the $q$-block  pointed to by $b$,  and the $q'$ self-path starting from the (second from top) $q'$-block  pointed to by $b$, all ending in their respective initial blocks.  Non-self pointers are left dangling in $[b]_p$ if from $q$- and $q'$-blocks, but not from $p$-blocks.  
  Still, the entire blocklace shown in the figure, including the top $q'$-block, is $p$-closed.
  }
\label{figure:p-closure}
\end{wrapfigure}
The local state in the protocol presented includes a blocklace and block messages.  

\begin{definition}[Blocklace Message, Blocklace Messaging Local States Function and Configuration, Blocklace of a Configuration]\label{definition:blocklace-configuration}
Given $P \subseteq \Pi$, a \temph{blocklace message} over $P$ is a pair $(p,b)$, with $p \in P$ being its \temph{destination} and $b\in \calB(P)$  its \temph{payload}. 
%
The \temph{blocklace messaging local states function} \textit{MSB}  maps $P$ to the set of all pairs $(B,Out)$, where $B$ is a finite subset of  $\calB(P)$ and $Out$ a finite set of blocklace messages over $P$.  Here,
$B$ is referred to as the \emph{local blocklace} and  $Out$ as the \emph{output messages} of the local state.  The associated partial order is defined by  $(B,Out) \preceq_{MSB} (B',Out')$
if $B \subseteq B'$ and $Out \subseteq Out')$.
%
A \temph{blocklace messaging configuration} $c$ over agents $P$ is a 
configuration over $P$ and \textit{MSB}.
The blocklace of a blocklace messaging configuration $c$ is defined by $B(c) := \bigcup_{p \in P, c_p=(B_p,Out_p)} B_p$.
\end{definition}

For a configuration $c$ over $P$ and \textit{MSB}, a block $b$ and $p \in P$ we use $b \in c_p$ for
$c_p=(B_p,Out_p) \& b \in B_p$.  With this abbreviation, definition of follows, needs, friend, and social graph for the blocklace messaging configurations is identical to their definition for simple blocks and its configurations (Def. \ref{defininition:follows}), except for replacing the simple blocks local state function $SB$ by the blocklace messaging local state function \textit{MSB}.

A key advantage of the blocklace is that agents may know global properties based on their local blocklace, provided these properties are monotonic wrt the subset relation (and thus hold globally, for the union of all local states, if they hold locally), as follows:
\begin{definition}[Agent Knowledge]\label{definition:agent-knowledge}
Given a blocklace configuration $c$ over $P$, an agent $p \in P$ \temph{knows a block $b$} in $c$ if $b \in c_p$, and $p$ \temph{knows a property} of the blocklace of configuration $c$ if the property is monotonic wrt the subset relation and holds in its local blocklace $c_p$.  In particular, $p$ \temph{knows that $q$ knows $b$} in $c$ if $c_p$ has a $q$-block that observes $b$; \temph{$p$ knows that $q$ follows $p'$ in $c$} if $c_p$ has a $q$-block that observes a $p'$-block;  and \temph{$p$ knows that $p'$ and $q$ are friends in $c$} if $p$ knows that $p'$ follows $q$ in $c$ and $p$ knows that $q$ follows $p'$ in $c$ (with $p=p'$ a special case).
\end{definition}

Pseudocode realizing basic blocklace utilities needed for grassroots dissemination are presented as Algorithm \ref{alg:blocklace}.

\input{Code/blocklace}

\begin{definition}[$\calCGD$:  Grassroots Cordial  Dissemination]\label{definition:protocol-GCD}
The $\calCGD$ \temph{grassroots cordial dissemination} protocol has for each $P \subseteq \Pi$  a distributed transition system $\text{GCD}=(P,\textit{MSB},T,\lambda)$ with transitions $T$  being all $p$-transitions $c\xrightarrow{}c'$, where $p \in P$, $c_p= (B,Out)$ and one of the following holds:
\begin{enumerate}[partopsep=0pt,topsep=0pt,parsep=0pt]
    \item[1.]  \textbf{Create\&Disclose}:  $c'_p := (B \cup \{b\},Out)$ and $b \in \calB(P)\setminus B$ is a $p$-block maximally-closed in $B$, or
    \item[2.] \textbf{Send-$b$-to-$q$}: $c'_p :=(B,Out \cup \{(q,b)\})$, $b \in B$ 
    \item[3.] \textbf{Receive-$b$}:   $c'_p := (B \cup \{b\},Out)$, $b\notin B$, and for some $q \in P$, $(p,b) \in Out_q$,  $c_q=(B_q,Out_q)$.
    \item[4.] \textbf{Cordially-Send-$b$-to-$q$}: $c'_p :=(B,Out \cup \{(q,b)\})$,  $b \in B$,  $(q,b) \notin Out$, and (\ia) $p$ knows  that $q$ is a friend,  (\ib) $p$ knows that $q$ follows the creator of $b$,  (\ic) $p$ does not know that $q$ knows $b$.
\end{enumerate}
The liveness condition $\lambda$ partitions the $p$-transitions Create\&Disclose, Cordially-Send, and Receive according to their labels.
\end{definition}
\mypara{Notes} Disclosure is realized by the Create\&Disclose transition choosing a maximally-closed $p$-block, and cordiality is realized by the Cordially-Send-$b$-to-$q$, with which $p$ sends any $p'$-block $b$ it knows to any friend $q$ that $p$ believes needs it. Namely, for which $p$ knows that $q$ follows $p'$ and $p$ doesn't know that $q$ knows $b$. If $q$ knows $b$ then $p$ would eventually know that, when it receives the next $q$-block that discloses knowledge of $b$.  The special case of Cordially-Send, where $p=p'$ and $b$ is a $p$-block, is simply dissemination among friends. Simple (volitional) Send can be used by an agent to send any block it has to any other agent. The recipient of a volitionally sent $q$-block can then follow $q$ starting from that block.  Similarly, two agents can send each other blocks to become friends.
%
The liveness condition requires an agent to disclose every so often the blocks they know, to eventually send any block that satisfies the specified conditions, and receive any block sent to it that it does not know already, but it does not require an agent to follow other agents or to voluntarily send any block.

Unlike in $\calG\calD$, where $p$ can construct a simple initial $q$-block, here the initial $q$-block includes a hash pointer signed by $q$, which cannot be created/forged by $p$. 
%

\mypara{Asynchrony} The model of asynchrony assumes that each message sent among correct agents is eventually received and an that an adversary may control, in addition to the faulty agents, also the order of message arrival among all agents.
These assumptions are satisfied  by the liveness requirement of $\calCGD$.  Liveness ensures that communication is reliable, as any message sent among correct miners is eventually received, yet there is no bound on the finite delay of message arrival, as postulated by the model. Correctness of an agent requires it to be correct in all computations,   hence the system has to be resilient to an adversary that controls not only faulty agents but also the order of transitions by correct agents.  Controlling the order of Receive transitions amounts to control of the order of message arrival, as postulated by the model.
The following proposition is the analogue of Proposition \ref{proposition:GD-local-liveness} for $\calG\calD$, with an analogue proof.

\begin{proposition}[$\calCGD$ Grassroots Liveness]\label{proposition:GCD-local-liveness}
Let $r$ be a run of $GCD$, $p,q \in P$.
If in some configuration $c \in r$, $p$ and $q$ are connected via a friendship path, all of its members follow $q$ in $c$ and are correct in $r$, then for every $q$-block $b$ in $r$ there is a configuration $c' \in r$ for which 
$b \in c'_p$. 
\end{proposition}



\begin{restatable}[]{proposition}{GCDgrassroots}\label{proposition:GCD-grassroots}
The \CGD protocol $\calCGD$ is grassroots.
\end{restatable}


\subsection{A Grassroots Implementation of $\calCGD$ by $\calG\calD$}


\andy{Title above the wrong way around?} We use the theorem above to show that:

\begin{theorem}\label{theorem:GCD-implements-GD}
$\calCGD$ can provide a grassroots implementation of $\calG\calD$.
\end{theorem}

We employ the notion of monotonic-completeness wrt to a partial order to prove the correctness of the implementation:
\begin{definition}[Monotonically-Complete Transition System]\label{definition:monotonic}
A transition system $TS=(P,S,T,\lambda)$ over $P\subseteq \Pi$ and a local states function $S$ is \temph{monotonically-complete} wrt a partial order $\prec$ if it is monotonic wrt $\prec$ and  $c0 \xrightarrow{*} c \subseteq T$ and $c \preceq c'$ implies that $c \xrightarrow{*} c' \subseteq T$.
\end{definition}
The partial order $\prec_S$ is often too broad to satisfy this definition, hence in the following we consider a restriction of it, namely a subset $\prec \subseteq \prec_S$.  

%In the following we abbreviate $\prec_S$ and $\prec_{S'}$ as $\prec$ and $\prec'$, respectively.
\begin{definition}[Order-Preserving Implementation]\label{definition:op-implementation}
Let  $TS=(P,S,T,\lambda)$ and $TS'=(P,S',T',\lambda')$ be  transition systems over $P$ and local state functions $S$ and $S'$,  monotonically-complete wrt $\prec \subseteq \prec_S$ and $\prec' \subseteq \prec_{S'}$, respectively.
Then an implementation $\sigma : C' \rightarrow C$ of $TS$ by $TS'$ is \temph{order-preserving} wrt $\prec$ and $\prec'$ if:
\begin{enumerate}[partopsep=0pt,topsep=0pt,parsep=0pt]
    \item \temph{Up condition:} 
     $c1' \preceq_{S'} c2'$ implies that $\sigma(c1') \preceq \sigma(c2')$
    \item \temph{Down condition:}  $c0 \xrightarrow{*}c1 \subseteq T$, $ c1 \preceq c2$ implies that there are $c1',c2' \in C'$ such that $c1= \sigma(c1')$, $c2= \sigma(c2')$, $c0' \xrightarrow{* }c1' \subseteq T'$ and $c1' \preceq' c2'$.
\end{enumerate}
\end{definition}

\begin{theorem}[Correct \& Complete Implementation Among Monotonically-Complete Transition Systems]\label{theorem:sigma-op}
Assume two transition systems $TS=(P,S,T,\lambda)$ and $TS'=(P,S',T',\lambda')$, wrt $P$ and local state functions $S$ and $S'$,  monotonically-complete wrt $\prec \subseteq \prec_S$ and $\prec'\subseteq \prec_{S'}$, respectively, and an implementation $\sigma : C' \rightarrow C$  of $TS$ by $TS'$. 
%Furthermore, assume that $\preceq$ is %strict and 
%unbounded. 
If $\sigma$ is order-preserving  wrt $\prec$ and $\prec'$ and productive then it is correct and complete.
\end{theorem}
With this background, we can prove the main Theorem:

\begin{proof}[Proof Outline of Theorem \ref{theorem:GCD-implements-GD}]
We define a piecemeal implementation $\sigma$ of  $\calG\calD$ by $\calCGD$ (Def. \ref{definition:sigma-GCD-GD}), prove that  $\calG\calD$ and $\calCGD$ are monotonically-complete (Prop. \ref{proposition:GD-MC},  \ref{proposition:GCD-MC})
wrt $\prec_{\calG\calD}$ (Def. \ref{definition:prec-GD}) and $\prec_{\calCGD}$ (Def. \ref{definition:prec-GCD}), respectively, 
and prove that $\sigma$ is order-preserving (Prop. \ref{proposition:sigma-op-GD-GCD}).  Together, these propositions and Theorem \ref{theorem:sigma-op} imply that $\sigma$ is correct.
The implementation $\sigma$ is piecemeal by construction and $\calCGD$ is grassroots by Prop. \ref{proposition:GCD-grassroots}.  Hence by Def. \ref{definition:grassroots-implementation}, the pair $(\calCGD,\sigma)$ constitutes a grassroots implementation of $\calG\calD$, which completes the proof.
\end{proof}


The implementation $\sigma$ defined next is piecemeal. For each local state $c_p=(B_p,Out_p)$, it ignores the block messages $Out_p$, and
maps each block in $B_p$ to a simple block by stripping its hash pointers and adding an index.

\begin{definition}[$\sigma:\calCGD \mapsto\calG\calD$]\label{definition:sigma-GCD-GD}
Given a $p$-closed blocklace $B$, the \emph{index} of a $p$-block $b \in B$, $\textit{index}(b)$ is the length of the path of self-pointers from $b$ to the initial $p$-block.
The piecemeal implementation $\sigma$  maps each local state $c_p=(B_p,Out_p)$, $p\in P$, in configuration $c$ over $P \subseteq \Pi$, to the local state
$\sigma(c_p) := \{(q,x,\textit{index}(b)) : b=(h^q,H,x) \in B_p \text{ is self-closed and $p$ follows $q$ in $B$}\}$.
\end{definition}


\subsection{Pseudocode Implementation of Grassroots Cordial Dissemination}
The \CGD protocol was specified as a family of asynchronous distributed multiagent transition systems $\calCGD$ (Def. \ref{definition:protocol-GCD}). 


\input{Code/dissemination-asynchrony.tex}

\mypara{Asynchrony} Algorithm \ref{alg:GCD} presents pseudocode implementation of the protocol for a single agent $p$ for the model of Asynchrony.  The comments indicate which transition rule is realized by what code.
We assume that the agent $p$ can interact with the protocol application that runs on their personal device. In particular, $p$ can specify the payload for a new block or decide to send any block it knows to any other agent.  As according to the model of asynchrony each message sent is eventually received,  we assume the \textbf{reliably\_send} construct to keep a record of sent messages so as not to send the same message to the same agent twice, implementing the requirement $(q,b) \notin Out$ of the Cordially-Send-$b$-to-$q$ transition. The construct \textbf{upon eventually} is also 
geared for the model of asynchrony: It is a `timeless timeout' with no notion of time, only with a guarantee of eventuality.  

The implementation of grassroots dissemination for asynchrony assumes reliable communication, readily implemented by TCP.  However, for grassroots dissemination to reach its full potential it must be designed for mobile agents using unreliable communication, namely UDP.
With TCP, smartphones can establish a connection only with the help of an agreed-upon third party, which undermines grassroots and digital sovereignty, and the connection needs reestablishing upon roaming to a new IP address. 
With UDP, a connection is not needed and incorporating the  sender's current IP address in a block lets recipients (re)transmit blocks to the sender's updated IP address, allowing roaming agents to remain connected to their friends.  Furthermore, the ability of a block in a blocklace to function as a multichannel ack/nack message shines in a UDP implementation, as a received $p$-block $b$ (even if received indirectly, not from $p$) makes redundant the (re)transmission to $p$ of any block observed by $b$. 


\input{Code/dissemination-UDP}

\mypara{Mobile Agents Communicating via UDP} A refinement of the \CGD protocol for mobile (address-hopping) agents communicating over an unreliable network, namely smartphones communicating via UDP, is presented as Alg. \ref{alg:GCD-UDP}.
Cordial dissemination over UDP exploits the ack/nak information of blocklace blocks to its fullest, by $p$ retransmitting to every friend $q$ every block $b$ that $p$ knows (not only $p$-blocks) and believes that $q$ needs, until $q$ acknowledges knowing $b$.  The sending of unsolicited blocks (Send-$b$-to-$q$) does not guaranteed delivery, and if delivered does not guarantee acknowledgement, unless the block is a friendship offer (with a $(\textit{`follow'},q)$ payload), and the recipient $q$ accept the offer (creating a block with a $(\textit{`follow'},p)$ payload).  Assuming that timeouts are separated by seconds and mobile address changes are separated by hours,  the probability of two friends hopping together without one successfully informing the other of its new IP address is around $10^{-7}$.
If the two hopping friends have a stationary joint friend, then it is enough that one of the hoppers successfully informs the stationary friend of the address change, for the other hopper  to soon know this new address from their stationary friend.
Under the same assumptions, the probability of a clique of $n$ friends loosing a member due to all hopping simultaneously is around $10^{-3.6*n}$.  Note that such a loss is not terminal --  assuming that friends have redundant ways to communicate (physical meetings, email, SMS, global social media), new addresses can be communicated and the digital friendship restored.  We note that the timer need not be of fixed duration and global  -- an adaptive timer for each friend might prove more efficient. 



\section{Applications of \GD Supporting Digital Sovereignty}\label{section:applications}

We describe applications of \GD that support digital sovereignty by not depending on or employing any third-party resources other than the network itself, and thus provide  motivation for implementing the \GD  protocol.

\subsection{Grassroots Twitter-Like Social Networking}\label{section:Twitter-DBD}

Here we illustrate how a Twitter-like grassroots social network can be realised on top of \GD.
Recall that any block $(p,i,x)$ is uniquely identified by its creator $p$ and index $i$, provided the creator is not equivocating.
%
The Twitter-like realization employs two types of payloads, $\textit{tweet}(x)$, where $x$ is any text string, and
$\textit{respond}(p,i,x)$, which includes the text string $x$ as a response to the $p$-block with index $i$.

With \GD, an agent $p$ will observe any tweet and any response by every agent that $p$ follows.  But, $p$ will not observe responses to tweets of agents that it follows, if $p$ does not follow the respondents.   This behavior could be desirable, if indeed $p$ prefers not to hear these respondents; or undesirable, if $p$ does not know the respondents but would be interested to hear what they have to say.  This can be addressed by adding a third type of payload,
$\textit{echo}(b)$, where $b$ is a block.  With this construct an agent $p$ could echo responses to its own tweets, for the benefit the agents that follow $p$ but not the respondents.  Doing so could induce  an agent to enlarge the set of agents it follows, if it finds agents whose echoed responses are of interest.
%
This completes the high-level description of how to implement serverless Twitter-like social networking with grassroots dissemination.  

\subsection{Grassroots WhatsApp-Like Social Networking}\label{section:WhatsApp-DBD}

Here we illustrate how a WhatsApp-like grassroots social network can be realised on top of \GD, using the same three payload types, \textit{tweet}, \textit{respond}, and \textit{echo}.
A group is initiated by $p$ creating block $b$ with a special tweet that declares the group formation and invites friends to join the group.  All communications in the group are direct or indirect responses to $b$.  While all group members are friends of $p$, they may not necessarily follow each other.  Therefore,  $p$ echoes all direct or indirect responses to $b$ by members of the group.  This way every group member can follow the group and contribute to it, and a user-interface can make group communication look and feel like a regular messaging group. The group founder $p$ can easily add or remove agents by echoing or ceasing to echo their responses to $b$. 
%
A group like this is public in that any follower of $p$ can follow the group. If $p$ wishes the group to be private, it can secretly share a new key-pair with all members of the group (as $p$ knows their public key), and have all group communication be encrypted and decipherable only by group members.    If a member leaves an encrypted group, $p$ has to share a new key-pair with the remaining group members.

Another way to ensure privacy is to initiate a separate blocklace for each new group.  This line of thought will be investigated in a separate paper.


\subsection{Grassroots Sovereign Cryptocurrencies}\label{section:Twitter-DBD}

Sovereign cryptocurrencies were introduced in reference~\cite{shapiro2022sovereign}, with an implementation by the \AD protocol $\calA\calD$ (Appendiex \ref{appendix-section:protocol-AD}).  However, sovereign cryptocurrencies do not need all-to-all dissemination: It is enough that dissemination `follows the money'.  This can be achieved by people adhering to the following conservative principle:  Transact only with friends, and only hold coins created by a friend (not the sovereigns include not only people but also legal persons such as banks, corporations, municipalities and states; hence a person its bank may be `friends' in this technical sense and hold each other's coins). 
The key operation of sovereign cryptocurrencies is coin redemption,
which provides for fungibility, equivocation-exclusion, credit-risk management, coin-trading, chain payments and arbitrage.  With it, an agent $p$ that holds a $q$-coin requests $q$ to redeem this coin for another coin $q$ holds.  Making and serving this request requires bi-directional communication between $p$ and $q$, which can happen by default with \GD if $p$ and $q$ are friends.
Thus, by following this principle, the \GD protocol $\calG\calD$ 
can provide a correct implementation of sovereign cryptocurrencies.  Transacting with non-friends is also possible through `direct messages' (the Send transition), but without the ability to verify that the other party is following the protocol. Proving this formally requires the entire mathematical machinery of sovereign cryptocurrencies~\cite{shapiro2022sovereign} and is beyond the scope of this paper.


\section{Future Work \& Discussion}\label{section:conclusions}

\mypara{Grassroots dissemination for sovereign cryptocurrencies} While the \GD protocol $\calG\calD$ is better-suited for  implementing sovereign cryptocurrencies than the \AD protocol $\calA\calD$, it should be refined to support a genuinely-practical implementation, allowing an agent to:
(\ia)  Follow another agent starting from an arbitrary block (not from its initial block), in particular from the first block recording a transaction between the two agents.  
(\ib) Unfollow an agent, for example when financial relations between the two have ended, permanently or temporarily.
Such extensions to $\calG\calD$ are possible with little additional implementation effort and with some additional mathematical effort for specifying them and proving them correct.


\mypara{Grassroots and the Internet} Formally, the underlying Internet protocol stack is not grassroots, as IP addresses are allocated top-down, with a central entity (IANA) at the top.  Does this mean that striving for grassroots protocols is futile?  We do not think so.  First, the full benefits of grassroots protocols can be reaped as long as IANA  does not abuse IP address allocation and Internet access is not restricted or abused. 
Second, if the local regime  restricts access to servers/services, but does not shut-down the Internet,  grassroots protocols may still operate.  Third, mobile mesh networks or SPANs (Smartphone ad-hoc networks)~\cite{albrecht2021mesh} allow communities to communicate in times of strife (e.g. demonstrations against the regime) without an Internet provider (but current designs are vulnerable~\cite{albrecht2021mesh}).  Extending the UDP-based \CGD protocol to a mobile mesh protocol is a goal of our future research.
Achieving it would realize the original vision of Xerox PARC's Bayou~\cite{demers1994bayou} project, of peer-to-peer update upon physical proximity. 

\mypara{Acknowledgements}
Ehud Shapiro is the Incumbent of The Harry Weinrebe Professorial Chair of Computer Science and Biology at the Weizmann Institute.  I thank Nimrod Talmon and Oded Naor for their comments on an earlier version of the manuscript and Idit Keidar for pointing me to related work.



%%
%% Bibliography
%%

%% Please use bibtex, 

\bibliography{bib}

\appendix

\section{Preliminaries: Asynchronous Distributed Multiagent Transition Systems}\label{section:preliminaries}

Here we introduce definitions and results regarding asynchronous distributed multiagent transition systems~\cite{shapiro2021multiagent},  needed for the definition and proofs of grassroots protocols. The original reference introduces them in four stages: transition systems; multiagent; distributed; asynchronous, and in addition to proofs it includes examples illustrating the various concepts. Here, we introduce distributed multiagent transition systems at once and simplify other notions by adhering to this special case.

Assume a set $\Pi$ of agents, each equipped with a single and unique key-pair, and identify an agent  $p \in \Pi$ by its public key.  While the set of all agents $\Pi$ could in principle be infinite (think of all the agents that are yet to be born), when we refer to a particular set of agents $P \subseteq \Pi$ we assume $P$ to be finite.


\begin{definition}[Local States, $\prec$, Initial State]
A \temph{local states function} $S$ maps every set of agents $P \subseteq \Pi$ to a set of \temph{local states} $S(P)$. A local states function $S$ has an associated partial order $\prec_{S}$ over the elements in its range that is unbounded over $S(P)$ for every $\emptyset \subset P \subseteq \Pi$ and has a minimal element $s0$, referred to as the \temph{initial local state} of $S$.
\end{definition}
Intuitively, think of $S(P)$ as the set of all possible sequences of messages among members of $P$; or the set of all possible  blockchains created and signed by members of $P$; or the set of all possible sets of posts/tweets and threads of responses to them by members of $P$. 
If the elements in the range of $S$ are sequences (of messages/blocks), then $\prec_{S}$ could be the prefix relation and $s0$ the empty sequence; if the elements in the range of $S$ are sets, then $\prec_{S}$ could be the subset relation and $s0$ the empty set. 
\andy{I will have a go at rewording this definition, as per our discussion.  It seems what is needed is that there is a set of all sequences, which $\prec_S$ partially orders, then $S(P)$ selects a subset of that set of all possible sequences, which inherits the ordering given by $\prec_S$. Should also emphasize that each sequence represents a set of possible states for an individual member of $P$, rather than for the members of $P$ as a whole.} 


%
A distributed multiagent transition system operates on \emph{configurations} over local states via \emph{transitions}, defined as follows:
\begin{definition}[Configuration, Transition, $p$-Transition, $\prec$]
Given a set of local states $X$ and a finite set of agents $P\subseteq \Pi$, a \temph{configuration} $c$ over $P$ and $X$ is a member of $C:=X^P$, namely $c$ consists of a set of local states indexed by $P$.  When $X =S(P)$ for a local states function $S$ we refer to a configuration over $P$ and $S$.
%
Given a configuration $c \in C$ and an agent $p \in P$, $c_p$ denotes the element of $c$ indexed by $p$, referred to as the \temph{local state of $p$ in $c$},
and $c0:=\{s0\}^P$ denotes the \temph{initial configuration}.
%
A \emph{transition} over $P$  and $X$ is a pair of configurations over $P$ and $X$, written $c \rightarrow c' \in C^2$.  If $c_p \ne c'_p$ for some $p \in P$ and $c'_q = c_q$ for every $q \ne p \in P$, the transition is a \temph{$p$-transition}.
%Let $CC(P)$  denote the set of transitions over $P$.
%
A partial order  $\prec$ on local states induces a partial order on configurations, defined by $c \preceq c'$ if $c_p \preceq c'_p$ for every $p \in P$.  
\end{definition}



Note that the definition implies that $c \prec c'$ if  $c \preceq c'$ and $c \ne c'$, and that if a $p$-transition $c \rightarrow c'$ satisfies $c_p \prec c'_p$ then $c \prec c'$.
%
With this we define:
\begin{definition}[Distributed Multiagent Transition System; Computation; Run]\label{definition:DMTS}
A \temph{distributed multiagent transition system} over $P\subseteq \Pi$ and a 
set of local states $X$ with initial local state $s0 \in X$,
 $TS =(P,X,T,\lambda)$, has \temph{configurations} $C=S(P)^P$; \temph{initial configuration}  $c0:=\{s0\}^P$;  a set of \temph{correct transitions} $T = \bigcup_{p \in P} T_p \subseteq C^2$, where each $T_p$ is a set of \temph{correct $p$-transitions}; and a \temph{liveness requirement} $\lambda = \bigcup_{p \in P} \lambda_p$,
where $\lambda_p$ is a partition  of $T_p$. \andy{So far, the definition uses $S$ without explicitly listing it. Is the version with $X$ rather than $S$ really needed?}
When $X$ is given by a local states function $S$, $X=S(P)$ with minimal element $s0$, we abbreviate $TS=(P,S(P),T,\lambda)$ as $TS =(P,S,T,\lambda)$.
%
A \temph{computation} of $TS$ is a sequence of arrow-separated configurations over $P$ and $S$,  $r= c \xrightarrow{} c' \xrightarrow{}  \cdots $, with two consecutive configurations in $r$ referred to as a \temph{transition of $r$}.   A \temph{run} of $TS$ is a computation that starts with $c0$. \andy{Are runs always infinite sequences?}
\end{definition}
\andy{Not immediately clear to me why we want $\lambda_p$ to be a partition of $T_p$ rather than a collection of subsets of $T_p$.} Note that computations and runs may include  incorrect transitions and that the liveness requirement may be the trivial one, namely $\lambda_p = \{T_p\}$ for every $p \in P$.


\begin{definition}[Safe, Live and Correct Run]\label{definition:ts-slc}
Given a transition system  $TS=(P,S,T,\lambda)$, a computation $r$ of $TS$ is \temph{safe}, also $r \subseteq T$, if every transition of $r$ is correct.  We use  $c \xrightarrow{*} c' \subseteq T$ to denote the existence of a safe computation (empty if $c=c'$) from $c$ to $c'$. 
%
A transition $c'\rightarrow c''$ is \temph{enabled on $c$} if $c=c'$.
A run is \temph{live wrt $L \in \lambda$} if either $r$ has a nonempty suffix in which no transition in $L$ is enabled, or every suffix of $r$ includes a transition in $L$. A run $r$ is \temph{live} if it is live wrt every $L \in \lambda$.
A run $r$ is \temph{correct} if it is safe and live.
%
An agent $p \in P$ is \temph{safe in $r$} if $r$ includes only correct $p$-transitions;  is \temph{live in $r$} if for every $L \in \lambda_p$, $r$ is live wrt $L$; and  is \temph{correct} in $r$ if $p$ is safe and live in $r$. 
\end{definition}
Note that the trivial liveness requirement entails the standard one:  A run is live if for every agent $p$ that is enabled infinitely often, the run has infinitely many $p$-transitions.


A transition system is \emph{asynchronous} if progress by other agents cannot prevent an agent from taking an already-enabled transition.

\begin{definition}[Monotonic and Asynchronous Distributed Multiagent Transition System]\label{definition:multiagent-sa}
%\begin{definition}[Multiagent Distributed Transition Systems]\label{definition:multiagent}
A distributed multiagent transition system $TS=(P,S,T,\lambda)$ is 
\temph{monotonic} wrt a partial order $\prec$ if $c\rightarrow c' \in T$ 
implies that $c \prec c'$, and it is \temph{monotonic} if it is monotonic wrt $\prec_S$.  It is \temph{asynchronous} if it is monotonic and for every $p$-transition $c \xrightarrow{} c' \in T_p$, $T_p$ also includes every $p$-transition $d \xrightarrow{} d'$ for which  $c \prec_{S} d$ and
    $(c_p \rightarrow c'_p) = (d_p \rightarrow d'_p)$.
\end{definition}


\begin{definition}[Specification; Implementation: Piecemeal, Safe, Live, Correct and Complete]\label{definition:implementation}
Given two transition systems, $TS=(P,S,T,\lambda)$ over $P$ and $S$ (the \temph{specification}) and $TS'=(P,S',T',\lambda')$ over $P$ and $S'$, \temph{an implementation of $TS$ by $TS'$} is a function $\sigma : C' \rightarrow C$ where $\sigma(c0') = c0$, in which case the pair $(TS', \sigma)$ is referred to as  \temph{an implementation of $TS$}. The implementation is \temph{piecemeal} if  $\sigma$ is also defined for local states and satisfies $\sigma(c')_p = \sigma(c'_p)$ for every $c'\in C'$ and $p \in P$.
%
Given a computation $r'= c'_1\rightarrow c'_2 \rightarrow \ldots$  of $TS'$, $\sigma(r')$ is the (possibly empty) computation obtained from the computation $\sigma(c'_1)\rightarrow \sigma(c'_2) \rightarrow \ldots$ by removing consecutively repetitive elements so that $\sigma(r')$ has no \temph{stutter transitions} of the form $c \rightarrow c$. The implementation $(TS', \sigma)$ of $TS$ is \temph{safe/live/correct} if $\sigma$ maps every safe/live/correct $TS'$ run $r'$ to a safe/live/correct $TS$ run $\sigma(r')$, respectively, 
and is \temph{complete} if every correct run $r$ of $TS$ has a correct run $r'$ of $TS'$ such that $\sigma(r')=r$.
\end{definition}
Note that while an implementation in general is defined for configurations, a piecemeal implementation is defined for local states, which entails its definition for configurations.   Not all implementations presented in~\cite{shapiro2021multiagent} are piecemeal, but, as elaborated below, grassroots and piecemeal go hand-in-hand.
%
A key property of correct and complete implementations is their transitivity:
\begin{proposition}[Transitivity of Correct \& Complete Implementations]\label{proposition:impelementation-transitivity}
The composition of safe/live/correct/complete   implementations is safe/live/correct/complete, respectively.
\end{proposition}

\begin{definition}[$\sigma$: Locally Safe, Productive, Locally Complete]
Given two transition systems $TS=(P,S,T,\lambda)$ and $TS'=(P',S',T',\lambda')$ and an implementation $\sigma: S'(P) \mapsto S(P)$. 
Then $\sigma$ is:
\begin{enumerate}[partopsep=0pt,topsep=0pt,parsep=0pt]
    \item \temph{Locally Safe} if $c0' \xrightarrow{*} c1' \xrightarrow{} c2' \subseteq T'$ implies that  $c0 \xrightarrow{*} c1  \xrightarrow{*} c2 \subseteq T$ for $c1 := \sigma(c1')$ and $c2 := \sigma(c2')$. If $c1 = c2$ then the $T'$ transition  $c1' \xrightarrow{} c2'$ \temph{stutters} $T$.
    
     \item \temph{Productive} if for every $L \in \lambda$ and every correct run $r'$ of $TS'$,
     either $r'$ has a nonempty suffix $r''$ such that $L$ is not enabled in $\sigma(r'')$,
     or every suffix $r''$ of $r'$  \temph{activates} $L$, namely $\sigma(r'')$ has an $L$-transition.
    
    \item \temph{Locally Complete} if  $c0 \xrightarrow{*} c1\xrightarrow{} c2 \subseteq T$, implies that
    $c0' \xrightarrow{*} c1' \xrightarrow{*} c2' \subseteq T'$ for some $c1', c2' \in C'$ such that $c1= \sigma(c1')$ and
     $c2 = \sigma(c2')$. 
\end{enumerate}
\end{definition}

\begin{proposition}[$\sigma$ Correct and Complete]\label{proposition:sigma-correct}
If an implementation $\sigma$ is locally safe and productive then it is correct, and if in addition it is locally complete then it is complete.  
\end{proposition}



\section{All-to-All Dissemination is not Grassroots}\label{appendix-section:protocol-AD}

As a strawman, we recall the All-to-All Dissemination protocol $\calA\calD$ from~\cite{shapiro2021multiagent} and argue that it is not grassroots.  
%
We assume a given \emph{payloads function} $\calX$ that maps each set of agents $P$ to a set of payloads $\calX(P)$.  For example, $\calX$ could map $P$ to all strings signed by members of $P$; or to all messages sent among members of $P$, signed by the sender and encrypted by the public key of the recipient; or to all financial transactions among members of $P$. Remember that here $P$ are not `miners' serving transactions by other agents, but are the full set of agents, all participating the in protocol.
 
\begin{definition}[Simple Block, $SB$, $\prec_{SB}$]
  A \temph{simple block} over $P$ is a triple $(p,i,x) \in P \times \calN \times \calX(P)$.  Such a block is referred to as an \temph{$i$-indexed simple $p$-block with payload $x$}.  The local states function $SB$ maps $P$ to the set of all sets of simple blocks over $P$ and $\calX(P)$.
    The partial order $\prec_{SB}$ is defined  by $c \preceq_{SB} c'$ if
   $c, c'$ are configurations over $P$ and $SB$ and $c_p \subseteq c'_p$ for every $p \in P$.
\end{definition}
Note that  $c \preceq_{SB} c'$  implies that $c\prec_{SB} c'$ if $c_p \subset c'_p$ for some $p \in P$ and $c_q = c'_q$ for every $q \ne p \in P$.

\begin{definition}[$\calA\calD$:  \AD~\cite{shapiro2021multiagent}]\label{definition:AD}
\temph{All-to-all dissemination} $\calA\calD$ is a protocol over $SB$ that for each $P \subseteq \Pi$ has the transition system $AD= (P,SB,T,\lambda)$, with correct transitions $T$ having a $p$-transition $c \rightarrow c' \in T_p$, $c'_p = c_p \cup \{b \}$, $b= (p',i,x)$, for every   $p, p' \in P$,  $i \in \NN$, $x\in \calX(P)$, and either:
\begin{enumerate}[partopsep=0pt,topsep=0pt,parsep=0pt]
    \item \textbf{Create}: $p'=p$, $i = \text{ max } \{ j : (p,j,x') \in c_p\}+1$, or
    \item \textbf{$q$-Sent-$b$}: $p'\ne p$, $b \in c_q \setminus c_p$ for some $q \in P$,
    provided $i=1$ or $c_p$ has an $(i-1)$-indexed simple $p'$-block.  
\end{enumerate}
The liveness condition $\lambda$ places all $p$-transitions with the same label in the same set, for every $p \in P$.
\end{definition}
In other words, every agent $p$ can either add a consecutively-indexed simple $p$-block to its local state or obtain a block $b$ it does not have from another agent, provided $b$ is an initial block or $p$ already has $b$'s preceding  block.
The liveness condition ensures that every correct agent will receive any simple block created by a correct agent, and will eventually create a next block, but it leaves agents the freedom as to which blocks to create.


\begin{definition}[$\prec_{\calA\calD}$]\label{definition:prec-AD}
A configuration $c$ over $P$ and $SB(P)$, $P\subseteq \Pi$, is \temph{consistent} if for every $p$-block $b \in c$, $b \in c_p$, and it is \emph{complete} if for every $i$-indexed $q$-block $b\in c_p$, $c_p$ includes every $i'$-indexed $q$-block $b'$, for every $1\le i' < 1$, $p,q \in P$.   The partial order $\prec_{\calA\calD}$ is defined  by $c \preceq_{\calA\calD} c'$ if
  $c\prec_{SB}c'$ and $c$ and $c'$ are consistent and complete configurations over $P \subseteq \Pi$ and $SB$.
\end{definition}

\begin{proposition}\label{proposition:AD-MC}
$\calA\calD$ is monotonically complete wrt $\prec_{\calA\calD}$.
\end{proposition}
\begin{proof}[Proof of Proposition \ref{proposition:AD-MC}]
The initial configuration is consistent and complete by definition, and both $p$-transitions Create and $q$-Sent-$b$ maintain consistency and completeness by construction,
hence all configurations in a correct run are consistent and complete.
Consider a $p$-transition $c\rightarrow c'$  in a correct computation.
Both Create and $q$-Sent-$b$ increase $c_p$, hence $c\prec_{\calA\calD} c'$ and $\calA\calD$ is monotonic wrt $\prec_{\calA\calD}$.

To show that $\calA\calD$ is monotonically-complete wrt $\prec_{\calA\calD}$, consider two configurations $c\prec_{\calA\calD} c'$ over $P$ and $SB$.  Let $B:= B(c')\setminus B(c)$.  Consider the computation from $c$ that first has a Create $q$-transitions for every  $i$-indexed $q$-block $b \in B$, in increasing order of $i$,  followed by a 
$q$-Sent-$b$ $p$-transition for every $p'$-block $b \in B$, ordered according to the index of $b$ for each $p \ne p' \in P$, in some order of $p$ and $p'$.   It can be verified that such a computation is a correct $\calA\calD$ computation, as the conditions for the the  Create 
transitions are fulfilled due to $c$ being complete and since they are done in creasing index order, and the conditions for $q$-Sent-$b$ transitions with $b$ being a $p'$ block are fulfilled  due to $c$ being complete and since they are done in increasing order of the index of $b$, so that $p$ knows the predecessor of $b$, and since $c'$ is consistent then each sent block has already been created.
\end{proof}


\begin{observation}\label{observation:AD-not-grassroot}
The $\calA\calD$ protocol is not grassroots.
\end{observation}
\begin{proof}[Proof of Observation \ref{observation:AD-not-grassroot}]
A run of a group of agents $P$ executing $AD$, when placed within a larger context $P'$, violates liveness. In a run of $AD(P)$ agents create and receive blocks among themselves.    However, the liveness condition of $AD(P')$ is not satisfied if the agents in $P$ retain the same behavior in a run of $AD(P')$: The reason is that in  an $AD(P')$-run, the liveness condition requires that an agent $p \in P$   eventually receives all blocks created by all agents, including agents in $P' \setminus P$. The transition system $AD(P)$ has correct runs that do not satisfy this condition, which cannot be correct behaviors in $AD(P')/P$.  Hence it is not true that $AD(P) \subseteq AD(P')/P$, and thus $\calA\calD$ is not grassroots.
%\qed    
\end{proof}



\begin{observation}\label{obserbation:AD-interactiv-interfering}
The $\calA\calD$ protocol is asynchronous and interactive but interfering.
\end{observation}
\begin{proof}
Examining $\calA\calD$, it can be verified that it is asynchronous and  interactive, but it is an interfering protocol.  We have argued above that $\calA\calD$ is interactive.
Regarding non-interference safety,  agents in their initial state do not interfere with other agents performing Create or $q$-Sent-$b$ transitions amongst themselves.
However, the $\calA\calD$ liveness condition on $q$-Sent-$b$ requires an agent $p$ to eventually receive every block $b$ created by every other agent.  In particular, in the definition above blocks by agents in $P'\setminus P$.  Hence even if $p$ is live in a run $r$ of $P$, the same behavior of $p$ will not be live if the run is extended by agents in $P'\setminus P$, since $p$ would ignore their blocks, violating liveness.  Therefore the $\calA\calD$ protocol is interfering, and hence the following Theorem \ref{theorem:grassroots} does not apply to it.
%\qed
\end{proof}



\section{Proofs}


\GrassrootsLiveness*
\begin{proof}[Proof of Proposition \ref{proposition:GD-local-liveness}]
Let $r, p, q, c$ be as in the Proposition. 
The proof is by induction on $k$, the length of a friendship path $p_1,p_2,\ldots,p_k$ correct in $r$,  between $q=p_1$ and $p=p_k$ in $c$. Let  $b$ a $q$-block in $c_q \setminus c_p$.  If $k=1$ then $p=q$ and $b \in c_p$.  Assume the proposition holds for $k=n$ and we prove it for $k=n+1$.  By the inductive assumption, $p_n$ eventually knows $b$, namely there is a configuration $c' \in r$ such that $b \in c_{p_n}$, and since $p_n$ is correct by assumption it does not delete $b$ from its local state and hence this holds also for every configuration subsequent to $c'$.  Also by assumption, $p_n$ and $p$ are friends and both follow $q$.  Hence $q$-Disseminates-$b$ is enabled in $c'$ and in any subsequent $r$ configuration in which $b$ is not known by $p$. Since $p$ is live in $r$, then  by the liveness requirement on transitions labeled $p_n$-Disseminates-$b$, eventually such a transition must be taken or all such transitions  be disabled, which can happen if either $p_n$  deletes $b$ it from its local state, or if $p_{n+1}$ already knows $b$.  Since members on the path are correct they do not delete $b$ from their local state, this can only happen if $p_{n+1}=p$ knows $b$ via some other transition. In either case the outcome is that $p$ eventually knows $b$ in $r$. This completes the proof.
\end{proof}


\GDgrassroots*
\begin{proof}[Proof of Proposition \ref{proposition:GD-grassroots}]
We argue somewhat informally that the $\calG\calD$ protocol is asynchronous, interactive and non-interfering, satisfying the condition of  Theorem \ref{theorem:grassroots} for a protocol to be grassroots.
\begin{enumerate}
    \item \textbf{Asynchronous}: The protocol is asynchronous as it is monotonic and examining its two $p$-transitions shows that once a $p$-transition is enabled in a configuration, it remains enabled even if local states of other agents increase.
    \item \textbf{Interactive}: The protocol is interactive since when $P$ is embedded in $P'$, members of $P$ can follow members of $P' \setminus P$ and then receive their blocks, a new behavior not available when $P$ run on their own.  
    \item \textbf{Non-interfering}: The protocol is non-interfering since:
    \begin{enumerate}
        \item \textbf{Safety}: a group $P$ can proceeds with its internal dissemination even if there are agents outside $P$ who do nothing, and
        \item \textbf{Liveness}:  Here the difference between \AD and \GD comes to bear. In a $GD(P')$ run, an agent  $p \in P\subset P'$ may choose not to follow agents in  $P' \setminus P$, in which case the liveness condition of $GD(P')$ does not require $p$ to receive blocks from agents in   $P' \setminus P$.  Hence, if $p$ is live in a run of $GD(P)$, then with the same behavior $p$ is also live in a run of $GD(P')$.
    \end{enumerate}
\end{enumerate}
This completes the proof.
\end{proof}


\begin{proposition}\label{proposition:calb-well-defined}
$\calB(P)$ is well-defined.
\end{proposition}
\begin{proof}[Proof of Proposition \ref{proposition:calb-well-defined}]
Given $P\subseteq \Pi$, we enumerate recursively all elements of $\calB(P)$ and prove that the result is unique.  First, let $\calB$ include all initial blocks of the form $(p,\emptyset,x)$, for any $p \in \PP$ and $x\in \calX$.  
%
Next, iterate adding to $\calB$ all blocks of the form $(h_p,H,x)$, with $p \in \PP$, $x \in \calX$, and $H$ a finite set of hash pointers to blocks in $\calB$. 
%
Note that the resulting $\calB$ is acyclic and maximal by construction.  To prove that it is unique, assume that there are two sets $\calB \ne \calB'$ that satisfy our construction, and that wlog $\calB \not\subset \calB'$.  
%
Let $b=(h_p,H,a)$ be a first block such that $b \in \calB \setminus \calB'$, namely a block for which every block $b'$ pointed to by some $h \in H$ is in $\calB \cap \calB'$. As by assumption all blocks pointed to by $H$ are in $\calB'$, then by construction $\calB'$ includes $b$, a contradiction.
\end{proof}

\begin{observation}[$p$-Closure of $\calCGD$]\label{observation:GCD-p-closure}
Given a run $r$ of $GCD(P)$, if $p\in P$ is correct in $r$ then $c_p$ is $p$-closed for every $c\in r$.
\end{observation}
\begin{proof}[Proof of Observation \ref{observation:GCD-p-closure}]
The proof is by induction on the index of $c$ in $r$.
In the initial configuration $c0_p=\emptyset$  and hence closed.
Assume $t= c \rightarrow c' \in r$ and that the observation holds for $c$.  If $t$ is a non-$p$ transition then $c_p = c'_p$. Else one can verify that for each $GCD$ $p$-transition, $c'_p$ is $p$-closed by construction.
\end{proof}

\begin{proof}[Proof of Proposition \ref{proposition:GCD-local-liveness}]
The proof is the same as the proof of Proposition \ref{proposition:GD-local-liveness}, with two small modifications: (\ia) Instead of the single $p$-transition
$q$-Sent-$b$ of $GD$,  employed in both induction arguments, two transitions are needed:  The $q$-transition $q$-Sends-$b$, which enables the $p$-transition Receive-$b$.  Due to the liveness requirement of GCD, Receive-$b$ is eventually taken, resulting in $p$ knowing $b$ as required. (\ib) In GCD, the notion of agent knowledge relates to the local blocklace, which is only part of the local state, not to the entire local state as in $GD$.
\end{proof}

\GCDgrassroots*
\begin{proof}[Proof of Proposition \ref{proposition:GCD-grassroots}]
The proof is similar in structure to the proof of Proposition \ref{proposition:GD-grassroots}, but has additional details.
%
According to Theorem \ref{theorem:grassroots},
an asynchronous, interactive non-interfering protocol is grassroots.  
Consider  $\emptyset \subset P \subset P' \subseteq \Pi$. 
We argue that the $\calCGD$ protocol is:
\begin{enumerate}[leftmargin=*]
    \item \textbf{Monotonic}:  Inspecting the five transitions of the protocol, one can verify that $\calCGD$ is monotonic wrt the partial order $\prec_{MSB}$, as they all increase one of the arguments of the local state, except for Input-$b$, which moved $b$ from $In$ to $B$.  The partial order $\prec_{MSB}$ is specifically defined to ensure that this transition is also increasing.
    \item \textbf{Asynchronous}. Inspecting the five transitions of the protocol, one can verify  that $\calCGD$ is asynchronous wrt $\prec_{MSB}$.  The transition conditions that are not monotonic wrt the subset relation, namely ``no $q$-block observes $b$'' and ``$p$ does not know that $q$ knows $b$'' refer to the local state of $p$ and hence do not hamper asynchrony, which requires a transition to remain enabled despite a change of state by agents other than $p$.
    
    \item \textbf{Interactive}. Consider agents $p \in P$ and $q \in P'\setminus P$.
    In a $GCD(P')$ run, $p$ may receive an Offer-to-Follow from $q$ and  choose to Follow $q$, transitions not available in $GCD(P)$.  Hence 
    $\calCGD$ is interactive according to Definition \ref{definition:non-interfering}.
    
    \item \textbf{Non-interfering}.  According to Definition \ref{definition:non-interfering}, we have to argue, for every $\emptyset \subset P \subset P' \subseteq \Pi$ with transition systems $TS = (P,\textit{MSB},T,\lambda), TS' = (P',\textit{MSB},T',\lambda') \in \calCGD$:
\begin{enumerate}
    \item \textbf{Safety}: That for  every transition $c1 \rightarrow c2 \in T$,
$T'$ includes the transition  $c1' \rightarrow c2'$ for which $c1=c1'/P$, $c2=c2'/P$. 

Consider such a $T$ transition.   It only depends on blocks from agents in $P$.  Hence, by Definition \ref{definition:protocol-GCD},  $T'$ includes the transition $c1' \rightarrow c2'$, where the agents of $P' \setminus P$ are in their initial state, namely  $c1_p = c2_p = c0_p$ for every $p \in P' \setminus P$, and
$c1'_p = c2'_p = c0'_p$ for every $p \in P \setminus P'$.
    \item \textbf{Liveness}: That for every agent $p \in P$ and run $r$ of $TS$, if $p$ is live in $r$ then it is also live in every run $r'$ of $TS'$ for which $r'/P = r$.  
    
    Consider such a run $r$ of $TS$ and agent $p$ live in $r$.
    The only  additional transitions enabled for $p$ in a run $r'$ of $TS'$ for which $r'/P = r$, beyond those enabled in $r$, are Follow and Offer-to-Follow, for some $q \in P'\setminus P$.  But such transitions have no liveness requirement, and hence $p$ is also live in $r'$.
\end{enumerate}
\end{enumerate} 
This completes the proof.
\end{proof}



\begin{definition}[Dissemination Consistency]\label{definition:dissemination-consistent}
Let $c$ be a complete and consistent configuration over $P\subseteq \Pi$ and $SB$.
We distinguish between a block $b$ and its \emph{occurrences} in $c$,  denoting the occurrence of a block $b$ in the local state $c_p$ as $b_p$, for any $p \in P$.
%
A \temph{dependency graph} $DG=(V,E)$ over $c$ is a directed graph over the occurrences $V$ of the blocks in $c$ with directed edged $E$ over $V$. If $b_p \rightarrow b_q \in E$ we say that $b_p$ \temph{depends} on $b_q$.  The graph has edges $E$ as follows:
%
(\ia) For each non-initial $p$-block $b$ in $c$, the edges in $E$ among all occurrences of $b$ form an inverted spanning tree, with  $b_p$ as its sole sink.  The spanning tree encodes dependencies among the occurrences of a non-initial $p$-block $b$ in a possible dissemination order of $b$ starting with $b_p$, namely the creation of $b$ by $p$.
%
(\ib) For each edge $b_p\rightarrow b_q \in E$ among two occurrences of a non-initial $i$-indexed $p'$-block $b$, there are also the following three additional edges: Two edges, $b_p \rightarrow (q,1,\bot)_p$ and $b_p \rightarrow (p,1,\bot)_q$, which encode the dependency of the receipt of $b$ by $p$ from $q$ on $p$ and $q$ each knowing the other's initial block, namely on being friends. The third edge is  $b_p \rightarrow b'_p$, to the occurrence in $p$ of the $i-1$-indexed $p'$-block.  A configuration $c$ is \emph{dissemination consistent} if there exists a directed dependency graph $DG$ over $c$ that is acyclic.
\end{definition}
Recall that using a Follow transition, an agent $p$ can `invent' an initial $q$-block and include it in its local state, for any $p,q \in P$. Hence initial blocks have no dependencies.  

For two graphs $G=(V,E)$, $G'=(V',E')$,  $G \subseteq G'$ if $V\subseteq V'$ and $E\subseteq E'$.
\begin{definition}[$\prec_{\calG\calD}$]\label{definition:prec-GD}
The partial order $\prec_{\calG\calD}$ is defined  by $c \preceq_{\calG\calD} c'$ if
  $c\preceq_{SB}c'$ and $c, c'$ are consistent, complete (Def. \ref{definition:prec-AD}) and  dissemination consistent (Def. \ref{definition:dissemination-consistent}) configurations over $P \subseteq \Pi$ and $SB$, with acyclic dependency graphs $DG$, $DG'$, respectively, satisfying $DG \subseteq DG'$.
\end{definition}



\begin{proposition}\label{proposition:GD-MC}
$\calG\calD$ is monotonically complete wrt $\prec_{\calG\calD}$.
\end{proposition}

\begin{proof}[Proof of Proposition \ref{proposition:GD-MC}]
The proof is structurally similar to the proof of Proposition \ref{proposition:AD-MC}, with  modifications to take into account the dependency graph. The initial configuration is consistent, complete and grassroots-consistent  by definition, and all transitions maintain consistency and completeness by construction,
hence all configurations in a correct run are consistent and complete.
%
We show by induction that all configurations are also dissemination  consistent. Consider a $p$-transition $t= c\rightarrow c' \in T$  in a correct computation, with
$c$ being dissemination-consistent wrt an acyclic dependency-graph $DG=(V,E)$, and construct the graph $DG'=(V',E')$ as follows:  
\begin{enumerate}
    \item \textbf{Create}: If $t$ is a Create $p$-transition of a non-initial $i$-indexed block $b$, then let $e= b'_p \rightarrow b_p$ be an edge from the $p$-occurrence of the $i-1$-indexed $p$-block $b'$ to $b_p$, then $V'=V\cup \{b_p\}$,   $E'=E\cup \{e\}$.
    \item \textbf{Follow}:  If $t$ is a Follow transition with an initial block $b$, then  $V'=V\cup \{b_p\}$,   $E'=E$.
    \item \textbf{$q$-Disseminate-$b$}: If $t$ is a $q$-Disseminate-$b$ transition, with $b$ being an $i$-indexed $p'$-block,  then let $e:= b'_p \rightarrow b_p$ be an edge from the $p$-occurrence of the $i-1$-indexed $p'$-block $b'$ to $b_p$, $e1 := (q,1,\bot)_p \rightarrow b_p$,
    $e2 := (p,1,\bot)_q \rightarrow b_p$,
    then $V'=V\cup \{b_p\}$,   $E'=E\cup \{e, e1, e2\}$.
\end{enumerate}
 It can be verified that in all three cases $DG'$ is a dependency-graph of $c'$, and that if $DG$ is acyclic then so is $DG'$.  In addition, each of Create, Follow, and $q$-Sent-$b$ $p$-transitions increases $c_p$. Hence $c\prec_{\calG\calD} c'$ and $\calG\calD$ is monotonic wrt $\prec_{\calG\calD}$.

To show that $\calG\calD$ is monotonically-complete wrt $\prec_{\calG\calD}$, consider two configurations $c\prec_{\calG\calD} c'$ over $P$ and $SB$.  By Def. \ref{definition:prec-GD} the configurations are consistent, complete and  dissemination-consistent configurations over $P \subseteq \Pi$ and $SB$, with some acyclic dependency graphs $DG=(V,E)$, $DG'=(V',E')$, respectively, satisfying $DG \subseteq DG'$.

Let $B$ be a sequence of the block occurrences in $V'\setminus V$, topologically-sorted in accordance with $DG$.    We argue that there is a one-to-one correspondence between members of $B$ and transitions, and that the dependency graph ensures that each of these transitions is enabled, in order.
Consider the computation from $c\xrightarrow{*}c'$ that has transitions for the block occurrences in $B$, in order, as follows.  For the next block occurrence $b_p \in B$, the computation has the next $p$-transition:
\begin{enumerate}
    \item \textbf{Create}: If $b_p$ is a $p$-block, then Create $b$.
    \item \textbf{Follow}: If $b_p$ is an initial $q$-block, $p\ne q$, then Follow $b$.
    \item \textbf{$q$-Sent-$b$}: If $b_p$ is a non-initial block that depends on $b_q$ in $DG$, then  $q$-Sent-$b$. 
\end{enumerate}
It can be verified that such a computation is a correct $\calG\calD$ computation from $c$ to $c'$,
and is consistent with the dependency graph $DG'$, as the conditions and dependencies for
each of the transitions are guaranteed by ordering them in accordance with the dependence graph, and since the configurations are consistent, complete and dissemination-consistent:
The condition for the  Create transitions are fulfilled due to $c$ being complete and since they are done in creasing index order, according to $DG$. Follow transitions have no dependencies. The conditions and dependencies for $q$-Sent-$b$ transitions are fulfilled since, due to
ordering according to $DG$, the block $b$ occurs in $q$'s local state, the friendship between $p$ and $q$ has been established, and $p$ knows the predecessor of $b$ before the transition takes place due to the dependency in $DG$, as required.
Hence $\calG\calD$ is monotonically-complete wrt $\prec_{\calG\calD}$, which completes the proof.
\end{proof}



A GCD configuration records explicitly all the dependencies among the block occurrences in it, with one exception -- if the same block message is sent to the same agent by several agents,
the configuration does not record which of the messages was received.  Hence the cordial dependency graph has some nondeterminism.

\begin{definition}[Cordial Dissemination Consistency]\label{definition:cordial-dissemination-consistent}
Let $c$ be a complete and consistent configuration over $P\subseteq \Pi$ and \textit{MSB}, $c_p=(B_p,Out_p)$ for every $p \in P$.
%
A \temph{dependency graph} $DG=(V,E)$ over $c$ is a directed graph over $V$, occurrences of blocks and block messages in $c$, with directed edged $E$ over $V$ as follows:
(\ia) For every local state $c_p=(B_p,Out_p)$, and every block message $(q,b)_p \in Out_p$, there is an edge $(q,b)_p  \rightarrow b_p \in E$.
(\ib) For every non-$p$-block $b_p\in B_p$ and for some block message $(p,b)_q \in Out_q$, $q \ne p$, there is an edge $b_p \rightarrow (p,b)_q \in E$.
(\ic) In addition, $E$ has edges that encode the $p$-closure of every $q$-block $b_p=(h^q,H,x) \in B$:
%
If $p=q$ then for every pointer (and if $p\ne q$ then only for a $q$-pointer) $h \in H$ and block $b'_p\in B$ such that $h=hash(b')$,  $b_p \rightarrow b'_p \in E$.
%
A configuration $c$ is \emph{cordial-dissemination consistent} if there exists a directed dependency graph $DG$ over $c$ that is acyclic.
\end{definition}



\begin{definition}[$\prec_{\calCGD}$]\label{definition:prec-GCD}
The partial order $\prec_{\calCGD}$ is defined  by $c \preceq_{\calCGD} c'$ if
  $c\preceq_{SB}c'$ and $c$ and $c'$ are consistent, complete (Def. \ref{definition:prec-AD}) and  cordial dissemination consistent (Def. \ref{definition:cordial-dissemination-consistent}) configurations over $P \subseteq \Pi$ and $SB$ with acyclic dependency graphs $DG$, $DG'$ respectively, satisfying $DG \subseteq DG'$.
\end{definition}


\begin{proposition}\label{proposition:GCD-MC}
$\calCGD$ is monotonically complete wrt $\prec_{\calCGD}$.
\end{proposition}
\begin{proof}[Proof of Proposition \ref{proposition:GCD-MC}]
The proof is structurally similar to the proof of Proposition \ref{proposition:GD-MC}, with  modifications to take into account the differences in the dependency graph and transitions. The initial configuration is consistent, complete and grassroots-dissemination consistent  by definition, and all transitions maintain consistency and completeness by construction,
hence all configurations in a correct run are consistent and complete.
%
We show by induction that all configurations are also grassroots-dissemination  consistent. Consider a $p$-transition $t= c\rightarrow c' \in T$  in a correct computation, with
$c=(B,Out)$ being grassroots-dissemination consistent wrt an acyclic dependency-graph $DG=(V,E)$, and construct the graph $DG'=(V',E')$, $E \subseteq E'$, as follows: 
\begin{enumerate}
        \item  \textbf{Create}:  If Create adds $b_p=(h^p,H,x)$ to $B$, then $V':=V\cup \{b_p\}$,  and for every pointer  $h \in H$ and block $b'_p$ such that $h=hash(b')$,  $b_p \rightarrow b'_p \in E'$.
        
        \item \textbf{Send-$b$-to-$q$/Offer-to-Follow}: If Send-$b$-to-$q$/Offer-to-Follow adds $(q,b_{q,Out})$ to $Out$,
        then $V':=V\cup \{b\}$ and $(q,b) \rightarrow b_q \in E'$.
        
        
        \item \textbf{Receive/Follow}: If Receive/Follow adds $b_p$ to $B$,   then $V':=V\cup \{b_p\}$,  and if there is a self-pointer $h \in H$ and block $b'_p$ such that $h=hash(b')$,  $b_p \rightarrow b'_p \in E'$.
\end{enumerate}

 It can be verified that in all three cases $DG'$ is a dependency-graph of $c'$, and that if $DG$ is acyclic then so is $DG'$.  In addition, each of the transitions increases $c_p$ wrt $\prec_{\calCGD}$. Hence $c\prec_{\calCGD} c'$ and $\calCGD$ is monotonic wrt $\prec_{\calCGD}$.

To show that $\calCGD$ is monotonically-complete wrt $\prec_{\calCGD}$, consider two configurations $c\prec_{\calCGD} c'$ over $P$ and \textit{MSB}.  By Def. \ref{definition:prec-GCD} the configurations are consistent, complete and  cordial-dissemination consistent configurations over $P \subseteq \Pi$ and \textit{MSB}, with some acyclic dependency graphs $DG=(V,E)$, $DG'=(V',E')$, respectively, satisfying $DG \subseteq DG'$.

Let $\bar{V}$ be a sequence of the block occurrences and block messages in $V'\setminus V$, topologically-sorted in accordance with $DG$.    We argue that there is a one-to-one correspondence between members of $\bar{V}$ and transitions, and that the dependency graph ensures by construction that each of these transitions is enabled, in order. Consider the computation from $c\xrightarrow{*}c'$ that has transitions for the block occurrences in $B$, in order, as follows.  For the next element $v \in \bar{V}$, the computation has the next $p$-transition:
\begin{enumerate}
    \item \textbf{Create}: If $v=b_p$ is a $p$-block, then Create $b$.
    \item \textbf{Offer-to-Follow}: If $v=(q,b)$ and $b$ is an initial block,  then Offer-to-Follow with $(q,b)$.
    \item \textbf{Follow}: If $v=b_p$ is an initial $q$-block, $p\ne q$, then Follow $b$.
    \item \textbf{$q$-Sent-$b$}: If $b_p$ is a non-initial block that depends on $b_q$ in $DG$, then  $q$-Sent-$b$.
         \item \textbf{Receive-$b$}: If $v=b_p$ is a non-initial $q$-block, $q\ne p$,
         then Receive-$b$. 
\end{enumerate}
It can be verified that such a computation is a correct $\calCGD$ computation from $c$ to $c'$, and is consistent with the dependency graph $DG'$, as the conditions and dependencies for
enabling each of the transitions in turn are guaranteed by ordering them in accordance with the dependence graph, and since the configurations are consistent, complete and cordial-dissemination consistent.
Hence $\calCGD$ is monotonically-complete wrt $\prec_{\calCGD}$, which completes the proof.
\end{proof}


\begin{proposition}\label{proposition:sigma-op-GD-GCD}
$\sigma$ is an order-preserving implementation of $\calG\calD$  by $\calCGD$.
\end{proposition}
\begin{proof}[Proof of Proposition \ref{proposition:sigma-op-GD-GCD}]
Let $TS=(P,SB,T,\lambda) \in \calG\calD$ and $TS'=(P,\textit{MSB},T',\lambda')\in  \calCGD$ be two transition systems over $P$ and $SB/MSB$, respectively.
According to definition \ref{definition:op-implementation}, we have to prove two conditions.
For the Up condition, we it is easy to see from the definition of $\sigma$ that  $c'_1 \preceqGCD  c'_2$ for $TS'$ configurations $c'_1, c'_2$  implies that $\sigma(c'_1) \preceqGD \sigma(c'_2)$, as $\sigma$ maps blocklace blocks to simple blocks and ignores block messages. 

For the Down condition, we construct a $TS'$ representative inverse configuration $\hat{\sigma}(c)$ such that $\hat{\sigma}(\sigma(c))=c$ for any $TS$ configuration $c$.  The mapping $\sigma$ hides two types information: The contents of the output $Out$ of each local state, and the non-self pointers in a block (self-pointers are can be recovered from the block indices of simple blocks).  

In constructing the representative inverse $\hat{\sigma}$ function, we assume that payloads and agent identifiers are lexicographically-ordered, and use this to resolve nondeterminism in the choice of a dependency graph and in its topological sorting.  In the choice of a spanning tree for a block $b$ in the dependency graph of $c$, $\hat{\sigma}(c)$ chooses the first one, lexicographically.  
In the topological sort of the dependency graph, lexicographic ordering of the blocks resolves any nondeterminism in the partial order induced by the directed graph.  The result is that  $\hat{\sigma}(c)$ maps each $TS$ configuration $c$ to a sequence $\bar{B}$ of its block occurrences.  

It then converts the sequence $\bar{B}$ into a $TS'$  configuration $c'$, where $c'_p = (B'_p,Out'_p)$ for every $p \in P$, as follows.
For each simple $p$-block $b_p \in c_p$, $b'_p \in B'_p$, where $b'_p$ has a  pointer to every  $q$-block $b^q \in c_p$ that is the most-recent $q$-block that precedes $b_p$ in $\bar{B}$, for every $q\in P$ (if $b$ is not initial this includes one self-pointer).
For each block $b_p$ that depends on a $p'$-block $b_q$,  $(p,b')\in Out'_q$, where $b'$ is the result of the mapping of $b$.  

The result $c'$ of the mapping is a configuration over $P$ and \textit{MSB}.  It is consistent by construction, since each $q$-block in $c'_p$ depends on it being created by $q$.  It is complete since each block points to its predecessor.  To see that it is grassroots-dissemination consistent, construct the dissemination graph $DG'=(V',E')$  by 
first incorporating in $DG'$ the image of $DG$ under $\hat{\sigma}$, and
then replacing each direct edge $b_p \rightarrow b_q$ by two edges,
$b_p \rightarrow (p,b)_q$ and $(p,b)_q \rightarrow b_q$, and finally adding edges for the pointers among blocks that are part of the $p$-closure of every $p$-block in $B_p$, for every $p \in P$.  The construction is in accordance with the definition of a dependency graph (Def. \ref{definition:prec-GCD}) and is acyclic since $DG$ is acyclic and the added edges do not form cycles.  Hence  $c0' \preceqGCD c'$.  

To see that $\sigma(\hat{\sigma}(c))=c$, note that each block occurrence in $c$ is mapped one-to-one and and inversely by $\sigma$  by $\hat{\sigma}$, and that  message blocks added by $\hat{\sigma}$ are ignored by $\sigma$.
\qed \end{proof}






To prove  Theorem \ref{theorem:grassroots} we employ the  notion of interleaving:
\begin{definition}[Interleaving]\label{definition:interleaving}
Let $\calF$ be a protocol, $P1, P2 \subset \Pi$, $P1 \cap P2 = \emptyset$. $P:= P1 \cup P2$.  Let
$r1 = c1_0 \rightarrow c1_1 \rightarrow c1_2 \rightarrow \ldots$ be a run of $TS(P1)$,  $r2 = c2_0 \rightarrow c2_1 \rightarrow c2_2 \rightarrow \ldots$ a run of $TS(P2)$.
Then an \temph{interleaving} $r$ of $r1$ and $r2$ is the run of
$TS(P1\cup P2)$, 
$r= c_0 \rightarrow c_1 \rightarrow c_2 \rightarrow \ldots$ satisfying:
\begin{enumerate}
    \item $c_0/P1 = c1_0$ and $c_0/P2 =c2_0)$
    \item For all $i\ge 0$, if $c_i/P1 = c1_j$ and $c_i/P2 = c2_k$ 
   then $c_{i+1}/P1 = c1_{j'}$ and $c_{i+1}/P2 = c2_{k'})$ where either 
$j' = j+1$ and $k' = k$ or
$j' = j$ and $k' = k+1$.
\end{enumerate}
\end{definition}
Note that for any $c_i$ such that  $c_i/P1 = c1_j$ and $c_i/P2 = c2_k$ , $i = j+k$ for all $i\ge 0$.  Note that since the following proof refers explicitly to the difference between the subcommunity ($P$ in Definition \ref{definition:grassroots}) and the supercommunity ($P'$ in the definition),  it uses $P1$ for the subcommunity, $P2$ for the difference, and $P = P1 \cup P2$ for the supercommunity.

\GrassrootsProtocol*
\begin{proof}[Proof of Theorem \ref{theorem:grassroots}]
Let $\calF$ be an asynchronous, interactive, and non-interfering protocol, 
$\emptyset \subset P1 \subset P \subseteq \Pi$, $P2 := P \setminus P1$, 
$r1 = c1_0 \rightarrow c1_1 \ldots$ a correct run of $TS(P1)$,  $r2= c2_0 \rightarrow c2_1 \ldots$ a correct run of $TS(P2)$,  $r=c_0 \rightarrow c_1 \rightarrow \ldots$ the interleaving of $r1$ and $r2$, which is a run of $TS(P)$ by construction.  We argue that $r$ is correct. 

Consider any $p$-transition 
$t= (c \rightarrow c') \in r$ for some $p \in P1$ (else $p \in P2$ and the symmetric argument applies).
Since $c/P1 \rightarrow c'/P1 \in T(P1)$ by construction and  $\calF$ is non-interfering, then by Definition \ref{definition:non-interfering} it follows that the $p$-transition that is similar to $t$, except that agents in $P2$ are in their initial state, is in $T(P)$.  Specifically, the $p$-transition $\hat{c} \rightarrow \hat{c}' \in T(P)$,  defined by $\hat{c}/P1 = c/P1$, $\hat{c}/P2 = c2_0$, $\hat{c}'/P1 = c'/P1$, $\hat{c}'/P2 = c2_0$.
Since $\hat{c} \preceq c$ by monotonicity of $\calF$, $(\hat{c}_p \rightarrow \hat{c}'_p) = (c_p \rightarrow c'_p)$ by construction, and the assumption that $\calF$ is asynchronous together imply that $c \rightarrow c' \in T(P')$. As $c \rightarrow c'$ is a generic transition of $r$, the argument holds for all $r$ transitions, and hence $r$ is safe.

To prove that $r$ is live, recall that $r1$ and $r2$ are correct by assumption, hence the agents of $P1$ are live in $r1$ and the agents of $P2$ are live in $r2$, and together with the liveness condition of non-interference this implies 
that all agents of $P$ are live in $r$, namely $r$ is live.  Hence $r$ is correct
and, since $r1$ and $r2$ were arbitrary,  $TS(P1) \subseteq TS(P)/P1$.   The assumption that $\calF$ is interactive
implies that the inclusion is strict, namely $TS(P1) \subset TS(P)/P1$, concluding that $\calF$ is grassroots.
%\qed
\end{proof}




\end{document}
