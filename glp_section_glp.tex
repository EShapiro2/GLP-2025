\section{GLP}\label{section:GLP}

We present GLP as an extension of Logic Programs: The syntax is extended with reader variables $X?$, where $X$ and $X?$ form a reader/writer pair, and with the Single-Reader/Single-Writer syntactic restriction on clauses.  For example, here is the quintessential concurrent logic program for merging two streams (incrementally constructed, potentially unbounded lists), written in GLP.  Its first two arguments are the input streams to be merged,  the third is the merged output stream:

\Program{GLP Fair Stream Merger}\label{program:merge}
\begin{small}
\begin{verbatim}
merge([X|Xs], Ys, [X?|Zs?]) :- merge(Ys?, Xs?, Zs).
merge(Xs, [Y|Ys], [Y?|Zs?]) :- merge(Xs?, Ys?, Zs).
merge(Xs, [], Xs?).
merge([], Ys, Ys?).
\end{verbatim}
\end{small}
Note that in each clause, each variable occurs at most once (single-occurrence), and each variable occurs if and only if its paired variable also occurs (SRSW).

The operational semantics of GLP extends that of LP as follows:
\begin{enumerate}
\item \textbf{Synchronisation}: Unification may only instantiate writers, so in addition to succeed/fail, unification may suspend if it requires instantiating readers.

\item \textbf{Communication}: When a unifying writer substitution binds a writer $X$ to a term $T$, the message  $X? := T$ encoding its paired reader assignment is created and added to the configuration. Its application happens asynchronously, realizing a message $T$ from the single occurrence of $X$ to the single occurrence of $X?$. 

\item \textbf{Deterministic clause selection}: The first applicable clause is chosen, not nondeterministically as in LP. This provides for the fairness of \verb|merge| presented above:  As long as the two input streams are available the output dovetails the two inputs, due to switching their order in the recursive call of the first clause; as long as only one stream is available, its elements are copied to the output; and when both streams are unavailable the goal suspends.
\end{enumerate}

The remainder of this section presents GLP syntax, nondeterministic operational semantics, and safety properties. A deterministic `workstation implementation-ready' transition-system specification for GLP is presented in Appendix~\ref{appendix:irGLP}. 

\subsection{GLP Syntax}

\mypara{Reader/Writer pairs}
GLP extends Logic Programs with paired reader/writer variables, where a \emph{writer} $X$ is a single-assignment variable (promise) and its \emph{paired reader $X?$} provides read-only access to the (future) value of $X$. We denote by $\calV$ the set of all writers (the standard LP variables), $\calV? = \{X? \mid X \in \calV\}$ the set of all readers, and $\hat\calV = \calV \cup \calV?$ the set of all GLP variables, where for each writer $X \in \calV$ there exists a paired reader $X? \in \calV?$.
We view $?$ as an identity suffix operator on non-writers, namely $(X?)?=X?$ for $X?\in \calV?$ and $T?=T$ for $T\notin \hat\calV$.
We use $\calA_?$ and $\calG_?$ to denote the set of all atoms and goals, respectively, over $\hat\calV$ (i.e., goals that may contain both readers and writers), and for a GLP program $P$, $\calA_?(P)$ and $\calG_?(P)$ to denote the subsets of $\calA_?$ and $\calG_?$, respectively, restricted to the vocabulary of $P$.


\mypara{Single-Occurrence and Single-Reader/Single-Writer}
GLP imposes two related but distinct requirements on variables:

\begin{definition}[Single-Occurrence (SO) Invariant]\label{def:so-invariant}
A goal or clause satisfies the \temph{single-occurrence (SO) invariant} if every variable occurs in it at most once.
\end{definition}

\begin{definition}[Single-Reader/Single-Writer (SRSW) Syntactic Restriction]\label{def:srsw-restriction}
A clause $C$ satisfies the \temph{SRSW syntactic restriction} if it satisfies SO and, furthermore, a variable occurs in $C$ if and only if its paired variable also occurs in $C$.
\end{definition}

The fundamental requirement is \emph{single-writer}: any writer may occur at most once in any state of a computation, ensuring there can be no conflict when writing on a logic variable. We extend it to \emph{single-reader} because with multiple instances of a reader, instantiating the writer to a term containing another writer would give all instances of the paired reader access to that writer, violating the single-writer requirement.

The SO invariant is maintained by the SRSW restriction: reducing a goal satisfying SO with a clause satisfying SRSW results in a goal satisfying SO (Proposition~\ref{proposition:srsw-preservation}).
This SRSW syntactic restriction excludes programs like the equality definition $X=X$ as it has two occurrences of the writer $X$. At the same time it
eliminates the need for distributed atomic unification~\cite{kleinman1990distributed}—replacing it with efficient point-to-point communication of a single assignment from the single occurrence of a writer to the single occurrence of its paired reader.

\mypara{No writer-to-writer binding (WxW)}
In addition, GLP requires \emph{no writer-to-writer} binding (WxW).  A reader/writer pair $X?/X$ is a communication channel from the writer $X$ to the reader $X?$.
It two writers $X$ and $Y$ are unified during execution, the SRSW requirement implies that no occurrences of either $X$ or $Y$ are left to instantiate them, and therefore their paired readers $X?$ and $Y?$ will be left \emph{abandoned}.  Combined,  the WxW and SRSW restrictions ensure that communication channels are properly closed, with no reader is left abandoned by their paired variable.\footnote{We discuss below a relaxation, allowing a reader to abandon its paired writer using anonymous variables $_$, which useful in case there is no need to read the channel any more.}

\subsection{GLP Operational semantics}

\begin{definition}[Writer Assignment, Reader Assignment, Substitutions, Reader Counterpart]\label{definition:GLP-substitution}
A GLP \temph{writer assignment} is a term of the form $X := T$, where $X\in\calV$, $T\notin\calV$, satisfying SO.
A GLP \temph{reader assignment} is a term of the form $X? := T$, where $X?\in\calV?$, $T\notin\calV$, satisfying SO.

A \temph{writer substitution} $\sigma$ is the substitution implied by a set of writer assignments that jointly satisfy SO. Equivalently, $\sigma$ is a writer substitution if:
\begin{enumerate}
    \item it only binds writers: $\calV_\sigma \subset \calV$
    \item it does not bind writers to writers: if $X\ne X\sigma$ for $X\in \calV$ then $X\sigma\notin \calV$
    \item it does not form cycles through readers: $X?$ does not occur in $X\sigma$ for any $X \in \calV_\sigma$
\end{enumerate}
A \temph{reader substitution} $\sigma$ is defined analogously: $\calV_\sigma \subset \calV?$.

Given a writer substitution $\sigma$, its \temph{reader counterpart} $\sigma?$ is the reader substitution defined by $X?\sigma? = X\sigma$ for every $X \in \calV_\sigma$.
\end{definition}

\begin{definition}[Writer Unification, Suspension Set]\label{definition:writer-unification}
The \temph{suspension set} of a substitution $\sigma$ is $W_\sigma := \{X? \in \calV? : X?\sigma \notin \hat\calV\}$.

The \temph{writer unification} of two terms:
\begin{enumerate}
    \item \temph{succeeds with $\sigma$} if they have a writer mgu $\sigma$
    \item else \temph{suspends on $W_\sigma$} if they have a (regular) mgu $\sigma$
    \item else \temph{fails}
\end{enumerate}
\end{definition}

\begin{remark}
If a writer mgu exists it is unique, rather than unique up to renaming, since it does not include writer-to-writer assignments.
If writer-to-writer assignments were allowed then, by the single-writer restriction, the assignment would leave their two paired readers \emph{abandoned}, namely without a writer that can provide them with a value.
The occurs check condition for the reader counterpart ensures that no writer is bound to a term containing its paired reader, preventing the formation of circular terms, as proven in Proposition~\ref{proposition:acyclicity}.
\end{remark}

Renaming  (Definition~\ref{definition:renaming}) is extended to respect variable pairing:
\begin{definition}[GLP Renaming]\label{definition:GLP-renaming}
A \temph{GLP renaming} is a substitution $\rho: \hat\calV \to \hat\calV$ such that for each $X \in \calV$: $X\rho \in \calV$ and $X?\rho = (X\rho)?$.
Two GLP terms have a variable in common if for some writer $X \in \calV$, either $X$ or $X?$ occurs in both. A GLP renaming $\rho$ renames $T'$ \temph{apart from} $T$ if $T'\rho$ and $T$ have no variable in common.
\end{definition}

\begin{definition}[GLP Goal/Clause Reduction]\label{definition:GLP-goal-clause-reduction}
 Given GLP goal $A$ and clause $C$,  with $H \verb|:-| B$ being the result of the GLP renaming of $C$ apart from $A$,
 the \temph{GLP reduction} of $A$ with $C$ \temph{succeeds with result} $(B,\sigma)$,
\temph{suspends on $W$}, or \temph{fails}, respectively, depending on the result of the writer unification of $A$ and $H$.
\end{definition}

\mypara{Term matching eschews unification}
If two terms $T_1$ and $T_2$ that jointly satisfy SO are unifiable with an mgu $\sigma$, then $\sigma$ maps any variable in $T_1$ to a subterm of $T_2$ and vice versa. Hence, the SO invariant of GLP allows eschewing unification in favour of \emph{term matching} that performs joint term-tree traversal and collects variable assignments along the way:

\begin{definition}[Term Matching]\label{def:term-matching}
Given two terms $T_1$ and $T_2$ that jointly satisfy SO, their \temph{term matching} proceeds via joint traversal of their term-trees, consulting the following table at each pair of vertices, where $X_1, X_2$ denote writers, $X_1?, X_2?$ denote readers, and $f/n$ denotes a non-variable term (constant when $n=0$, compound when $n>0$):
\begin{center}
\begin{tabular}{l|lll}
$T_1 \backslash T_2$ & Writer $X_2$ & Reader $X_2?$ & Term $f_2/n_2$ \\
\hline
Writer $X_1$ & fail & $X_1 := X_2?$ & $X_1 := T_2$ \\
Reader $X_1?$ & $X_2 := X_1?$ & fail & suspend on $X_1?$\\
Term $f_1/n_1$ & $X_2 := T_1$ & fail & fail if $f_1\ne f_2$ or $n_1\ne n_2$\\
\end{tabular}
\end{center}
The writer mgu is the union of all writer assignments if no \emph{fail} was encountered and the suspension set is empty.
\end{definition}

The GLP operational semantics is defined via the following transition system, which employs the notions defined above to extend LP (Definition~\ref{definition:lp-ts}). It abstracts-away goal suspension and failure; these are used in the implementation-ready specifications (Appendixes~\ref{appendix:irGLP} and~\ref{appendix:irmaGLP}) for explicit goal scheduling, suspension and activation.
\begin{definition}[GLP Transition System]\label{definition:GLP-ts}
Given a GLP program $M$, an \temph{asynchronous resolvent} over $M$ is a pair $(G,\sigma)$ where $G\in \calG_?(M)$ and $\sigma$ is a reader substitution. 
%
A transition system $GLP = (\calC,c0,\calT)$ is a \temph{GLP transition system} over $M$ and initial goal $G_0 \in \mathcal{G}_?(M)$ satisfying SRSW if:
\begin{enumerate}
    \item $\calC$ is the set of all asynchronous resolvents over $M$
    \item $c0= (G_0,\emptyset)$
    \item $\calT$ is the set of all transitions $(G,\sigma)\rightarrow (G',\sigma')$ satisfying:
    \begin{enumerate}
        \item \textbf{Reduce:} there exists an atom $A \in G$ such that $C \in M$ is the first clause for which the GLP reduction of $A$ with $C$ succeeds with result $(B,\hat\sigma)$,  $G' = (G \setminus \{A\} \cup B)\hat\sigma$, and $\sigma' = \sigma \circ \hat\sigma?$
        \item \textbf{Communicate:} $\{X:=T\} \in \sigma$, $X? \in vars(G)$, $G'= G\{X?:=T\}$, and $\sigma' = \sigma$
\end{enumerate}
\end{enumerate}
\end{definition}
The monotonicity of GLP goal/clause reduction (Proposition~\ref{proposition:GLP-monotonicity}) allows a simple \emph{GLP fairness requirement}: A goal that can be reduced is eventually reduced.


\mypara{Guards and system predicates}
GLP also includes \emph{guards}—predicates that test runtime conditions (e.g., \verb|ground(X)| tests if \verb|X| contains no variables) without modifying state, appearing after clause heads separated by \verb=|=—and \emph{system predicates} that provide access to the GLP runtime state and operating system and hardware capabilities (variable state and name, arithmetic evaluation, timestamps). Guards enable conditional clause selection. The \verb|ground(X)| guard allows relaxing the single-reader constraint for \verb|X?| for the clause it occurs in, as having multiple occurrences of \verb|X?| instantiated to a ground term does not violate the fundamental single-writer requirement.
Their specification appears in Appendix~\ref{appendix:guards-system}.


\subsection{GLP Safety}

Here we prove that, like LP, GLP computations are deductions, but, unlike LP, a goal that can be reduced in a configuration can still be reduced in any subsequent configuration of the computation.

\mypara{GLP computations are deductions}  First we show that the extensions of GLP over LP do not take it outside of the logic programming realm.

\begin{definition}[Pure Logic Variant]\label{definition:pure-logic}
Given a GLP term or goal $T$, the \temph{pure logic variant} $L(T)$ of $T$ is defined by replacing every reader $X?$ in $T$ with its paired writer $X$. Given a GLP computation  $r$, its pure logic variant $L(r)$ is the result of replacing every configuration $(G,\sigma)$ in $r$ by $L(G)$,  removing duplications and labelling the remaining transitions by the mgu of their respective reduction.
\end{definition}
Note that duplications as above result from Communicate transitions.

\begin{restatable}[GLP Computations are Deductions]{proposition}{GLPComputationsareDeductions}\label{theorem:GLP-computation-deduction}
For any finite GLP run $r$, let 
$L(r) = G0\xrightarrow{\sigma_1}G_1\xrightarrow{\sigma_2}\ldots G_n$, 
with $\sigma = \sigma_1\cdot \ldots \cdot \sigma_n$, then  $(G_ :- G_n)\sigma$ is a logical consequence of $L(M)$.
\end{restatable}

Next, we establish essential safety properties for GLP that distinguish it from standard LP. The key is monotonicity—once a goal becomes reducible in GLP, it remains reducible.

\mypara{SO Preservation}
\begin{restatable}[SO Preservation]{proposition}{SOPreservation}\label{proposition:srsw-preservation}
If the initial goal $G_0$ in a $GLP$ run satisfies SO, then every goal in the run satisfies SO.
\end{restatable}

\mypara{Acyclicity}
The occurs check in readers prevents the formation of circular terms.

\begin{restatable}[Acyclicity]{proposition}{Acyclicity}\label{proposition:acyclicity}
If the initial goal $G_0$ in a $GLP$ run contains no circular terms, then no goal in the run contains a circular term.
\end{restatable}

\mypara{Monotonicity}
Unlike LP where variable instantiation can cause a previously reducible goal to fail, GLP exhibits monotonicity. In a run, if a goal $A$ can be reduced at some point, it remains reducible at all future points in that run, where 
``future" implies that readers in $A$  (and only readers) have been further instantiated by other goal reductions.

\begin{restatable}[Reader-Instance]{lemma}{ReaderOnlyInstantiation}\label{lemma:reader-only}
In any $GLP$ run $G_0 \rightarrow G_1 \rightarrow \cdots$, if $G_i \rightarrow G_{i+1}$ via reduction with substitution $\sigma?$ does not reduce $A \in G_{i}$, then $A\tau \in G_{i+1}$ where $\tau$ instantiates only readers.
\end{restatable}

\begin{restatable}[Monotonicity]{proposition}{Monotonicity}\label{proposition:GLP-monotonicity}
In any $GLP$ run $G_0 \rightarrow G_1 \rightarrow \cdots$, if atom $A \in G_i$ can reduce with clause $C$, then for any $j > i$, either $A$ has been reduced by step $j$, or there exists $A' \in G_j$ where $A' = A\tau$ for some reader substitution $\tau$, and $A'$ can reduce with $C$.
\end{restatable}

