

\section{Design of a smartphone-based implementation of GLP in Dart}

\subsection{Implementation Requirements and Design Context}

To implement Grassroots Logic Programs (GLP) on smartphones, we require a programming environment that supports:
\begin{itemize}
  \item Concurrency with lightweight processes.
  \item Garbage-collected dynamic memory.
  \item Cryptographic operations (key generation, signing, hashing, encryption).
  \item Platform-neutral deployment (iOS and Android).
  \item Trusted Execution Environment (TEE)-backed attestation support.
  \item A runtime capable of interpreting or executing logic programs dynamically.
\end{itemize}

Given these requirements, the Dart programming language running within a single \emph{isolate} on each smartphone is selected as the GLP runtime environment. Dart satisfies the constraints above and has strong cross-platform support through Flutter, making it the only viable choice currently.

Each GLP \emph{agent} is a smartphone running a TEE-certified GLP app. Each agent owns a self-generated public/private keypair, and its identity is defined by the public key. All inter-agent messages are signed and encrypted; all modules and logic terms are content-addressed by cryptographic hash.

\subsection{System Architecture Overview}

The GLP runtime is realized as a single Dart isolate per smartphone. This isolate hosts the following components:

\begin{itemize}
  \item A logic term runtime: typed classes representing variables, terms, and clauses.
  \item A GLP engine: implements grassroots unification, process scheduling, and operational semantics.
  \item A secure communication layer: handles inter-agent message signing, encryption, and parsing.
  \item A module manager: tracks all GLP modules (by hash), loads and verifies them on demand.
  \item TEE interface: verifies app integrity and platform attestation using Google/Apple APIs.
\end{itemize}

All logic variables are tagged with a creator key and a serial number. The single-writer invariant is maintained via program-level checks and runtime enforcement. Shared variables across agents are realized as signed hash references passed in message payloads.

\subsection{Logic Terms and Variables in Dart}

GLP terms are encoded using Dart class hierarchies. For example:

\begin{verbatim}
sealed class Term {}
class Var extends Term {
  final String creatorPubKey;
  final int serialNumber;
  bool isWriter;
  Term? value;
}
class Const extends Term {
  final String name;
}
class Compound extends Term {
  final String functor;
  final List<Term> args;
}
\end{verbatim}

Each logic variable is identified globally by \texttt{creatorPubKey:serialNumber}. The \texttt{isWriter} flag determines its role. Writers may be instantiated exactly once; readers/futures resolve by watching for that binding. 

Terms are serialized for communication using signed JSON-compatible encodings. For example:

\begin{verbatim}
{
  "type": "Compound",
  "functor": "ask",
  "args": [{"type": "Var", "creator": "...", "serial": 42}]
}
\end{verbatim}

\subsection{Operational Semantics in Dart}

Each active goal is represented by a Dart object:

\begin{verbatim}
class Goal {
  final Term head;
  final List<Term> body;
  GoalStatus status;
}
\end{verbatim}

A scheduler manages runnable goals and forks new threads of execution as needed. To respect the single-writer invariant and avoid general unification, the unification algorithm only binds writers and requires that each reader appear at most once.

Example of grassroots unification (simplified):

\begin{verbatim}
bool unify(Term a, Term b, Map<String, Term> env) {
  if (a is Var && a.isWriter) {
    a.value = b;
    return true;
  }
  if (b is Var && b.isWriter) {
    b.value = a;
    return true;
  }
  if (a is Const && b is Const) return a.name == b.name;
  if (a is Compound && b is Compound &&
      a.functor == b.functor && a.args.length == b.args.length) {
    for (int i = 0; i < a.args.length; i++) {
      if (!unify(a.args[i], b.args[i], env)) return false;
    }
    return true;
  }
  return false;
}
\end{verbatim}

\subsection{Bootstrapping the Social Graph and Friendship Variables}

All GLP apps are preloaded with a consistent, hash-identified implementation of the grassroots social graph protocol.

When two agents wish to establish a friendship, one sends a GLP term of the form:

\begin{verbatim}
offer(FriendshipID, WriterVar)
\end{verbatim}

The receiver may respond by binding \texttt{WriterVar} to \texttt{yes} or \texttt{no}. Because logic variables are globally identified, this exchange shares a fresh writer/reader pair across agents securely and verifiably.

\subsection{Modules and Code Mobility}

GLP modules are interpretable logic programs. Each module is serialized, hashed, and signed. For instance:

\begin{verbatim}
[
  { "head": "merge([X|Xs], Ys, [X|Zs])",
    "body": "merge(Xs, Ys, Zs)" },
  ...
]
\end{verbatim}

Modules can be transmitted between agents and executed upon receipt if the signature and hash match and the sender is trusted (via TEE-based verification). The runtime maintains a cache of verified modules indexed by their hash.

\subsection{TEE-Based Verification of Peers}

Each message between agents includes a signed attestation that:
\begin{itemize}
  \item The sender is running a verified GLP app.
  \item The app has not been modified and matches the known hash.
  \item The device identity is bound to the sender key.
\end{itemize}

Verification is performed using backend-mediated attestation (e.g., Google Play Integrity API or Apple App Attest). The backend server acts as a verifier, issuing cryptographic certificates that peers can exchange to trust each other.

\subsection{Conclusion}

This design realizes GLP as a secure, portable, single-isolate logic engine running on smartphones. By carefully mapping GLP constructs to Dart classes and TEE-backed communication protocols, we enable trustworthy grassroots logic programming across untrusted networks of mobile agents.

\section{Design of a smartphone-based implementation of GLP in Dart}

\subsection{Implementation Requirements and Design Context}

To implement Grassroots Logic Programs (GLP) on smartphones, we require a programming environment that supports:
\begin{itemize}
  \item Concurrency with lightweight processes.
  \item Garbage-collected dynamic memory.
  \item Cryptographic operations (key generation, signing, hashing, encryption).
  \item Platform-neutral deployment (iOS and Android).
  \item Trusted Execution Environment (TEE)-backed attestation support.
  \item A runtime capable of interpreting or executing logic programs dynamically.
\end{itemize}

Given these requirements, the Dart programming language running within a single \emph{isolate} on each smartphone is selected as the GLP runtime environment. Dart satisfies the constraints above and has strong cross-platform support through Flutter, making it the only viable choice currently.

Each GLP \emph{agent} is a smartphone running a TEE-certified GLP app. Each agent owns a self-generated public/private keypair, and its identity is defined by the public key. All inter-agent messages are signed and encrypted; all modules and logic terms are content-addressed by cryptographic hash.

\subsection{System Architecture Overview}

The GLP runtime is realized as a single Dart isolate per smartphone. This isolate hosts the following components:

\begin{itemize}
  \item A logic term runtime: typed classes representing variables, terms, and clauses.
  \item A GLP engine: implements grassroots unification, process scheduling, and operational semantics.
  \item A secure communication layer: handles inter-agent message signing, encryption, and parsing.
  \item A module manager: tracks all GLP modules (by hash), loads and verifies them on demand.
  \item TEE interface: verifies app integrity and platform attestation using Google/Apple APIs.
\end{itemize}

All logic variables are tagged with a creator key and a serial number. The single-writer invariant is maintained via program-level checks and runtime enforcement. Shared variables across agents are realized as signed hash references passed in message payloads.

\subsection{Logic Terms and Variables in Dart}

GLP terms are encoded using Dart class hierarchies. For example:

\begin{verbatim}
sealed class Term {}
class Var extends Term {
  final String creatorPubKey;
  final int serialNumber;
  bool isWriter;
  Term? value;
}
class Const extends Term {
  final String name;
}
class Compound extends Term {
  final String functor;
  final List<Term> args;
}
\end{verbatim}

Each logic variable is identified globally by \texttt{creatorPubKey:serialNumber}. The \texttt{isWriter} flag determines its role. Writers may be instantiated exactly once; readers/futures resolve by watching for that binding. 

Terms are serialized for communication using signed JSON-compatible encodings. For example:

\begin{verbatim}
{
  "type": "Compound",
  "functor": "ask",
  "args": [{"type": "Var", "creator": "...", "serial": 42}]
}
\end{verbatim}

\subsection{Operational Semantics in Dart}

Each active goal is represented by a Dart object:

\begin{verbatim}
class Goal {
  final Term head;
  final List<Term> body;
  GoalStatus status;
}
\end{verbatim}

A scheduler manages runnable goals and forks new threads of execution as needed. To respect the single-writer invariant and avoid general unification, the unification algorithm only binds writers and requires that each reader appear at most once.

Example of grassroots unification (simplified):

\begin{verbatim}
bool unify(Term a, Term b, Map<String, Term> env) {
  if (a is Var && a.isWriter) {
    a.value = b;
    return true;
  }
  if (b is Var && b.isWriter) {
    b.value = a;
    return true;
  }
  if (a is Const && b is Const) return a.name == b.name;
  if (a is Compound && b is Compound &&
      a.functor == b.functor && a.args.length == b.args.length) {
    for (int i = 0; i < a.args.length; i++) {
      if (!unify(a.args[i], b.args[i], env)) return false;
    }
    return true;
  }
  return false;
}
\end{verbatim}

\subsection{Bootstrapping the Social Graph and Friendship Variables}

All GLP apps are preloaded with a consistent, hash-identified implementation of the grassroots social graph protocol.

When two agents wish to establish a friendship, one sends a GLP term of the form:

\begin{verbatim}
offer(FriendshipID, WriterVar)
\end{verbatim}

The receiver may respond by binding \texttt{WriterVar} to \texttt{yes} or \texttt{no}. Because logic variables are globally identified, this exchange shares a fresh writer/reader pair across agents securely and verifiably.

\subsection{Modules and Code Mobility}

GLP modules are interpretable logic programs. Each module is serialized, hashed, and signed. For instance:

\begin{verbatim}
[
  { "head": "merge([X|Xs], Ys, [X|Zs])",
    "body": "merge(Xs, Ys, Zs)" },
  ...
]
\end{verbatim}

Modules can be transmitted between agents and executed upon receipt if the signature and hash match and the sender is trusted (via TEE-based verification). The runtime maintains a cache of verified modules indexed by their hash.

\subsection{TEE-Based Verification of Peers}

Each message between agents includes a signed attestation that:
\begin{itemize}
  \item The sender is running a verified GLP app.
  \item The app has not been modified and matches the known hash.
  \item The device identity is bound to the sender key.
\end{itemize}

Verification is performed using backend-mediated attestation (e.g., Google Play Integrity API or Apple App Attest). The backend server acts as a verifier, issuing cryptographic certificates that peers can exchange to trust each other.

\subsection{Conclusion}

This design realizes GLP as a secure, portable, single-isolate logic engine running on smartphones. By carefully mapping GLP constructs to Dart classes and TEE-backed communication protocols, we enable trustworthy grassroots logic programming across untrusted networks of mobile agents.
