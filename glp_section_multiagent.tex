\section{Multiagent GLP}\label{sec:maglp}

We extend GLP to be multiagent using the mathematical framework of Section~\ref{sec:foundations}. We define multiagent GLP (maGLP) as a transactions-based multiagent transition system, prove that maGLP is grassroots, and establish that any GLP application using cold calls is grassroots.

\subsection{From GLP to Multiagent GLP}

In extending GLP to multiple agents, each agent maintains its own asynchronous resolvent as its local state. The key insight is that GLP's reader/writer pairs provide natural binary communication channels: when agent $p$ binds a writer $X$ shared with agent $q$, the corresponding reader assignment $X? := T$ must be communicated to $q$.

A key difference between single-agent GLP and multiagent GLP is in the initial state. In a multiagent transition system all agents must have the same initial local state $s0$ (Definition~\ref{definition:mts}). This precludes setting up an initial configuration in which agents share logic variables, as this would imply different initial states for different agents.

We resolve this in two steps. First, we employ only anonymous logic variables ``\verb|_|'' in the initial local states of agents: Anonymous variables are, on the one hand, syntactically identical, hence allow all initial states to be syntactically identical, and on the other hand represent unique variables, hence semantically all initial goals have unique, local, non-shared variables. The initial state of all agents is the atomic goal \verb|agent(ch(_?,_),ch(_?,_))|, with the first channel serving communication with the user and the second with the network.

Second, the Network transaction enables agents to bootstrap communication by establishing shared variables through the network infrastructure, realizing the cold-call protocol for connecting previously-disconnected agents.

\subsection{Multiagent GLP Definition}

\begin{definition}[Multiagent GLP]\label{definition:maGLP}
Given agents $P\subset \Pi$ and GLP program $M$, the \temph{maGLP transition system} over $P$ and $M$ is the transactions-based multiagent transition system (Definition~\ref{definition:tbmts}) over $P$, local states being asynchronous resolvents over $M$, initial local state $s0 = (\{\verb|agent(ch(_?,_),ch(_?,_))|\}, \emptyset)$, and the following transactions $c\rightarrow c'$:
\begin{enumerate}
    \item \textbf{Reduce $p$:} A unary transaction with participant $p$ where $c_p\rightarrow c'_p$ is a GLP Reduce transition (Definition~\ref{def:glp-ts}).
    
    \item \textbf{Communicate $p$ to $q$:} A binary transaction with participants $\{p,q\}\subseteq P$ where $c_p=(G_p,\sigma_p)$, $c_q=(G_q,\sigma_q)$, $\{X?:=T\} \in \sigma_p$, $X?$ occurs in $G_q$, $c'_p=(G_p,\sigma_p \setminus \{X?:=T\})$, and $c'_q=(G_q\{X?:=T\},\sigma_q)$. Note: this includes $p=q$.
    
    \item \textbf{Network $p$ to $q$:} A binary transaction with participants $\{p,q\}\subseteq P$ where the network output stream in $c_p$ has a new message \verb|msg|$(q,X)$, $c'_p$ is the result of advancing the network output stream in $c_p$, and $c'_q$ is the result of adding $X?$ to the network input stream in $c_q$.
\end{enumerate}
\end{definition}

Note that Reduce is unary while Communicate and Network are binary. Both Communicate and Network transfer assignments from writers to readers: Communicate operates between agents sharing logic variables, while Network operates through the network input/output streams established in each agent's initial configuration, enabling the cold-call protocol for connecting previously-disconnected agents.

\subsection{maGLP is Grassroots}

We now prove that maGLP is grassroots using the framework of Section~\ref{sec:foundations}.

\begin{theorem}[maGLP is Grassroots]\label{theorem:maGLP-grassroots}
The maGLP protocol is grassroots.
\end{theorem}

\begin{proof}
By Theorem~\ref{theorem:interactive-grassroots}, it suffices to show that maGLP is a transactions-based protocol with interactive transactions.

\emph{maGLP is transactions-based}: By Definition~\ref{definition:maGLP}, maGLP is defined via a set of transactions (Reduce, Communicate, Network) over a local-states function (asynchronous resolvents) with a common initial state. Hence maGLP is a transactions-based protocol (Definition~\ref{definition:protocol-transactions}).

\emph{maGLP transactions are interactive}: Let $\emptyset \subset P \subset P' \subseteq \Pi$ and let $c \in C(P')$ be a configuration such that $c/P \in C(P)$. We must show there exists a computation $c \xrightarrow{*} c'$ of maGLP$(P')$ such that $c'/P \notin C(P)$.

Since $c/P \in C(P)$, the local states of agents in $P$ contain no variables shared with agents in $P' \setminus P$---all their reader/writer pairs are ``internal'' to $P$.

Consider any agent $p \in P$ and any agent $q \in P' \setminus P$. Agent $p$ can execute a Reduce transaction that sends a message \verb|msg|$(q,X)$ on its network output stream, where $X$ is a fresh writer. Then the Network transaction from $p$ to $q$ adds $X?$ to agent $q$'s network input stream. Agent $q$ can then execute Reduce transactions that bind $X?$ to some term $T$, creating a reader assignment $X? := T$. Finally, the Communicate transaction from $q$ to $p$ applies this assignment to $p$'s resolvent.

The result is that agent $p$'s local state now contains a term $T$ that originated from agent $q \in P' \setminus P$. This constitutes an ``alien trace''---the configuration $c'/P$ contains references to variables or terms that could not have been produced by agents in $P$ running alone. Hence $c'/P \notin C(P)$.

Since such a computation exists for any valid configuration $c$, the maGLP transactions are interactive (Definition~\ref{definition:interactive}).

By Theorem~\ref{theorem:interactive-grassroots}, maGLP is grassroots.
\end{proof}

\subsection{GLP Applications Using Cold Calls are Grassroots}

The grassroots property of maGLP extends to applications built on top of it, provided they use the cold-call mechanism.

\begin{definition}[GLP Application, Cold Call]
A \temph{GLP application} is a GLP program $M$ together with the maGLP infrastructure. An application \temph{uses cold calls} if agents can execute the Network transaction to establish communication with previously-disconnected agents.
\end{definition}

\begin{proposition}[GLP Applications Using Cold Calls are Grassroots]\label{prop:app-grassroots}
Any GLP application that uses cold calls is grassroots.
\end{proposition}

\begin{proof}
A GLP application using cold calls is a restriction of maGLP to a specific program $M$. The Network transaction remains available, as cold calls are used. The proof of Theorem~\ref{theorem:maGLP-grassroots} relies only on the availability of the Network transaction to establish interactivity. Since cold calls provide this mechanism, the application inherits the interactive property.

The application is transactions-based by construction (being a restriction of maGLP). By Proposition~\ref{proposition:oblivious}, it is oblivious. By the interactivity argument above and Proposition~\ref{proposition:interactive}, it is interactive. Therefore, by Definition~\ref{definition:grassroots}, it is grassroots.
\end{proof}

This proposition provides a simple criterion for verifying that a GLP application is grassroots: if it uses cold calls for initial contact between disconnected agents, it inherits the grassroots property from maGLP.

\subsection{Safety Properties of maGLP}

The safety properties established for single-agent GLP extend to maGLP.

\begin{proposition}[Safety Properties of maGLP]\label{proposition:maGLP-safety}
The safety properties established for GLP in Section~\ref{sec:glp} extend to maGLP:
\begin{enumerate}
\item \textbf{SO Preservation} (cf.\ Proposition~\ref{prop:so-preservation}): If the initial goals of all agents satisfy SO, then every goal in every agent's resolvent throughout the run satisfies SO.
\item \textbf{Acyclicity} (cf.\ Proposition~\ref{prop:acyclicity}): If the initial goals of all agents contain no circular terms, then no goal in any agent's resolvent contains a circular term.
\item \textbf{Monotonicity} (cf.\ Proposition~\ref{prop:glp-monotonicity}): If unit goal $A$ in agent $p$'s resolvent can reduce with clause $C$ at step $i$, then at any step $j > i$, either $A$ has been reduced or there exists $A'$ in $p$'s resolvent where $A' = A\tau$ for some reader substitution $\tau$, and $A'$ can reduce with $C$.
\end{enumerate}
\end{proposition}

\begin{proof}
The proofs are identical to those for single-agent GLP, substituting ``agent $p$'s resolvent'' for ``resolvent'' and noting that Reduce transitions operate locally within each agent whilst Communicate and Network transitions preserve the properties through reader assignment transfer.
\end{proof}

\begin{proposition}[maGLP Computation is Deduction]\label{prop:maglp-deduction}
Let $L$ be the transition system whose resolvent is the union of all local resolvents, the initial goal includes a \verb|network| goal with channels paired to each agent's network channels, and the program is $M$ augmented with the GLP definition of \verb|network|. Then maGLP runs correspond to GLP runs of $L$, and their outcomes are logical consequences of the augmented program.
\end{proposition}
