\section{The Grassroots Social Graph}\label{section:social-graph}

This section demonstrates how GLP can realize the foundational grassroots platform, the grassroots social graph. The Network transaction enables cold-call connections between disconnected agents, whilst the Communicate transaction provides secure message transfer through established friend channels. Friend-mediated introductions for expanding the network through existing trust relationships are presented in Appendix~\ref{appendix:friend-introductions}.

The grassroots social graph serves as the infrastructure layer for all other grassroots platforms. It enables people to establish authenticated friendships through cryptographically-identified connections. Grassroots platforms built upon this foundation---including grassroots social networks, grassroots cryptocurrencies, and grassroots democratic federations---employ the social graph to establish their platform-specific communication network.

\subsection{Protocol Architecture}

Each agent maintains its social graph neighbourhood as a friends list containing named bidirectional channels to connected peers. The protocol processes three types of events: connection requests initiated by the agent's user, offers received from other agents through the network, and responses to the agent's own connection attempts. The architecture unifies all communication through a single merged input stream, with the friends list serving as both the social graph state and the routing table for outgoing messages.

The protocol achieves non-blocking asynchronous operation through GLP's synchronization mechanisms, enabling agents to handle multiple concurrent connection attempts, process friend messages, and respond to user commands simultaneously without deadlock or starvation.

\subsection{Initialization and Message Routing}

Each agent begins with the goal \verb|agent_init(Id, ChUser, ChNet)| where \verb|Id| is the agent's unique identifier, \verb|ChUser| provides bidirectional communication with the user interface, and \verb|ChNet| connects to the network for initial message routing. The initialization phase establishes the unified message processing architecture:

\Program{Social Graph Initialization}\label{program:social-init}
\begin{verbatim}
agent_init(Id, ch(UserIn, UserOut), ch(NetIn, NetOut)) :-
    merge(UserIn?, NetIn?, In),
    agent(Id?, In?, [friend(user, UserOut), friend(net, NetOut)]).
\end{verbatim}

The initialization extracts the input and output streams from the user and network channels, merges the input streams into a unified stream \verb|In|, and stores the output streams in the initial friends list with special identifiers ``user'' and ``net'' wrapped in \verb|friend| structures. This design treats the user interface and network as special cases of friends, enabling uniform message sending through the \verb|lookup_send| procedure regardless of destination type.

\subsection{Cold Call Protocol}

The cold call mechanism enables agents to establish friendship without prior shared variables. When agent $p$ wishes to befriend agent $q$, the protocol proceeds through four phases: user $p$ initiation, $p$ to $q$ offer transmission, user $q$ consultation, and if the response is positive then $p$--$q$ channel establishment.

\Program{Social Graph Cold-Call Befriending Protocol}\label{program:social-graph}
\begin{verbatim}
% User initiates cold call
agent(Id, [msg(user, Id1, connect(Target))|In], Fs) :-
    ground(Id?), ground(Target?), Id? =?= Id1? |
    lookup_send(net, msg(Id?, Target?, intro(Id?, Id?, Resp)), Fs?, Fs1),
    inject_msg(Resp?, Target?, Id?, In?, In1),
    agent(Id?, In1?, Fs1?).

% Received self-introduction (cold-call) - forward to user
agent(Id, [msg(From, Id1, intro(From1, From2, Resp))|In], Fs) :-
    ground(Id?), ground(From?), Id? =?= Id1?, From? =?= From1?, From? =?= From2? |
    lookup_send(user, msg(agent, user, befriend(From?, Resp?)), Fs?, Fs1),
    agent(Id?, In?, Fs1?).

% User decision on cold-call introduction
agent(Id, [msg(user, Id1, decision(Dec, From, Resp))|In], Fs) :-
    ground(Id?), Id? =?= Id1? |
    bind_response(Dec?, From?, Resp, Fs?, Fs1, In?, In1),
    agent(Id?, In1?, Fs1?).

% Response to sent cold-call introduction
agent(Id, [msg(From, Id1, response(Resp))|In], Fs) :-
    ground(Id?), ground(From?), Id? =?= Id1? |
    handle_response(Resp?, From?, Fs?, Fs1, In?, In1),
    agent(Id?, In1?, Fs1?).

inject_msg(Resp, Target, Id, Ys, [msg(Target?, Id?, response(Resp?))|Ys?]) :-
    known(Resp?) | true.
inject_msg(Resp, Target, Id, [Y|Ys], [Y?|Ys1?]) :-
    otherwise | inject_msg(Resp?, Target?, Id?, Ys?, Ys1).
\end{verbatim}

The first clause handles user-initiated connections by sending an offer containing an unbound response variable through the network. The \verb|inject_msg| procedure defers insertion of the response message into the input stream until the response variable becomes bound, while allowing the stream to continue flowing. The second clause receives offers from other agents and forwards them to the user interface for approval. The third clause processes user decisions, calling \verb|bind_response| to handle acceptance or rejection. The fourth clause handles responses to the agent's own offers.

When the response variable is known, \verb|inject_msg| inserts the response message at the output stream and terminates. Until then, it passes input stream messages to its output using the \verb|otherwise| guard. This ensures the protocol remains responsive while awaiting responses to its own connection attempts.

\subsection{Channel Establishment and Response Handling}

When an offer is accepted, both agents must establish symmetric channel configurations and merge the new friend's input stream into their main processing loop:

\Program{Response Processing}\label{program:response-handling}
\begin{verbatim}
bind_response(yes, From, accept(RetCh?), Fs, Fs1?, In, In1?) :-
    new_channel(RetCh, LocalCh) |
    handle_response(accept(LocalCh?), From?, Fs?, Fs1, In?, In1).
bind_response(no, _, no, Fs, Fs?, In, In?).

handle_response(accept(ch(FIn, FOut?)), From, Fs, Fs1?, In, In1?) :-
    ground(From?) |
    merge(In?, FIn?, In1),
    add_friend_and_notify(From?, FOut, Fs?, Fs1).
handle_response(no, From, Fs, Fs1?, In, In?) :-
    ground(From?) |
    lookup_send(user, msg(agent, user, rejected(From?)), Fs?, Fs1).

add_friend_and_notify(From, FOut?, Fs, [friend(From?, FOut)|Fs1?]) :-
    ground(From?) |
    lookup_send(user, msg(agent, user, connected(From?)), Fs?, Fs1).
\end{verbatim}

When accepting an offer, \verb|bind_response| creates a new channel pair using \verb|new_channel|, which produces two channels with crossed input/output streams. The acceptor retains one channel and sends the other through the response variable, ensuring both agents receive complementary channel endpoints. The \verb|handle_response| procedure merges the new friend's input stream into the main message flow and calls \verb|add_friend_and_notify| to add the friend's output stream to the friends list and notify the user of the successful connection. When a connection is rejected, the user is notified accordingly.

\subsection{The Social Graph Protocol is Grassroots}

The grassroots social graph protocol uses cold calls (Program~\ref{program:social-graph}) for initial contact between disconnected agents. Cold calls utilize the Network transaction (Definition~\ref{definition:maGLP}) to establish shared variables between agents who previously had none. Therefore, by Proposition~\ref{prop:app-grassroots}, the grassroots social graph protocol is grassroots.

\begin{corollary}[Grassroots Social Graph is Grassroots]
The GLP implementation of the grassroots social graph protocol is grassroots.
\end{corollary}

This result establishes that any set of agents $P$ running the social graph protocol can operate independently, yet when embedded in a larger set $P'$, agents in $P$ can establish friendships with agents in $P' \setminus P$ through cold calls, leaving ``alien traces'' (shared variables with non-$P$ agents) in their local states.
